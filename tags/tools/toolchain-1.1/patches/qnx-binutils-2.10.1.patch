diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/archive.c binutils/bfd/archive.c
--- binutils-2.10.1/bfd/archive.c	2000-05-28 20:57:49.000000000 +1000
+++ binutils/bfd/archive.c	2001-02-27 05:19:38.000000000 +1000
@@ -1860,6 +1860,11 @@
 			  map = new_map;
 			}
 
+		      if ( syms[src_count]->name == NULL ) {
+			  (*_bfd_error_handler)
+			    ("Error: missing symbol name in %s\n", current->filename );
+			  goto error_return;
+		      }
 		      namelen = strlen (syms[src_count]->name);
 		      map[orl_count].name = ((char **)
 					     bfd_alloc (arch,
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/bfd-in2.h binutils/bfd/bfd-in2.h
--- binutils-2.10.1/bfd/bfd-in2.h	2000-04-29 11:45:48.000000000 +1000
+++ binutils/bfd/bfd-in2.h	2001-02-27 05:19:38.000000000 +1000
@@ -1960,6 +1960,7 @@
   BFD_RELOC_MIPS_GOT_PAGE,
   BFD_RELOC_MIPS_GOT_OFST,
   BFD_RELOC_MIPS_GOT_DISP,
+  BFD_RELOC_MIPS_QNX_COPY,
 
 
 /* i386/elf relocations */
@@ -2086,6 +2087,14 @@
   BFD_RELOC_SH_CODE,
   BFD_RELOC_SH_DATA,
   BFD_RELOC_SH_LABEL,
+  BFD_RELOC_SH_GOT32,
+  BFD_RELOC_SH_PLT32,
+  BFD_RELOC_SH_COPY,
+  BFD_RELOC_SH_GLOB_DAT,
+  BFD_RELOC_SH_JMP_SLOT,
+  BFD_RELOC_SH_RELATIVE,
+  BFD_RELOC_SH_GOTOFF,
+  BFD_RELOC_SH_GOTPC,
 
 /* Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
 be zero and is not stored in the instruction. */
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/config.bfd binutils/bfd/config.bfd
--- binutils-2.10.1/bfd/config.bfd	2000-09-07 06:57:43.000000000 +1000
+++ binutils/bfd/config.bfd	2001-05-29 06:57:53.000000000 +1000
@@ -34,7 +34,7 @@
 thumb*)	targ_archs=bfd_arm_arch ;;
 c30*)	targ_archs=bfd_tic30_arch ;;
 hppa*)	targ_archs=bfd_hppa_arch ;;
-i[3456]86) targ_archs=bfd_i386_arch ;;
+x86 | i[3456]86) targ_archs=bfd_i386_arch ;;
 i370)   targ_archs=bfd_i370_arch ;;
 m68*)	targ_archs=bfd_m68k_arch ;;
 m88*)	targ_archs=bfd_m88k_arch ;;
@@ -138,7 +138,11 @@
     targ_defvec=bfd_elf32_littlearm_oabi_vec
     targ_selvecs=bfd_elf32_bigarm_oabi_vec
     ;;
-
+  arm-*-nto* | nto*arm*)
+   targ_defvec=bfd_elf32_littlearm_vec
+   targ_selvecs=bfd_elf32_bigarm_vec
+   targ_cflags=-D__QNXTARGET__
+   ;;
   thumb-*-coff)
     targ_defvec=armcoff_little_vec
     targ_selvecs=armcoff_big_vec
@@ -254,6 +258,11 @@
     targ_defvec=bfd_elf32_i386_vec
     targ_selvecs=i386coff_vec
     ;;
+  i[3456]86-*-qnx* | i[3456]86-*-nto* | x86-*nto*)
+    targ_defvec=bfd_elf32_i386_vec
+    targ_selvecs=i386coff_vec
+    targ_cflags=-D__QNXTARGET__
+    ;;
   i[3456]86-*-msdosdjgpp* | i[3456]*-*-go32* | i[3456]86-go32-rtems* )
     targ_defvec=go32coff_vec
     targ_selvecs="go32stubbedcoff_vec i386aout_vec"
@@ -576,10 +585,20 @@
     targ_defvec=bfd_elf32_littlemips_vec
     targ_selvecs="bfd_elf32_bigmips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec"
     ;;
+  mips*el-*-nto*)
+    targ_defvec=bfd_elf32_littlemips_vec
+    targ_selvecs="bfd_elf32_bigmips_vec"
+    targ_cflags=-D__QNXTARGET__
+    ;;
   mips*-*-elf* | mips*-*-rtems* | mips*-*-vxworks*)
     targ_defvec=bfd_elf32_bigmips_vec
     targ_selvecs="bfd_elf32_littlemips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec"
     ;;
+  mips*-*-nto*)
+    targ_defvec=bfd_elf32_bigmips_vec
+    targ_selvecs="bfd_elf32_littlemips_vec"
+    targ_cflags=-D__QNXTARGET__
+    ;;
   mips*-*-none)
     targ_defvec=bfd_elf32_bigmips_vec
     targ_selvecs="bfd_elf32_littlemips_vec bfd_elf64_bigmips_vec bfd_elf64_littlemips_vec"
@@ -629,6 +648,11 @@
     targ_defvec=bfd_elf32_powerpc_vec
     targ_selvecs="rs6000coff_vec bfd_elf32_powerpcle_vec ppcboot_vec"
     ;;
+  powerpc-*-nto* | ppc*-nto-*)
+    targ_defvec=bfd_elf32_powerpc_vec
+    targ_selvecs="rs6000coff_vec bfd_elf32_powerpcle_vec ppcboot_vec"
+    targ_cflags=-D__QNXTARGET__
+    ;;
   powerpc-*-macos* | powerpc-*-mpw*)
     targ_defvec=pmac_xcoff_vec
     ;;
@@ -642,7 +666,11 @@
     targ_defvec=bfd_elf32_powerpcle_vec
     targ_selvecs="rs6000coff_vec bfd_elf32_powerpc_vec ppcboot_vec"
     ;;
-
+  powerpcle-*-nto*)
+    targ_defvec=bfd_elf32_powerpcle_vec
+    targ_selvecs="rs6000coff_vec bfd_elf32_powerpc_vec ppcboot_vec"
+    targ_cflags=-D__QNXTARGET__
+    ;;
   powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin*)
     targ_defvec=bfd_powerpcle_pe_vec
     targ_selvecs="bfd_powerpcle_pei_vec bfd_powerpc_pei_vec bfd_powerpcle_pe_vec bfd_powerpc_pe_vec"
@@ -652,10 +680,16 @@
     targ_defvec=rs6000coff_vec
     ;;
 
-  sh-*-elf* | sh-*-rtemself*)
+  sh-*-elf* | sh-*-rtemself* )
+    targ_defvec=bfd_elf32_sh_vec
+    targ_selvecs="bfd_elf32_shl_vec shcoff_vec shlcoff_vec shcoff_small_vec shlcoff_small_vec"
+    targ_underscore=yes
+    ;;
+  sh-*-nto*)
     targ_defvec=bfd_elf32_sh_vec
     targ_selvecs="bfd_elf32_shl_vec shcoff_vec shlcoff_vec shcoff_small_vec shlcoff_small_vec"
     targ_underscore=yes
+    targ_cflags=-D__QNXTARGET__
     ;;
   sh-*-pe)
     targ_defvec=shlpe_vec
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/doc/bfdint.texi binutils/bfd/doc/bfdint.texi
--- binutils-2.10.1/bfd/doc/bfdint.texi	2000-05-01 01:07:52.000000000 +1000
+++ binutils/bfd/doc/bfdint.texi	2001-02-27 04:45:14.000000000 +1000
@@ -19,7 +19,7 @@
 helpful when working on BFD.  It is very incomplete.
 
 This document is not updated regularly, and may be out of date.  It was
-last modified on $Date: 2000/04/30 15:07:52 $.
+last modified on $Date: 2001/02/26 18:45:14 $.
 
 The initial version of this document was written by Ian Lance Taylor
 @email{ian@@cygnus.com}.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/doc/bfd.texinfo binutils/bfd/doc/bfd.texinfo
--- binutils-2.10.1/bfd/doc/bfd.texinfo	1999-05-03 17:28:58.000000000 +1000
+++ binutils/bfd/doc/bfd.texinfo	2001-02-27 04:45:14.000000000 +1000
@@ -1,6 +1,6 @@
 \input texinfo.tex
 @setfilename bfd.info
-@c $Id: bfd.texinfo,v 1.1.1.1 1999/05/03 07:28:58 rth Exp $
+@c $Id: bfd.texinfo,v 1.1.1.1 2001/02/26 18:45:14 keith Exp $
 @tex
 % NOTE LOCAL KLUGE TO AVOID TOO MUCH WHITESPACE
 \global\long\def\example{%
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/dwarf1.c binutils/bfd/dwarf1.c
--- binutils-2.10.1/bfd/dwarf1.c	1999-10-18 22:45:21.000000000 +1000
+++ binutils/bfd/dwarf1.c	2001-05-25 03:30:22.000000000 +1000
@@ -467,7 +467,7 @@
   struct dwarf1_unit* eachUnit;
 
   /* What address are we looking for? */
-  bfd_vma addr = offset + section->vma;
+  unsigned long addr = (unsigned long) (offset + section->vma);
 
   *filename_ptr = NULL;
   *functionname_ptr = NULL;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/dwarf2.c binutils/bfd/dwarf2.c
--- binutils-2.10.1/bfd/dwarf2.c	2000-04-19 21:13:16.000000000 +1000
+++ binutils/bfd/dwarf2.c	2001-02-27 05:19:38.000000000 +1000
@@ -1270,6 +1270,7 @@
       return 0;
     }
 
+#ifndef __QNXNTO__
   if (addr_size > sizeof (bfd_vma))
     {
       (*_bfd_error_handler) (_("Dwarf Error: found address size '%u', this reader can not handle sizes greater than '%u'."),
@@ -1278,6 +1279,7 @@
       bfd_set_error (bfd_error_bad_value);
       return 0;
     }
+#endif
 
   if (addr_size != 2 && addr_size != 4 && addr_size != 8)
     {
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/elf32-arm.h binutils/bfd/elf32-arm.h
--- binutils-2.10.1/bfd/elf32-arm.h	2000-11-07 18:44:11.000000000 +1000
+++ binutils/bfd/elf32-arm.h	2001-03-01 02:51:39.000000000 +1000
@@ -3253,7 +3253,11 @@
 
 #define ELF_ARCH			bfd_arch_arm
 #define ELF_MACHINE_CODE		EM_ARM
+#ifdef __QNXTARGET__
+#define ELF_MAXPAGESIZE			0x1000
+#else
 #define ELF_MAXPAGESIZE			0x8000
+#endif
 
 
 #define bfd_elf32_bfd_copy_private_bfd_data 	elf32_arm_copy_private_bfd_data
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/elf32-mips.c binutils/bfd/elf32-mips.c
--- binutils-2.10.1/bfd/elf32-mips.c	2000-10-23 22:38:15.000000000 +1000
+++ binutils/bfd/elf32-mips.c	2001-03-01 02:51:39.000000000 +1000
@@ -303,6 +303,14 @@
 #define STUB_LI16 0x34180000	/* ori t8,zero,0 */
 #define MIPS_FUNCTION_STUB_SIZE (16)
 
+/* Stubs for QNX pic fucntion calls. Allow calling a lib from non-pic code */
+#define STUB_QNX_LW(abfd) \
+  (SGI_COMPAT (abfd)					\
+   ? 0x8f998010			/* lw at,0x8010(gp) */	\
+   : 0x8f998000)		/* lw at,0x0000(gp) */
+#define STUB_QNX_NOP 0x00000000
+#define STUB_QNX_JR  0x03200008	/* jal t9 */
+   
 #if 0
 /* We no longer try to identify particular sections for the .dynsym
    section.  When we do, we wind up crashing if there are other random
@@ -944,6 +952,26 @@
 	 0x07ff001f,	        /* dst_mask */
 	 false);		/* pcrel_offset */
 
+/* Do a QNX pic copy relocation. This is used only with dynamic linking.
+   This works in the same way as copy relocs on other platforms: the data
+   object must exist both in the object and in the shared lib. The dynamic 
+   linker copies the data from the shared object to the executable at runtime.
+   This is needed because the exec. does not access the data through the GOT.
+   */
+static reloc_howto_type elf_mips_qnx_copy_howto =
+  HOWTO (R_MIPS_QNX_COPY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MIPS_QNX_COPY",	/* name */
+	 false,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 false);		/* pcrel_offset */
 
 /* GNU extensions for embedded-pic.  */
 /* High 16 bits of symbol value, pc-relative.  */
@@ -1314,6 +1342,16 @@
     return _bfd_mips_elf_hi16_reloc (abfd, reloc_entry, symbol, data,
 				     input_section, output_bfd, error_message);
 
+  /* Else we might be doing a reloc from a local symbol, but we want it
+     to be a got16 reloc, instead of a reloc against a section */
+  if (output_bfd != (bfd *) NULL
+      && (symbol->flags & BSF_GLOBAL))
+    {
+      reloc_entry->address += input_section->output_offset;
+    //  reloc_entry->addend = 0;
+      return bfd_reloc_ok;
+    }
+  
   abort ();
 }
 
@@ -1923,7 +1961,8 @@
   { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
   { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
   { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
-  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
+  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP },
+  { BFD_RELOC_MIPS_QNX_COPY, R_MIPS_QNX_COPY }
 };
 
 /* Given a BFD reloc type, return a howto structure.  */
@@ -7080,6 +7119,49 @@
 	}
     }
 
+  /* The .rel.bss section holds copy relocs.  This section is not
+     normally needed.  We need to create it here, though, so that the
+     linker will map it to an output section.  We can't just create it
+     only if we need it, because we will not know whether we need it
+     until we have seen all the input files, and the first time the
+     main linker code calls BFD after examining all the input files
+     (size_dynamic_sections) the input sections have already been
+     mapped to the output sections.  If the section turns out not to
+     be needed, we can discard it later.  We will never need this
+     section when generating a shared object, since they do not use
+     copy relocs.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".rel.bss");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+	  || ! bfd_set_section_alignment (abfd, s, 3))
+	return false;
+    }
+
+  /* We also make a .bss and .sbss section here. This is needed in
+     case we have copy relocs, but didn't have a bss section in
+     from the normal symbols. */
+
+  if ((! info->shared) 
+      && bfd_get_section_by_name (abfd, ".bss") == NULL)
+    {
+      s = bfd_make_section (abfd, ".bss");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, SEC_RELOC | SEC_ALLOC | SEC_HAS_CONTENTS)
+	  || ! bfd_set_section_alignment (abfd, s, 3))
+	return false;
+    }
+
+  if ((! info->shared)
+      && bfd_get_section_by_name (abfd, ".sbss") == NULL)
+    {
+      s = bfd_make_section (abfd, ".sbss");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, SEC_RELOC | SEC_ALLOC | SEC_HAS_CONTENTS)
+	  || ! bfd_set_section_alignment (abfd, s, 3))
+	return false;
+    } 
   return true;
 }
 
@@ -7483,6 +7565,7 @@
 	    case R_MIPS_32:
 	    case R_MIPS_REL32:
 	    case R_MIPS_64:
+	    case R_MIPS_QNX_COPY: 
 	      if (dynobj == NULL
 		  && (info->shared || h != NULL)
 		  && (sec->flags & SEC_ALLOC) != 0)
@@ -7555,6 +7638,7 @@
 	case R_MIPS_32:
 	case R_MIPS_REL32:
 	case R_MIPS_64:
+	case R_MIPS_QNX_COPY:
 	  if ((info->shared || h != NULL)
 	      && (sec->flags & SEC_ALLOC) != 0)
 	    {
@@ -7767,12 +7851,14 @@
   bfd *dynobj;
   struct mips_elf_link_hash_entry *hmips;
   asection *s;
+  unsigned int power_of_two;
 
   dynobj = elf_hash_table (info)->dynobj;
 
   /* Make sure we know what is going on here.  */
   BFD_ASSERT (dynobj != NULL
 	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
+		  || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY)
 		  || h->weakdef != NULL
 		  || ((h->elf_link_hash_flags
 		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
@@ -7839,7 +7925,55 @@
   /* This is a reference to a symbol defined by a dynamic object which
      is not a function.  */
 
-  return true;
+  if (info->shared)
+  	return true;
+  /* In this case, it is a data reference; we must therefore allocate it
+     in the bss/sbss, and generate a copy relocation for it.
+   */
+  if(h->size <= elf_gp_size (dynobj))
+    s = bfd_get_section_by_name(dynobj, ".sbss");
+  else 
+    s = bfd_get_section_by_name(dynobj, ".bss");
+  BFD_ASSERT (s != NULL);
+
+  /* Now we need to set up a copy relocation for this object */
+  /* Come back and check flags here for QNX_COPY... */
+  if (1 || (h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      asection *srel;
+// fprintf(stderr,"Going to add to .rel.bss, size %d\n",h->size);
+      srel = bfd_get_section_by_name(dynobj, ".rel.bss");
+      BFD_ASSERT (srel != NULL); 
+      srel->_raw_size += sizeof (Elf32_External_Rel);
+      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
+    }
+
+  /* We need to figure out the alignment required for this symbol.  I
+     have no idea how ELF linkers handle this.  */
+  power_of_two = bfd_log2 (h->size);
+  if (power_of_two > 3)
+    power_of_two = 3;
+
+  /* Apply the required alignment.  */
+  s->_raw_size = BFD_ALIGN (s->_raw_size,
+			    (bfd_size_type) (1 << power_of_two));
+  if (power_of_two > bfd_get_section_alignment (dynobj, s))
+    {
+      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
+	return false;
+    }
+
+  /* Define the symbol as being at this point in the section.  */
+  h->root.u.def.section = s;
+  h->root.u.def.value = s->_raw_size;
+
+  /* Increment the section size to make room for the symbol.  */
+//fprintf(stderr, "section cooked size %x raw %x new %x sym size %x\n", 
+//(unsigned) s->_cooked_size, (unsigned) s->_raw_size, (unsigned) (s->_cooked_size + h->size), (unsigned) h->size);
+
+  s->_raw_size += h->size;
+  /* Work around bug in sbss handling */
+  s->_cooked_size += h->size;
 }
 
 /* This function is called after all the input files have been read,
@@ -8145,7 +8279,8 @@
 	return false;
 
       if (bfd_get_section_by_name (dynobj,
-				   MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)))
+				   MIPS_ELF_REL_DYN_SECTION_NAME (dynobj))
+      ||(bfd_get_section_by_name (dynobj, ".rel.bss")))
 	{
 	  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_REL, 0))
 	    return false;
@@ -8299,11 +8434,23 @@
   struct mips_got_info *g;
   const char *name;
   struct mips_elf_link_hash_entry *mh;
+  flagword flags;
+
+  /* To see if we are linking PIC */
+  flags = elf_elfheader (output_bfd)->e_flags;
 
   dynobj = elf_hash_table (info)->dynobj;
   gval = sym->st_value;
   mh = (struct mips_elf_link_hash_entry *) h;
 
+  BFD_ASSERT (h->dynindx != -1);
+
+  sgot = bfd_get_section_by_name (dynobj, ".got");
+  BFD_ASSERT (sgot != NULL);
+  BFD_ASSERT (elf_section_data (sgot) != NULL);
+  g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
+  BFD_ASSERT (g != NULL);
+
   if (h->plt.offset != (bfd_vma) -1)
     {
       asection *s;
@@ -8320,6 +8467,8 @@
 
       /* Fill the stub.  */
       p = stub;
+      if ((flags & EF_MIPS_PIC) || (flags & EF_MIPS_CPIC))
+	{
       bfd_put_32 (output_bfd, STUB_LW(output_bfd), p);
       p += 4;
       bfd_put_32 (output_bfd, STUB_MOVE, p);
@@ -8332,6 +8481,27 @@
       bfd_put_32 (output_bfd, STUB_JALR, p);
       p += 4;
       bfd_put_32 (output_bfd, STUB_LI16 + h->dynindx, p);
+	}
+      else  /* Non-pic case: stub is used to jump to shared lib */
+	{
+	  bfd_size_type offset;
+/*
+   GP Dec 21, 2000.  In the simple case, g->global_gotsym is NULL, so test
+   against it.  I _hope_ this is right...
+*/
+          if(g->global_gotsym)
+                offset = (h->dynindx - g->global_gotsym->dynindx + g->local_gotno) * 4;
+          else
+                offset = (h->dynindx + g->local_gotno) * 4;
+          bfd_put_32 (output_bfd, (STUB_LW(output_bfd) & 0xffff0000) |
+		(0xffff & (0x8010 + offset)), p);
+          p += 4;
+          bfd_put_32 (output_bfd, STUB_QNX_JR, p);
+          p += 4;
+          bfd_put_32 (output_bfd, STUB_QNX_NOP, p);
+          p += 4;
+          bfd_put_32 (output_bfd, STUB_QNX_NOP, p);
+	}
 
       BFD_ASSERT (h->plt.offset <= s->_raw_size);
       memcpy (s->contents + h->plt.offset, stub, MIPS_FUNCTION_STUB_SIZE);
@@ -8344,9 +8514,17 @@
 	 to reset the global offset table entry for this external
 	 to its stub address when unlinking a shared object.  */
       gval = s->output_section->vma + s->output_offset + h->plt.offset;
-      sym->st_value = gval;
+      if ((flags & EF_MIPS_PIC) || (flags & EF_MIPS_CPIC) || !info->shared)
+	{
+      	  sym->st_value = gval;
+	}
+      else 
+	{
+	  sym->st_value = 0;
+	}	
     }
 
+#if 0
   BFD_ASSERT (h->dynindx != -1);
 
   sgot = mips_elf_got_section (dynobj);
@@ -8354,6 +8532,7 @@
   BFD_ASSERT (elf_section_data (sgot) != NULL);
   g = (struct mips_got_info *) elf_section_data (sgot)->tdata;
   BFD_ASSERT (g != NULL);
+#endif
 
   /* Run through the global symbol table, creating GOT entries for all
      the symbols that need them.  */
@@ -8464,6 +8643,28 @@
 	}
     }
 
+  /* Finish handling the QNX_COPY relocs if there are any */
+  if (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) 
+    {
+      asection *s;
+      Elf_Internal_Rel rel;
+
+      /* Set up the copy reloc */
+      BFD_ASSERT (h->dynindx != -1);
+      s = bfd_get_section_by_name (h->root.u.def.section->owner,
+				     ".rel.bss");
+      BFD_ASSERT (s != NULL);
+
+      rel.r_offset = (h->root.u.def.value
+		       + h->root.u.def.section->output_section->vma
+		       + h->root.u.def.section->output_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_MIPS_QNX_COPY);
+      bfd_elf32_swap_reloc_out (output_bfd, &rel,
+				 ((Elf32_External_Rel *) s->contents
+				  + s->reloc_count));
+      ++s->reloc_count;
+    }
+
   /* If this is a mips16 symbol, force the value to be even.  */
   if (sym->st_other == STO_MIPS16
       && (sym->st_value & 1) != 0)
@@ -8527,6 +8728,7 @@
 	      s = (bfd_get_section_by_name 
 		   (dynobj,
 		    MIPS_ELF_REL_DYN_SECTION_NAME (dynobj)));
+	      if (s == NULL) s = bfd_get_section_by_name (dynobj, ".rel.bss");
 	      BFD_ASSERT (s != NULL);
 	      dyn.d_un.d_val = MIPS_ELF_REL_SIZE (dynobj);
 	      break;
@@ -8989,7 +9191,9 @@
    a value of 0x1000, and we are compatible.  */
 #define ELF_MAXPAGESIZE			0x1000
 
+#if !defined(__QNXNTO__) && !defined(__QNXTARGET__)
 #define elf_backend_collect		true
+#endif
 #define elf_backend_type_change_ok	true
 #define elf_backend_can_gc_sections	true
 #define elf_backend_sign_extend_vma	true
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/elf32-ppc.c binutils/bfd/elf32-ppc.c
--- binutils-2.10.1/bfd/elf32-ppc.c	2000-11-04 03:15:59.000000000 +1000
+++ binutils/bfd/elf32-ppc.c	2001-06-23 04:35:55.000000000 +1000
@@ -3050,7 +3050,8 @@
                              It's here to avoid a crash when
                              generating a shared library with DWARF
                              debugging information.  */
-		          || (input_section->flags & SEC_DEBUGGING) != 0)
+		     	|| ((input_section->flags & SEC_DEBUGGING) != 0
+			  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))	
 		      && (r_type == R_PPC_ADDR32
 			  || r_type == R_PPC_ADDR24
 			  || r_type == R_PPC_ADDR16
@@ -3185,7 +3186,7 @@
 	  if (info->shared)
 	    {
 	      Elf_Internal_Rela outrel;
-	      boolean skip;
+	      boolean skip, relocate;
 
 #ifdef DEBUG
 	      fprintf (stderr, "ppc_elf_relocate_section need to create relocation for %s\n",
@@ -3217,6 +3218,7 @@
 		}
 
 	      skip = false;
+	      relocate = false;
 
 	      if (elf_section_data (input_section)->stab_info == NULL)
 		outrel.r_offset = rel->r_offset;
@@ -3237,10 +3239,11 @@
 	      outrel.r_offset += (input_section->output_section->vma
 				  + input_section->output_offset);
 
-	      if (skip)
+	      if (skip) {
 		memset (&outrel, 0, sizeof outrel);
 	      /* h->dynindx may be -1 if this symbol was marked to
                  become local.  */
+               }
 	      else if (h != NULL
 		       && ((! info->symbolic && h->dynindx != -1)
 			   || (h->elf_link_hash_flags
@@ -3249,9 +3252,14 @@
 		  BFD_ASSERT (h->dynindx != -1);
 		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
 		  outrel.r_addend = rel->r_addend;
+		  if ((input_section->flags & SEC_ALLOC) != 0)
+		     relocate = false;
+		  else
+		     relocate = true;
 		}
 	      else
 		{
+		  relocate = true;
 		  if (r_type == R_PPC_ADDR32)
 		    {
 		      outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
@@ -3310,8 +3318,12 @@
                  reloc in an unallocated section.  */
 	      if (skip
 		  || (input_section->flags & SEC_ALLOC) != 0
-		  || ELF32_R_TYPE (outrel.r_info) != R_PPC_RELATIVE)
-		continue;
+		  || ELF32_R_TYPE (outrel.r_info) != R_PPC_RELATIVE) {
+//		  if ( relocate )
+//		      fprintf( stderr, "wanted to skip relocation of %s in %s, but relocate=%s\n", sym_name, input_section->name,  relocate?"true":"false" );
+		 if ( !relocate )
+		    continue;
+	       }
 	    }
 
 	  /* Arithmetic adjust relocations that aren't going into a
@@ -3729,7 +3741,11 @@
 #define TARGET_BIG_NAME		"elf32-powerpc"
 #define ELF_ARCH		bfd_arch_powerpc
 #define ELF_MACHINE_CODE	EM_PPC
+#ifdef __QNXTARGET__
+#define ELF_MAXPAGESIZE		0x1000   /* Temp. fix for mkifs woes... */
+#else
 #define ELF_MAXPAGESIZE		0x10000
+#endif
 #define elf_info_to_howto	ppc_elf_info_to_howto
 
 #ifdef  EM_CYGNUS_POWERPC
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/elf32-sh.c binutils/bfd/elf32-sh.c
--- binutils-2.10.1/bfd/elf32-sh.c	2000-03-02 06:39:07.000000000 +1000
+++ binutils/bfd/elf32-sh.c	2001-06-23 04:35:55.000000000 +1000
@@ -55,6 +55,25 @@
 static bfd_byte *sh_elf_get_relocated_section_contents
   PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
 	   bfd_byte *, boolean, asymbol **));
+static boolean sh_elf_check_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, asection *,
+	   const Elf_Internal_Rela *));
+
+static struct bfd_hash_entry *elf_sh_link_hash_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static struct bfd_link_hash_table *elf_sh_link_hash_table_create
+  PARAMS ((bfd *));
+static boolean elf_sh_adjust_dynamic_symbol
+  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
+static boolean elf_sh_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+static boolean elf_sh_finish_dynamic_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+	   Elf_Internal_Sym *));
+static boolean elf_sh_finish_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+#define USE_RELA		/* we want RELA relocations, not REL */
 
 static reloc_howto_type sh_elf_howto_table[] =
 {
@@ -420,6 +439,251 @@
          0,                     /* dst_mask */
          false),                /* pcrel_offset */
 
+  EMPTY_HOWTO (36),
+  EMPTY_HOWTO (37),
+  EMPTY_HOWTO (38),
+  EMPTY_HOWTO (39),
+  EMPTY_HOWTO (40),
+  EMPTY_HOWTO (41),
+  EMPTY_HOWTO (42),
+  EMPTY_HOWTO (43),
+  EMPTY_HOWTO (44),
+  EMPTY_HOWTO (45),
+  EMPTY_HOWTO (46),
+  EMPTY_HOWTO (47),
+  EMPTY_HOWTO (48),
+  EMPTY_HOWTO (49),
+  EMPTY_HOWTO (50),
+  EMPTY_HOWTO (51),
+  EMPTY_HOWTO (52),
+  EMPTY_HOWTO (53),
+  EMPTY_HOWTO (54),
+  EMPTY_HOWTO (55),
+  EMPTY_HOWTO (56),
+  EMPTY_HOWTO (57),
+  EMPTY_HOWTO (58),
+  EMPTY_HOWTO (59),
+  EMPTY_HOWTO (60),
+  EMPTY_HOWTO (61),
+  EMPTY_HOWTO (62),
+  EMPTY_HOWTO (63),
+  EMPTY_HOWTO (64),
+  EMPTY_HOWTO (65),
+  EMPTY_HOWTO (66),
+  EMPTY_HOWTO (67),
+  EMPTY_HOWTO (68),
+  EMPTY_HOWTO (69),
+  EMPTY_HOWTO (70),
+  EMPTY_HOWTO (71),
+  EMPTY_HOWTO (72),
+  EMPTY_HOWTO (73),
+  EMPTY_HOWTO (74),
+  EMPTY_HOWTO (75),
+  EMPTY_HOWTO (76),
+  EMPTY_HOWTO (77),
+  EMPTY_HOWTO (78),
+  EMPTY_HOWTO (79),
+  EMPTY_HOWTO (80),
+  EMPTY_HOWTO (81),
+  EMPTY_HOWTO (82),
+  EMPTY_HOWTO (83),
+  EMPTY_HOWTO (84),
+  EMPTY_HOWTO (85),
+  EMPTY_HOWTO (86),
+  EMPTY_HOWTO (87),
+  EMPTY_HOWTO (88),
+  EMPTY_HOWTO (89),
+  EMPTY_HOWTO (90),
+  EMPTY_HOWTO (91),
+  EMPTY_HOWTO (92),
+  EMPTY_HOWTO (93),
+  EMPTY_HOWTO (94),
+  EMPTY_HOWTO (95),
+  EMPTY_HOWTO (96),
+  EMPTY_HOWTO (97),
+  EMPTY_HOWTO (98),
+  EMPTY_HOWTO (99),
+  EMPTY_HOWTO (100),
+  EMPTY_HOWTO (101),
+  EMPTY_HOWTO (102),
+  EMPTY_HOWTO (103),
+  EMPTY_HOWTO (104),
+  EMPTY_HOWTO (105),
+  EMPTY_HOWTO (106),
+  EMPTY_HOWTO (107),
+  EMPTY_HOWTO (108),
+  EMPTY_HOWTO (109),
+  EMPTY_HOWTO (110),
+  EMPTY_HOWTO (111),
+  EMPTY_HOWTO (112),
+  EMPTY_HOWTO (113),
+  EMPTY_HOWTO (114),
+  EMPTY_HOWTO (115),
+  EMPTY_HOWTO (116),
+  EMPTY_HOWTO (117),
+  EMPTY_HOWTO (118),
+  EMPTY_HOWTO (119),
+  EMPTY_HOWTO (120),
+  EMPTY_HOWTO (121),
+  EMPTY_HOWTO (122),
+  EMPTY_HOWTO (123),
+  EMPTY_HOWTO (124),
+  EMPTY_HOWTO (125),
+  EMPTY_HOWTO (126),
+  EMPTY_HOWTO (127),
+  EMPTY_HOWTO (128),
+  EMPTY_HOWTO (129),
+  EMPTY_HOWTO (130),
+  EMPTY_HOWTO (131),
+  EMPTY_HOWTO (132),
+  EMPTY_HOWTO (133),
+  EMPTY_HOWTO (134),
+  EMPTY_HOWTO (135),
+  EMPTY_HOWTO (136),
+  EMPTY_HOWTO (137),
+  EMPTY_HOWTO (138),
+  EMPTY_HOWTO (139),
+  EMPTY_HOWTO (140),
+  EMPTY_HOWTO (141),
+  EMPTY_HOWTO (142),
+  EMPTY_HOWTO (143),
+  EMPTY_HOWTO (144),
+  EMPTY_HOWTO (145),
+  EMPTY_HOWTO (146),
+  EMPTY_HOWTO (147),
+  EMPTY_HOWTO (148),
+  EMPTY_HOWTO (149),
+  EMPTY_HOWTO (150),
+  EMPTY_HOWTO (151),
+  EMPTY_HOWTO (152),
+  EMPTY_HOWTO (153),
+  EMPTY_HOWTO (154),
+  EMPTY_HOWTO (155),
+  EMPTY_HOWTO (156),
+  EMPTY_HOWTO (157),
+  EMPTY_HOWTO (158),
+  EMPTY_HOWTO (159),
+
+  /* 0xa0: */
+  HOWTO (R_SH_GOT32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_GOT32",		/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 false),		/* pcrel_offset */
+
+  /* 0xa1: */
+  HOWTO (R_SH_PLT32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 true,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_PLT32",		/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 true),			/* pcrel_offset */
+
+  /* 0xa2: */
+  HOWTO (R_SH_COPY,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_COPY",		/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 false),		/* pcrel_offset */
+
+  /* 0xa3: */
+  HOWTO (R_SH_GLOB_DAT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_GLOB_DAT",	/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 false),		/* pcrel_offset */
+
+  /* 0xa4: */
+  HOWTO (R_SH_JMP_SLOT,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_JMP_SLOT",	/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 false),		/* pcrel_offset */
+
+  /* 0xa5: */
+  HOWTO (R_SH_RELATIVE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_RELATIVE",	/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 false),		/* pcrel_offset */
+
+  /* 0xa6: */
+  HOWTO (R_SH_GOTOFF,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 false,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_GOTOFF",		/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 false),		/* pcrel_offset */
+
+  /* 0xa7: */
+  HOWTO (R_SH_GOTPC,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 true,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* */
+	 "R_SH_GOTPC",		/* name */
+	 true,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 true),			/* pcrel_offset */
+
 };
 
 /* This function is used for normal relocs.  This is like the COFF
@@ -549,6 +813,14 @@
   { BFD_RELOC_SH_LABEL, R_SH_LABEL },
   { BFD_RELOC_VTABLE_INHERIT, R_SH_GNU_VTINHERIT },
   { BFD_RELOC_VTABLE_ENTRY, R_SH_GNU_VTENTRY },
+  { BFD_RELOC_SH_GOT32, R_SH_GOT32 },
+  { BFD_RELOC_SH_PLT32, R_SH_PLT32 },
+  { BFD_RELOC_SH_COPY, R_SH_COPY },
+  { BFD_RELOC_SH_GLOB_DAT, R_SH_GLOB_DAT },
+  { BFD_RELOC_SH_JMP_SLOT, R_SH_JMP_SLOT },
+  { BFD_RELOC_SH_RELATIVE, R_SH_RELATIVE },
+  { BFD_RELOC_SH_GOTOFF, R_SH_GOTOFF },
+  { BFD_RELOC_SH_GOTPC, R_SH_GOTPC },
 };
 
 /* Given a BFD reloc code, return the howto structure for the
@@ -584,6 +856,7 @@
 
   BFD_ASSERT (r < (unsigned int) R_SH_max);
   BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC || r > R_SH_LAST_INVALID_RELOC);
+  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC2 || r > R_SH_LAST_INVALID_RELOC2);
 
   cache_ptr->howto = &sh_elf_howto_table[r];
 }
@@ -1674,86 +1947,967 @@
   return true;
 }
 
-/* Relocate an SH ELF section.  */
+/* Functions for the sh ELF linker.  */
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_ENTRY_SIZE 28
+
+/* First entrie in an absolute procedure linkage table look like this.  */
+
+static const bfd_byte elf_sh_plt0_entry_be[PLT_ENTRY_SIZE] =
+{
+#if 0
+  0xd0, 0x04,	/* mov.l 1f,r0 */
+  0xd2, 0x05,	/* mov.l 2f,r2 */
+  0x60, 0x02,	/* mov.l @r0,r0 */
+  0x62, 0x22,	/* mov.l @r2,r2 */
+#else
+  0xd0, 0x04,	/* mov.l 1f,r0 */
+  0xd3, 0x05,	/* mov.l 2f,r3 */
+  0x60, 0x02,	/* mov.l @r0,r0 */
+  0x63, 0x32,	/* mov.l @r3,r3 */
+#endif
+  0x40, 0x2b,	/* jmp @r0 */
+  0xe0, 0x00,	/*  mov #0,r0 */
+  0x00, 0x09,	/* nop */
+  0x00, 0x09,	/* nop */
+  0x00, 0x09,	/* nop */
+  0x00, 0x09,	/* nop */
+  0, 0, 0, 0,	/* 1: replaced with address of .got.plt + 8.  */
+  0, 0, 0, 0,	/* 2: replaced with address of .got.plt + 4.  */
+};
+
+static const bfd_byte elf_sh_plt0_entry_le[PLT_ENTRY_SIZE] =
+{
+#if 0
+  0x04, 0xd0,	/* mov.l 1f,r0 */
+  0x05, 0xd2,	/* mov.l 2f,r2 */
+  0x02, 0x60,	/* mov.l @r0,r0 */
+  0x22, 0x62,	/* mov.l @r2,r2 */
+#else
+  0x04, 0xd0,	/* mov.l 1f,r0 */
+  0x05, 0xd3,	/* mov.l 2f,r3 */
+  0x02, 0x60,	/* mov.l @r0,r0 */
+  0x32, 0x63,	/* mov.l @r3,r3 */
+#endif
+  0x2b, 0x40,	/* jmp @r0 */
+  0x00, 0xe0,	/*  mov #0,r0 */
+  0x09, 0x00,	/* nop */
+  0x09, 0x00,	/* nop */
+  0x09, 0x00,	/* nop */
+  0x09, 0x00,	/* nop */
+  0, 0, 0, 0,	/* 1: replaced with address of .got.plt + 8.  */
+  0, 0, 0, 0,	/* 2: replaced with address of .got.plt + 4.  */
+};
+
+/* Sebsequent entries in an absolute procedure linkage table look like
+   this.  */
+
+static const bfd_byte elf_sh_plt_entry_be[PLT_ENTRY_SIZE] =
+{
+#if 0
+  0xd0, 0x04,	/* mov.l 1f,r0 */
+  0x60, 0x02,	/* mov.l @r0,r0 */
+  0xd2, 0x02,	/* mov.l 0f,r2 */
+  0x40, 0x2b,   /* jmp @r0 */
+  0x60, 0x23,	/*  mov r2,r0 */
+  0xd1, 0x03,	/* mov.l 2f,r1 */
+#else
+  0xd0, 0x04,	/* mov.l 1f,r0 */
+  0x60, 0x02,	/* mov.l @r0,r0 */
+  0xd3, 0x02,	/* mov.l 0f,r3 */
+  0x40, 0x2b,   /* jmp @r0 */
+  0x60, 0x33,	/*  mov r3,r0 */
+  0xd1, 0x03,	/* mov.l 2f,r1 */
+#endif
+  0x40, 0x2b,	/* jmp @r0 */
+  0x00, 0x09,	/* nop */
+  0, 0, 0, 0,	/* 0: replaced with address of .PLT0.  */
+  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
+  0, 0, 0, 0,	/* 2: replaced with offset into relocation table.  */
+};
+
+static const bfd_byte elf_sh_plt_entry_le[PLT_ENTRY_SIZE] =
+{
+#if 0
+  0x04, 0xd0,	/* mov.l 1f,r0 */
+  0x02, 0x60,	/* mov.l @r0,r0 */
+  0x02, 0xd2,	/* mov.l 0f,r2 */
+  0x2b, 0x40,   /* jmp @r0 */
+  0x23, 0x60,	/*  mov r2,r0 */
+  0x03, 0xd1,	/* mov.l 2f,r1 */
+#else
+  0x04, 0xd0,	/* mov.l 1f,r0 */
+  0x02, 0x60,	/* mov.l @r0,r0 */
+  0x02, 0xd3,	/* mov.l 0f,r3 */
+  0x2b, 0x40,   /* jmp @r0 */
+  0x33, 0x60,	/*  mov r3,r0 */
+  0x03, 0xd1,	/* mov.l 2f,r1 */
+#endif
+  0x2b, 0x40,	/* jmp @r0 */
+  0x09, 0x00,	/*  nop */
+  0, 0, 0, 0,	/* 0: replaced with address of .PLT.  */
+  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
+  0, 0, 0, 0,	/* 2: replaced with offset into relocation table.  */
+};
+
+/* Entries in a PIC procedure linkage table look like this.  */
+
+static const bfd_byte elf_sh_pic_plt_entry_be[PLT_ENTRY_SIZE] =
+{
+  0xd0, 0x04,	/* mov.l 1f,r0 */
+  0x00, 0xce,	/* mov.l @(r0,r12),r0 */
+  0x40, 0x2b,	/* jmp @r0 */
+  0x00, 0x09,	/*  nop */
+  0x50, 0xc2,	/* 0: mov.l @(8,r12),r0 */
+#if 0
+  0x52, 0xc1,	/* 1: mov.l @(4,r12),r2 */
+#else
+  0x53, 0xc1,	/* 1: mov.l @(4,r12),r3 */
+#endif
+  0xd1, 0x02,	/* mov.l 2f,r1 */
+  0x40, 0x2b,	/* jmp @r0 */
+  0xe0, 0x00,	/*  mov #0,r0 ! shows the type of PLT.  */
+  0x00, 0x09,	/* nop */
+  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
+  0, 0, 0, 0    /* 2: replaced with offset into relocation table.  */
+};
+
+static const bfd_byte elf_sh_pic_plt_entry_le[PLT_ENTRY_SIZE] =
+{
+  0x04, 0xd0,	/* mov.l 1f,r0 */
+  0xce, 0x00,	/* mov.l @(r0,r12),r0 */
+  0x2b, 0x40,	/* jmp @r0 */
+  0x09, 0x00,	/*  nop */
+  0xc2, 0x50,	/* 0: mov.l @(8,r12),r0 */
+#if 0
+  0xc1, 0x52,	/* 1: mov.l @(4,r12),r2 */
+#else
+  0xc1, 0x53,	/* 1: mov.l @(4,r12),r3 */
+#endif
+  0x02, 0xd1,	/* mov.l 2f,r1 */
+  0x2b, 0x40,	/* jmp @r0 */
+  0x00, 0xe0,	/*  mov #0,r0 ! shows the type of PLT.  */
+  0x09, 0x00,	/* nop */
+  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
+  0, 0, 0, 0    /* 2: replaced with offset into relocation table.  */
+};
+
+#ifdef __QNXTARGET__
+#define USE_SMALL_PLT_WITHOUT_LAZY_BINDING
+#endif
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+/* Small PLT stuff without lazy binding.  */
+
+#define SMALL_PLT_ENTRY_SIZE   12
+
+static const bfd_byte elf_sh_small_plt_entry_be[SMALL_PLT_ENTRY_SIZE] =
+{
+  0xd1, 0x01,	/* mov.l 0f,r1 */
+  0x61, 0x12,	/* mov.l @r1,r1 */
+  0x41, 0x2b,	/* jmp @r1 */
+  0x00, 0x09,   /* nop */
+  0, 0, 0, 0,	/* 0: replaced with address of this symbol in .got.  */
+};
+
+static const bfd_byte elf_sh_small_plt_entry_le[SMALL_PLT_ENTRY_SIZE] =
+{
+  0x01, 0xd1,	/* mov.l 0f,r1 */
+  0x12, 0x61,	/* mov.l @r1,r1 */
+  0x2b, 0x41,	/* jmp @r1 */
+  0x09, 0x00,   /* nop */
+  0, 0, 0, 0,	/* 0: replaced with address of this symbol in .got.  */
+};
+  
+static const bfd_byte elf_sh_pic_small_plt_entry_be[SMALL_PLT_ENTRY_SIZE] =
+{
+  0xd0, 0x01,	/* mov.l 1f,r0 */
+  0x00, 0xce,	/* mov.l @(r0,r12),r0 */
+  0x40, 0x2b,	/* jmp @r0 */
+  0x00, 0x09,	/*  nop */
+  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
+};
+
+static const bfd_byte elf_sh_pic_small_plt_entry_le[SMALL_PLT_ENTRY_SIZE] =
+{
+  0x01, 0xd0,	/* mov.l 1f,r0 */
+  0xce, 0x00,	/* mov.l @(r0,r12),r0 */
+  0x2b, 0x40,	/* jmp @r0 */
+  0x09, 0x00,	/*  nop */
+  0, 0, 0, 0,	/* 1: replaced with address of this symbol in .got.  */
+};
+#endif
+
+static const bfd_byte *elf_sh_plt0_entry;
+static const bfd_byte *elf_sh_plt_entry;
+static const bfd_byte *elf_sh_pic_plt_entry;
+
+/* Return size of a PLT entry.  */
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+#define elf_sh_sizeof_plt(info) \
+  (info->without_lazy_binding ? SMALL_PLT_ENTRY_SIZE : PLT_ENTRY_SIZE)
+#else
+#define elf_sh_sizeof_plt(info) PLT_ENTRY_SIZE
+#endif
+
+/* Return offset of the PLT0 address in an absolute PLT entry.  */
+#define elf_sh_plt_plt0_offset(info) 16
+
+/* Return offset of the linker in PLT0 entry.  */
+#define elf_sh_plt0_linker_offset(info) 20
+
+/* Return offset of the GOT id in PLT0 entry.  */
+#define elf_sh_plt0_gotid_offset(info) 24
+
+/* Return offset of the tempoline in PLT entry */
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+#define elf_sh_plt_temp_offset(info) (info->without_lazy_binding ? 0 : 8)
+#else
+#define elf_sh_plt_temp_offset(info) 8
+#endif
+
+/* Return offset of the symbol in PLT entry.  */
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+#define elf_sh_plt_symbol_offset(info) (info->without_lazy_binding ? 8 : 20)
+#else
+#define elf_sh_plt_symbol_offset(info) 20
+#endif
+
+/* Return offset of the relocation in PLT entry.  */
+#define elf_sh_plt_reloc_offset(info) 24
+
+/* The sh linker needs to keep track of the number of relocs that it
+   decides to copy in check_relocs for each symbol.  This is so that
+   it can discard PC relative relocs if it doesn't need them when
+   linking with -Bsymbolic.  We store the information in a field
+   extending the regular ELF linker hash table.  */
+
+/* This structure keeps track of the number of PC relative relocs we
+   have copied for a given symbol.  */
+
+struct elf_sh_pcrel_relocs_copied
+{
+  /* Next section.  */
+  struct elf_sh_pcrel_relocs_copied *next;
+  /* A section in dynobj.  */
+  asection *section;
+  /* Number of relocs copied in this section.  */
+  bfd_size_type count;
+};
+
+/* sh ELF linker hash entry.  */
+
+struct elf_sh_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Number of PC relative relocs copied for this symbol.  */
+  struct elf_sh_pcrel_relocs_copied *pcrel_relocs_copied;
+};
+
+/* sh ELF linker hash table.  */
+
+struct elf_sh_link_hash_table
+{
+  struct elf_link_hash_table root;
+};
+
+/* Declare this now that the above structures are defined.  */
+
+static boolean elf_sh_discard_copies
+  PARAMS ((struct elf_sh_link_hash_entry *, PTR));
+
+/* Traverse an sh ELF linker hash table.  */
+
+#define elf_sh_link_hash_traverse(table, func, info)			\
+  (elf_link_hash_traverse						\
+   (&(table)->root,							\
+    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
+    (info)))
+
+/* Get the sh ELF linker hash table from a link_info structure.  */
+
+#define elf_sh_hash_table(p) \
+  ((struct elf_sh_link_hash_table *) ((p)->hash))
+
+/* Create an entry in an sh ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+elf_sh_link_hash_newfunc (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct elf_sh_link_hash_entry *ret =
+    (struct elf_sh_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == (struct elf_sh_link_hash_entry *) NULL)
+    ret = ((struct elf_sh_link_hash_entry *)
+	   bfd_hash_allocate (table,
+			      sizeof (struct elf_sh_link_hash_entry)));
+  if (ret == (struct elf_sh_link_hash_entry *) NULL)
+    return (struct bfd_hash_entry *) ret;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_sh_link_hash_entry *)
+	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+				     table, string));
+  if (ret != (struct elf_sh_link_hash_entry *) NULL)
+    {
+      ret->pcrel_relocs_copied = NULL;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Create an sh ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+elf_sh_link_hash_table_create (abfd)
+     bfd *abfd;
+{
+  struct elf_sh_link_hash_table *ret;
+
+  ret = ((struct elf_sh_link_hash_table *)
+	 bfd_alloc (abfd, sizeof (struct elf_sh_link_hash_table)));
+  if (ret == (struct elf_sh_link_hash_table *) NULL)
+    return NULL;
+
+  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
+				       elf_sh_link_hash_newfunc))
+    {
+      bfd_release (abfd, ret);
+      return NULL;
+    }
+
+  return &ret->root.root;
+}
+
+/* Create dynamic sections when linking against a dynamic object.  */
 
 static boolean
-sh_elf_relocate_section (output_bfd, info, input_bfd, input_section,
-			 contents, relocs, local_syms, local_sections)
-     bfd *output_bfd ATTRIBUTE_UNUSED;
+sh_elf_create_dynamic_sections (abfd, info)
+     bfd *abfd;
      struct bfd_link_info *info;
-     bfd *input_bfd;
-     asection *input_section;
-     bfd_byte *contents;
-     Elf_Internal_Rela *relocs;
-     Elf_Internal_Sym *local_syms;
-     asection **local_sections;
 {
-  Elf_Internal_Shdr *symtab_hdr;
-  struct elf_link_hash_entry **sym_hashes;
-  Elf_Internal_Rela *rel, *relend;
+  flagword flags, pltflags;
+  register asection *s;
+  struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  int ptralign = 0;
 
-  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
-  sym_hashes = elf_sym_hashes (input_bfd);
+  switch (bed->s->arch_size)
+    {
+    case 32: ptralign = 2; break;
+    case 64: ptralign = 3; break;
+    default: abort();
+    }
 
-  rel = relocs;
-  relend = relocs + input_section->reloc_count;
-  for (; rel < relend; rel++)
+  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
+     .rel[a].bss sections.  */
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED);
+
+  pltflags = flags;
+  pltflags |= SEC_CODE;
+  if (bed->plt_not_loaded)
+    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
+  if (bed->plt_readonly)
+    pltflags |= SEC_READONLY;
+
+  s = bfd_make_section (abfd, ".plt");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, pltflags)
+      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
+    return false;
+
+  if (bed->want_plt_sym)
     {
-      int r_type;
-      reloc_howto_type *howto;
-      unsigned long r_symndx;
-      Elf_Internal_Sym *sym;
-      asection *sec;
-      struct elf_link_hash_entry *h;
-      bfd_vma relocation;
-      bfd_vma addend = (bfd_vma)0;
-      bfd_reloc_status_type r;
+      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
+	 .plt section.  */
+      struct elf_link_hash_entry *h = NULL;
+      if (! (_bfd_generic_link_add_one_symbol
+	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
+	      (bfd_vma) 0, (const char *) NULL, false,
+	      get_elf_backend_data (abfd)->collect,
+	      (struct bfd_link_hash_entry **) &h)))
+	return false;
+      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
+      h->type = STT_OBJECT;
 
-      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (info->shared
+	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
+	return false;
+    }
 
-      if (info->relocateable)
-	{
-	  /* This is a relocateable link.  We don't have to change
-             anything, unless the reloc is against a section symbol,
-             in which case we have to adjust according to where the
-             section symbol winds up in the output section.  */
-	  if (r_symndx < symtab_hdr->sh_info)
-	    {
-	      sym = local_syms + r_symndx;
-	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
-		{
-		  sec = local_sections[r_symndx];
-		  rel->r_addend += sec->output_offset + sym->st_value;
-		}
-	    }
+  s = bfd_make_section (abfd, 
+			bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, ptralign))
+    return false;
+
+  if (! _bfd_elf_create_got_section (abfd, info))
+    return false;
+
+  {
+    const char *secname;
+    char *relname;
+    flagword secflags;
+    asection *sec;
 
+    for (sec = abfd->sections; sec; sec = sec->next)
+      {
+	secflags = bfd_get_section_flags (abfd, sec);
+	if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
+	    || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
 	  continue;
+	secname = bfd_get_section_name (abfd, sec);
+	relname = (char *) bfd_malloc (strlen (secname) + 6);
+	strcpy (relname, ".rela");
+	strcat (relname, secname);
+	s = bfd_make_section (abfd, relname);
+	if (s == NULL
+	    || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+	    || ! bfd_set_section_alignment (abfd, s, ptralign))
+	  return false;
+      }
+  }
+
+  if (bed->want_dynbss)
+    {
+      /* The .dynbss section is a place to put symbols which are defined
+	 by dynamic objects, are referenced by regular objects, and are
+	 not functions.  We must allocate space for them in the process
+	 image and use a R_*_COPY reloc to tell the dynamic linker to
+	 initialize them at run time.  The linker script puts the .dynbss
+	 section into the .bss section of the final image.  */
+      s = bfd_make_section (abfd, ".dynbss");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
+	return false;
+
+      /* The .rel[a].bss section holds copy relocs.  This section is not
+	 normally needed.  We need to create it here, though, so that the
+	 linker will map it to an output section.  We can't just create it
+	 only if we need it, because we will not know whether we need it
+	 until we have seen all the input files, and the first time the
+	 main linker code calls BFD after examining all the input files
+	 (size_dynamic_sections) the input sections have already been
+	 mapped to the output sections.  If the section turns out not to
+	 be needed, we can discard it later.  We will never need this
+	 section when generating a shared object, since they do not use
+	 copy relocs.  */
+      if (! info->shared)
+	{
+	  s = bfd_make_section (abfd, 
+				(bed->default_use_rela_p 
+				 ? ".rela.bss" : ".rel.bss")); 
+	  if (s == NULL
+	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
+	      || ! bfd_set_section_alignment (abfd, s, ptralign))
+	    return false;
 	}
+    }
 
-      r_type = ELF32_R_TYPE (rel->r_info);
+  return true;
+}
+
 
-      /* Many of the relocs are only used for relaxing, and are
-         handled entirely by the relaxation code.  */
-      if (r_type > (int) R_SH_LAST_INVALID_RELOC)
-	continue;
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
 
-      if (r_type < 0
-	  || r_type >= (int) R_SH_FIRST_INVALID_RELOC)
+static boolean
+elf_sh_adjust_dynamic_symbol (info, h)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+{
+  bfd *dynobj;
+  asection *s;
+  unsigned int power_of_two;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
+		  || h->weakdef != NULL
+		  || ((h->elf_link_hash_flags
+		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
+		      && (h->elf_link_hash_flags
+			  & ELF_LINK_HASH_REF_REGULAR) != 0
+		      && (h->elf_link_hash_flags
+			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
+    {
+      if (! info->shared
+	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
+	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
 	{
-	  bfd_set_error (bfd_error_bad_value);
-	  return false;
+	  /* This case can occur if we saw a PLT reloc in an input
+             file, but the symbol was never referred to by a dynamic
+             object.  In such a case, we don't actually need to build
+             a procedure linkage table, and we can just do a REL32
+             reloc instead.  */
+	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
+	  return true;
 	}
 
-      /* FIXME: This is certainly incorrect.  However, it is how the
-         COFF linker works.  */
-      if (r_type != (int) R_SH_DIR32
-	  && r_type != (int) R_SH_IND12W)
-	continue;
+      /* Make sure this symbol is output as a dynamic symbol.  */
+      if (h->dynindx == -1)
+	{
+	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
+	    return false;
+	}
 
-      howto = sh_elf_howto_table + r_type;
+      s = bfd_get_section_by_name (dynobj, ".plt");
+      BFD_ASSERT (s != NULL);
 
-      /* This is a final link.  */
-      h = NULL;
+      /* If this is the first .plt entry, make room for the special
+	 first entry.  */
+      if (s->_raw_size == 0)
+	s->_raw_size += PLT_ENTRY_SIZE;
+
+      /* If this symbol is not defined in a regular file, and we are
+	 not generating a shared library, then set the symbol to this
+	 location in the .plt.  This is required to make function
+	 pointers compare as equal between the normal executable and
+	 the shared library.  */
+      if (! info->shared
+	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  h->root.u.def.section = s;
+	  h->root.u.def.value = s->_raw_size;
+	}
+
+      h->plt.offset = s->_raw_size;
+
+      /* Make room for this entry.  */
+      s->_raw_size += elf_sh_sizeof_plt (info);
+
+      /* We also need to make an entry in the .got.plt section, which
+	 will be placed in the .got section by the linker script.  */
+
+      s = bfd_get_section_by_name (dynobj, ".got.plt");
+      BFD_ASSERT (s != NULL);
+      s->_raw_size += 4;
+
+      /* We also need to make an entry in the .rela.plt section.  */
+
+      s = bfd_get_section_by_name (dynobj, ".rela.plt");
+      BFD_ASSERT (s != NULL);
+      s->_raw_size += sizeof (Elf32_External_Rela);
+
+      return true;
+    }
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->weakdef != NULL)
+    {
+      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
+		  || h->weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->weakdef->root.u.def.section;
+      h->root.u.def.value = h->weakdef->root.u.def.value;
+      return true;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return true;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
+    return true;
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  s = bfd_get_section_by_name (dynobj, ".dynbss");
+  BFD_ASSERT (s != NULL);
+
+  /* We must generate a R_SH_COPY reloc to tell the dynamic linker to
+     copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rela.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      asection *srel;
+
+      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
+      BFD_ASSERT (srel != NULL);
+      srel->_raw_size += sizeof (Elf32_External_Rela);
+      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
+    }
+
+  /* We need to figure out the alignment required for this symbol.  I
+     have no idea how ELF linkers handle this.  */
+  power_of_two = bfd_log2 (h->size);
+  if (power_of_two > 3)
+    power_of_two = 3;
+
+  /* Apply the required alignment.  */
+  s->_raw_size = BFD_ALIGN (s->_raw_size,
+			    (bfd_size_type) (1 << power_of_two));
+  if (power_of_two > bfd_get_section_alignment (dynobj, s))
+    {
+      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
+	return false;
+    }
+
+  /* Define the symbol as being at this point in the section.  */
+  h->root.u.def.section = s;
+  h->root.u.def.value = s->_raw_size;
+
+  /* Increment the section size to make room for the symbol.  */
+  s->_raw_size += h->size;
+
+  return true;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+static boolean
+elf_sh_size_dynamic_sections (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  bfd *dynobj;
+  asection *s;
+  boolean plt;
+  boolean relocs;
+  boolean reltext;
+
+  dynobj = elf_hash_table (info)->dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (! info->shared)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+  else
+    {
+      /* We may have created entries in the .rela.got section.
+         However, if we are not creating the dynamic sections, we will
+         not actually use these entries.  Reset the size of .rela.got,
+         which will cause it to get stripped from the output file
+         below.  */
+      s = bfd_get_section_by_name (dynobj, ".rela.got");
+      if (s != NULL)
+	s->_raw_size = 0;
+    }
+
+  /* If this is a -Bsymbolic shared link, then we need to discard all
+     PC relative relocs against symbols defined in a regular object.
+     We allocated space for them in the check_relocs routine, but we
+     will not fill them in in the relocate_section routine.  */
+  if (info->shared && info->symbolic)
+    elf_sh_link_hash_traverse (elf_sh_hash_table (info),
+				 elf_sh_discard_copies,
+				 (PTR) NULL);
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  plt = false;
+  relocs = false;
+  reltext = false;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      const char *name;
+      boolean strip;
+
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      /* It's OK to base decisions on the section name, because none
+	 of the dynobj section names depend upon the input files.  */
+      name = bfd_get_section_name (dynobj, s);
+
+      strip = false;
+
+      if (strcmp (name, ".plt") == 0)
+	{
+	  if (s->_raw_size == 0)
+	    {
+	      /* Strip this section if we don't need it; see the
+                 comment below.  */
+	      strip = true;
+	    }
+	  else
+	    {
+	      /* Remember whether there is a PLT.  */
+	      plt = true;
+	    }
+	}
+      else if (strncmp (name, ".rela", 5) == 0)
+	{
+	  if (s->_raw_size == 0)
+	    {
+	      /* If we don't need this section, strip it from the
+		 output file.  This is mostly to handle .rela.bss and
+		 .rela.plt.  We must create both sections in
+		 create_dynamic_sections, because they must be created
+		 before the linker maps input sections to output
+		 sections.  The linker does that before
+		 adjust_dynamic_symbol is called, and it is that
+		 function which decides whether anything needs to go
+		 into these sections.  */
+	      strip = true;
+	    }
+	  else
+	    {
+	      asection *target;
+
+	      /* Remember whether there are any reloc sections other
+                 than .rela.plt.  */
+	      if (strcmp (name, ".rela.plt") != 0)
+		{
+		  const char *outname;
+
+		  relocs = true;
+
+		  /* If this relocation section applies to a read only
+		     section, then we probably need a DT_TEXTREL
+		     entry.  The entries in the .rela.plt section
+		     really apply to the .got section, which we
+		     created ourselves and so know is not readonly.  */
+		  outname = bfd_get_section_name (output_bfd,
+						  s->output_section);
+		  target = bfd_get_section_by_name (output_bfd, outname + 5);
+		  if (target != NULL
+		      && (target->flags & SEC_READONLY) != 0
+		      && (target->flags & SEC_ALLOC) != 0)
+		    reltext = true;
+		}
+
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      s->reloc_count = 0;
+	    }
+	}
+      else if (strncmp (name, ".got", 4) != 0)
+	{
+	  /* It's not one of our sections, so don't allocate space.  */
+	  continue;
+	}
+
+      if (strip)
+	{
+	  _bfd_strip_section_from_output (info, s);
+	  continue;
+	}
+
+      /* Allocate memory for the section contents.  */
+      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
+      if (s->contents == NULL && s->_raw_size != 0)
+	return false;
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in elf_sh_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+      if (! info->shared)
+	{
+	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
+	    return false;
+	}
+
+      if (plt)
+	{
+	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
+	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
+	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
+	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
+	    return false;
+	}
+
+      if (relocs)
+	{
+	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
+	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
+	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
+						sizeof (Elf32_External_Rela)))
+	    return false;
+	}
+
+      if (reltext)
+	{
+	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
+	    return false;
+	}
+    }
+
+  return true;
+}
+
+/* This function is called via elf_sh_link_hash_traverse if we are
+   creating a shared object with -Bsymbolic.  It discards the space
+   allocated to copy PC relative relocs against symbols which are
+   defined in regular objects.  We allocated space for them in the
+   check_relocs routine, but we won't fill them in in the
+   relocate_section routine.  */
+
+/*ARGSUSED*/
+static boolean
+elf_sh_discard_copies (h, ignore)
+     struct elf_sh_link_hash_entry *h;
+     PTR ignore ATTRIBUTE_UNUSED;
+{
+  struct elf_sh_pcrel_relocs_copied *s;
+
+  /* We only discard relocs for symbols defined in a regular object.  */
+  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+    return true;
+
+  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
+    s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
+
+  return true;
+}
+
+/* Relocate an SH ELF section.  */
+
+static boolean
+sh_elf_relocate_section (output_bfd, info, input_bfd, input_section,
+			 contents, relocs, local_syms, local_sections)
+     bfd *output_bfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+     bfd *input_bfd;
+     asection *input_section;
+     bfd_byte *contents;
+     Elf_Internal_Rela *relocs;
+     Elf_Internal_Sym *local_syms;
+     asection **local_sections;
+{
+  bfd *dynobj;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel, *relend;
+  bfd_vma *local_got_offsets;
+  asection *sgot;
+  asection *splt;
+  asection *sreloc;
+
+  dynobj = elf_hash_table (info)->dynobj;
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+
+  sgot = NULL;
+  splt = NULL;
+  sreloc = NULL;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_vma addend = (bfd_vma)0;
+      bfd_reloc_status_type r;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      if (info->relocateable)
+	{
+	  /* This is a relocateable link.  We don't have to change
+             anything, unless the reloc is against a section symbol,
+             in which case we have to adjust according to where the
+             section symbol winds up in the output section.  */
+	  if (r_symndx < symtab_hdr->sh_info)
+	    {
+	      sym = local_syms + r_symndx;
+	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+		{
+		  sec = local_sections[r_symndx];
+		  rel->r_addend += sec->output_offset + sym->st_value;
+		}
+	    }
+
+	  continue;
+	}
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+
+      /* Many of the relocs are only used for relaxing, and are
+         handled entirely by the relaxation code.  */
+      if (r_type > (int) R_SH_LAST_INVALID_RELOC &&
+	  r_type < (int) R_SH_FIRST_INVALID_RELOC2)
+	continue;
+
+      if (r_type < 0
+	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC
+	      && r_type <= (int) R_SH_LAST_INVALID_RELOC)
+	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC2
+	      && r_type <= (int) R_SH_LAST_INVALID_RELOC2)
+	  || r_type >= R_SH_max)
+	{
+	  bfd_set_error (bfd_error_bad_value);
+	  return false;
+	}
+
+      /* FIXME: This is certainly incorrect.  However, it is how the
+         COFF linker works.  */
+      if (r_type != (int) R_SH_DIR32
+	  && r_type != (int) R_SH_IND12W
+	  && r_type < (int) R_SH_FIRST_INVALID_RELOC)
+	continue;
+
+      howto = sh_elf_howto_table + r_type;
+
+      /* This is a final link.  */
+      h = NULL;
       sym = NULL;
       sec = NULL;
       if (r_symndx < symtab_hdr->sh_info)
@@ -1779,12 +2933,51 @@
 	      || h->root.type == bfd_link_hash_defweak)
 	    {
 	      sec = h->root.u.def.section;
-	      relocation = (h->root.u.def.value
-			    + sec->output_section->vma
-			    + sec->output_offset);
+	      if (r_type == R_SH_GOTPC
+		  || (r_type == R_SH_PLT32
+		      && h->plt.offset != (bfd_vma) -1)
+		  || (r_type == R_SH_GOT32
+		      && elf_hash_table (info)->dynamic_sections_created
+		      && (! info->shared
+			  || (! info->symbolic && h->dynindx != -1)
+			  || (h->elf_link_hash_flags
+			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
+		  || (info->shared
+		      && ((! info->symbolic && h->dynindx != -1)
+			  || (h->elf_link_hash_flags
+			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
+		      && (r_type == R_SH_DIR32
+			  || r_type == R_SH_REL32)
+		      && ((input_section->flags & SEC_ALLOC) != 0
+			  /* DWARF will emit R_SH_DIR32 relocations in its
+			     sections against symbols defined externally
+			     in shared libraries.  We can't do anything
+			     with them here.  */
+		  || ((input_section->flags & SEC_DEBUGGING) != 0
+			  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
+		{
+		  /* In these cases, we don't need the relocation
+                     value.  We check specially because in some
+                     obscure cases sec->output_section will be NULL.  */
+		  relocation = 0;
+		}
+	      else if (sec->output_section == NULL)
+		{
+		  (*_bfd_error_handler)
+		    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
+		     bfd_get_filename (input_bfd), h->root.root.string,
+		     bfd_get_section_name (input_bfd, input_section));
+		  relocation = 0;
+		}
+	      else
+		relocation = (h->root.u.def.value
+			      + sec->output_section->vma
+			      + sec->output_offset);
 	    }
 	  else if (h->root.type == bfd_link_hash_undefweak)
 	    relocation = 0;
+	  else if (info->shared && !info->symbolic && !info->no_undefined)
+	    relocation = 0;
 	  else
 	    {
 	      if (! ((*info->callbacks->undefined_symbol)
@@ -1801,8 +2994,277 @@
 
       switch ((int)r_type)
 	{
-	case (int)R_SH_DIR32:
-	  addend = rel->r_addend;
+	case R_SH_DIR32:
+	case R_SH_REL32:
+	  if (info->shared
+	      && (input_section->flags & SEC_ALLOC) != 0
+	      && (r_type != R_SH_REL32
+		  || (h != NULL
+		      && h->dynindx != -1
+		      && (! info->symbolic
+			  || (h->elf_link_hash_flags
+			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
+	    {
+	      Elf_Internal_Rela outrel;
+	      boolean skip, relocate;
+
+	      /* When generating a shared object, these relocations
+		 are copied into the output file to be resolved at run
+		 time.  */
+
+	      if (sreloc == NULL)
+		{
+		  const char *name;
+
+		  name = (bfd_elf_string_from_elf_section
+			  (input_bfd,
+			   elf_elfheader (input_bfd)->e_shstrndx,
+			   elf_section_data (input_section)->rel_hdr.sh_name));
+		  if (name == NULL)
+		    return false;
+
+		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
+			      && strcmp (bfd_get_section_name (input_bfd,
+							       input_section),
+					 name + 5) == 0);
+
+		  sreloc = bfd_get_section_by_name (dynobj, name);
+		  BFD_ASSERT (sreloc != NULL);
+		}
+
+	      skip = false;
+
+	      if (elf_section_data (input_section)->stab_info == NULL)
+		outrel.r_offset = rel->r_offset;
+	      else
+		{
+		  bfd_vma off;
+
+		  off = (_bfd_stab_section_offset
+			 (output_bfd, &elf_hash_table (info)->stab_info,
+			  input_section,
+			  &elf_section_data (input_section)->stab_info,
+			  rel->r_offset));
+		  if (off == (bfd_vma) -1)
+		    skip = true;
+		  outrel.r_offset = off;
+		}
+
+	      outrel.r_offset += (input_section->output_section->vma
+				  + input_section->output_offset);
+
+	      if (skip)
+		{
+		  memset (&outrel, 0, sizeof outrel);
+		  relocate = false;
+		}
+	      else if (r_type == R_SH_REL32)
+		{
+		  BFD_ASSERT (h != NULL && h->dynindx != -1);
+		  relocate = false;
+		  outrel.r_info = ELF32_R_INFO (h->dynindx, R_SH_REL32);
+		  outrel.r_addend = rel->r_addend;
+		}
+	      else
+		{
+		  /* h->dynindx may be -1 if this symbol was marked to
+                     become local.  */
+#if 1
+		  /* This is a really ugly hack. We need to output a
+		     correct addend value in the rela, but the rest of 
+		     the tools use the implicit rel value instead, and
+		     so they don't keep r_addend up-to-date. We fish out
+		     the additional addend from the data.  */
+		  addend = bfd_get_32 (input_bfd,
+				       contents + rel->r_offset);
+		  rel->r_addend += addend;
+#endif
+		  if (h == NULL
+		      || ((info->symbolic || h->dynindx == -1)
+			  && (h->elf_link_hash_flags
+			      & ELF_LINK_HASH_DEF_REGULAR) != 0))
+		    {
+		      relocate = true;
+		      outrel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
+		      outrel.r_addend = relocation + rel->r_addend;
+		    }
+		  else
+		    {
+		      BFD_ASSERT (h->dynindx != -1);
+		      relocate = false;
+		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_SH_DIR32);
+		      outrel.r_addend = relocation + rel->r_addend;
+		    }
+		}
+
+	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
+					(((Elf32_External_Rela *)
+					  sreloc->contents)
+					 + sreloc->reloc_count));
+	      ++sreloc->reloc_count;
+
+	      /* If this reloc is against an external symbol, we do
+		 not want to fiddle with the addend.  Otherwise, we
+		 need to include the symbol value so that it becomes
+		 an addend for the dynamic reloc.  */
+	      if (! relocate)
+		continue;
+	    }
+	  else if (r_type == R_SH_DIR32)
+	    addend = rel->r_addend;
+	  break;
+
+
+	case R_SH_GOT32:
+	  /* Relocation is to the entry for this symbol in the global
+	     offset table.  */
+	  if (sgot == NULL)
+	    {
+	      sgot = bfd_get_section_by_name (dynobj, ".got");
+	      BFD_ASSERT (sgot != NULL);
+	    }
+
+	  if (h != NULL)
+	    {
+	      bfd_vma off;
+
+	      off = h->got.offset;
+	      BFD_ASSERT (off != (bfd_vma) -1);
+
+	      if (! elf_hash_table (info)->dynamic_sections_created
+		  || (info->shared
+		      && (info->symbolic || h->dynindx == -1)
+		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of 4, we use the
+		     least significant bit to record whether we have
+		     initialized it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      bfd_put_32 (output_bfd, relocation,
+				  sgot->contents + off);
+		      h->got.offset |= 1;
+		    }
+		}
+
+	      relocation = sgot->output_offset + off;
+	    }
+	  else
+	    {
+	      bfd_vma off;
+
+	      BFD_ASSERT (local_got_offsets != NULL
+			  && local_got_offsets[r_symndx] != (bfd_vma) -1);
+
+	      off = local_got_offsets[r_symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+                 the least significant bit to record whether we have
+                 already generated the necessary reloc.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
+
+		  if (info->shared)
+		    {
+		      asection *srelgot;
+		      Elf_Internal_Rela outrel;
+
+		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
+		      BFD_ASSERT (srelgot != NULL);
+
+		      outrel.r_offset = (sgot->output_section->vma
+					 + sgot->output_offset
+					 + off);
+		      outrel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
+		      outrel.r_addend = relocation;
+		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
+						(((Elf32_External_Rela *)
+						  srelgot->contents)
+						 + srelgot->reloc_count));
+		      ++srelgot->reloc_count;
+		    }
+
+		  local_got_offsets[r_symndx] |= 1;
+		}
+
+	      relocation = sgot->output_offset + off;
+	    }
+
+	  break;
+
+	case R_SH_GOTOFF:
+	  /* Relocation is relative to the start of the global offset
+	     table.  */
+
+	  if (sgot == NULL)
+	    {
+	      sgot = bfd_get_section_by_name (dynobj, ".got");
+	      BFD_ASSERT (sgot != NULL);
+	    }
+
+	  /* Note that sgot->output_offset is not involved in this
+	     calculation.  We always want the start of .got.  If we
+	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
+	     permitted by the ABI, we might have to change this
+	     calculation.  */
+	  relocation -= sgot->output_section->vma;
+
+	  break;
+
+	case R_SH_GOTPC:
+	  /* Use global offset table as symbol value.  */
+
+	  if (sgot == NULL)
+	    {
+	      sgot = bfd_get_section_by_name (dynobj, ".got");
+	      BFD_ASSERT (sgot != NULL);
+	    }
+
+	  relocation = sgot->output_section->vma;
+
+	  break;
+
+	case R_SH_PLT32:
+	  /* Relocation is to the entry for this symbol in the
+	     procedure linkage table.  */
+
+	  /* Resolve a PLT reloc again a local symbol directly,
+             without using the procedure linkage table.  */
+	  if (h == NULL)
+	    break;
+
+	  if (h->plt.offset == (bfd_vma) -1)
+	    {
+	      /* We didn't make a PLT entry for this symbol.  This
+                 happens when statically linking PIC code, or when
+                 using -Bsymbolic.  */
+	      break;
+	    }
+
+	  if (splt == NULL)
+	    {
+	      splt = bfd_get_section_by_name (dynobj, ".plt");
+	      BFD_ASSERT (splt != NULL);
+	    }
+
+	  relocation = (splt->output_section->vma
+			+ splt->output_offset
+			+ h->plt.offset);
+
 	  break;
 	}
 
@@ -1982,6 +3444,7 @@
     free (sections);
   return NULL;
 }
+
 static asection *
 sh_elf_gc_mark_hook (abfd, info, rel, h, sym)
        bfd *abfd;
@@ -2026,6 +3489,8 @@
   return NULL;
 }
 
+/* Update the got entry reference counts for the section being removed.  */
+
 static boolean
 sh_elf_gc_sweep_hook (abfd, info, sec, relocs)
      bfd *abfd ATTRIBUTE_UNUSED;
@@ -2033,7 +3498,10 @@
      asection *sec ATTRIBUTE_UNUSED;
      const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
 {
-  /* we don't use got and plt entries for sh. */
+  /* ??? It would seem that the existing SH code does no sort
+     of reference counting or whatnot on its GOT and PLT entries,
+     so it is not possible to garbage collect them at this time.  */
+
   return true;
 }
 
@@ -2048,14 +3516,28 @@
      asection *sec;
      const Elf_Internal_Rela *relocs;
 {
+  bfd *dynobj;
   Elf_Internal_Shdr *symtab_hdr;
   struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
   const Elf_Internal_Rela *rel;
   const Elf_Internal_Rela *rel_end;
- 
+  bfd_vma *local_got_offsets;
+  asection *sgot;
+  asection *srelgot;
+  asection *sreloc;
+
+  sgot = NULL;
+  srelgot = NULL;
+  sreloc = NULL;
+
   if (info->relocateable)
     return true;
  
+  dynobj = elf_hash_table (info)->dynobj;
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  local_got_offsets = elf_local_got_offsets (abfd);
+
   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
   sym_hashes = elf_sym_hashes (abfd);
   sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
@@ -2074,6 +3556,24 @@
       else
         h = sym_hashes[r_symndx - symtab_hdr->sh_info];
  
+      /* Some relocs require a global offset table.  */
+      if (dynobj == NULL)
+	{
+	  switch (ELF32_R_TYPE (rel->r_info))
+	    {
+	    case R_SH_GOT32:
+	    case R_SH_GOTOFF:
+	    case R_SH_GOTPC:
+	      elf_hash_table (info)->dynobj = dynobj = abfd;
+	      if (! _bfd_elf_create_got_section (dynobj, info))
+		return false;
+	      break;
+
+	    default:
+	      break;
+	    }
+	}
+
       switch (ELF32_R_TYPE (rel->r_info))
         {
         /* This relocation describes the C++ object vtable hierarchy.
@@ -2089,12 +3589,580 @@
           if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
             return false;
           break;
+ 
+ 	case R_SH_GOT32:
+ 	  /* This symbol requires a global offset table entry.  */
+ 
+ 	  if (sgot == NULL)
+ 	    {
+ 	      sgot = bfd_get_section_by_name (dynobj, ".got");
+ 	      BFD_ASSERT (sgot != NULL);
+ 	    }
+ 
+ 	  if (srelgot == NULL
+ 	      && (h != NULL || info->shared))
+ 	    {
+ 	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
+ 	      if (srelgot == NULL)
+ 		{
+ 		  srelgot = bfd_make_section (dynobj, ".rela.got");
+ 		  if (srelgot == NULL
+ 		      || ! bfd_set_section_flags (dynobj, srelgot,
+ 						  (SEC_ALLOC
+ 						   | SEC_LOAD
+ 						   | SEC_HAS_CONTENTS
+ 						   | SEC_IN_MEMORY
+ 						   | SEC_LINKER_CREATED
+ 						   | SEC_READONLY))
+ 		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
+ 		    return false;
+ 		}
+ 	    }
+ 
+ 	  if (h != NULL)
+ 	    {
+ 	      if (h->got.offset != (bfd_vma) -1)
+ 		{
+ 		  /* We have already allocated space in the .got.  */
+ 		  break;
+ 		}
+ 	      h->got.offset = sgot->_raw_size;
+ 
+ 	      /* Make sure this symbol is output as a dynamic symbol.  */
+ 	      if (h->dynindx == -1)
+ 		{
+ 		  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
+ 		    return false;
+ 		}
+ 
+ 	      srelgot->_raw_size += sizeof (Elf32_External_Rela);
+ 	    }
+ 	  else
+ 	    {
+      	      /* This is a global offset table entry for a local
+                  symbol.  */
+ 	      if (local_got_offsets == NULL)
+ 		{
+ 		  size_t size;
+ 		  register unsigned int i;
+ 
+ 		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
+ 		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
+ 		  if (local_got_offsets == NULL)
+ 		    return false;
+ 		  elf_local_got_offsets (abfd) = local_got_offsets;
+ 		  for (i = 0; i < symtab_hdr->sh_info; i++)
+ 		    local_got_offsets[i] = (bfd_vma) -1;
+ 		}
+ 	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
+ 		{
+ 		  /* We have already allocated space in the .got.  */
+ 		  break;
+ 		}
+ 	      local_got_offsets[r_symndx] = sgot->_raw_size;
+ 
+ 	      if (info->shared)
+ 		{
+ 		  /* If we are generating a shared object, we need to
+                      output a R_SH_RELATIVE reloc so that the dynamic
+                      linker can adjust this GOT entry.  */
+ 		  srelgot->_raw_size += sizeof (Elf32_External_Rela);
+ 		}
+ 	    }
+ 
+ 	  sgot->_raw_size += 4;
+ 
+ 	  break;
+ 
+ 	case R_SH_PLT32:
+ 	  /* This symbol requires a procedure linkage table entry.  We
+              actually build the entry in adjust_dynamic_symbol,
+              because this might be a case of linking PIC code which is
+              never referenced by a dynamic object, in which case we
+              don't need to generate a procedure linkage table entry
+              after all.  */
+ 
+ 	  /* If this is a local symbol, we resolve it directly without
+              creating a procedure linkage table entry.  */
+ 	  if (h == NULL)
+ 	    continue;
+ 
+ 	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
+ 
+ 	  break;
+ 
+ 	case R_SH_DIR32:
+ 	case R_SH_REL32:
+ 	  if (h != NULL)
+ 	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
+ 
+ 	  /* If we are creating a shared library, and this is a reloc
+              against a global symbol, or a non PC relative reloc
+              against a local symbol, then we need to copy the reloc
+              into the shared library.  However, if we are linking with
+              -Bsymbolic, we do not need to copy a reloc against a
+              global symbol which is defined in an object we are
+              including in the link (i.e., DEF_REGULAR is set).  At
+              this point we have not seen all the input files, so it is
+              possible that DEF_REGULAR is not set now but will be set
+              later (it is never cleared).  We account for that
+              possibility below by storing information in the
+              pcrel_relocs_copied field of the hash table entry.  */
+ 	  if (info->shared
+ 	      && (sec->flags & SEC_ALLOC) != 0
+ 	      && (ELF32_R_TYPE (rel->r_info) != R_SH_REL32
+ 		  || (h != NULL
+ 		      && (! info->symbolic
+ 			  || (h->elf_link_hash_flags
+ 			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
+ 	    {
+ 	      /* When creating a shared object, we must copy these
+                  reloc types into the output file.  We create a reloc
+                  section in dynobj and make room for this reloc.  */
+ 	      if (sreloc == NULL)
+ 		{
+ 		  const char *name;
+ 
+ 		  name = (bfd_elf_string_from_elf_section
+ 			  (abfd,
+ 			   elf_elfheader (abfd)->e_shstrndx,
+ 			   elf_section_data (sec)->rel_hdr.sh_name));
+ 		  if (name == NULL)
+ 		    return false;
+ 
+ 		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
+ 			      && strcmp (bfd_get_section_name (abfd, sec),
+ 					 name + 5) == 0);
+ 
+ 		  sreloc = bfd_get_section_by_name (dynobj, name);
+ 		  if (sreloc == NULL)
+ 		    {
+ 		      flagword flags;
+ 
+ 		      sreloc = bfd_make_section (dynobj, name);
+ 		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
+ 			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+ 		      if ((sec->flags & SEC_ALLOC) != 0)
+ 			flags |= SEC_ALLOC | SEC_LOAD;
+ 		      if (sreloc == NULL
+ 			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
+ 			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
+ 			return false;
+ 		    }
+ 		}
+ 
+ 	      sreloc->_raw_size += sizeof (Elf32_External_Rela);
+ 
+ 	      /* If we are linking with -Bsymbolic, and this is a
+                  global symbol, we count the number of PC relative
+                  relocations we have entered for this symbol, so that
+                  we can discard them again if the symbol is later
+                  defined by a regular object.  Note that this function
+                  is only called if we are using an elf_sh linker
+                  hash table, which means that h is really a pointer to
+                  an elf_sh_link_hash_entry.  */
+ 	      if (h != NULL && info->symbolic
+ 		  && ELF32_R_TYPE (rel->r_info) == R_SH_REL32)
+ 		{
+ 		  struct elf_sh_link_hash_entry *eh;
+ 		  struct elf_sh_pcrel_relocs_copied *p;
+ 
+ 		  eh = (struct elf_sh_link_hash_entry *) h;
+ 
+ 		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
+ 		    if (p->section == sreloc)
+ 		      break;
+ 
+ 		  if (p == NULL)
+ 		    {
+ 		      p = ((struct elf_sh_pcrel_relocs_copied *)
+ 			   bfd_alloc (dynobj, sizeof *p));
+ 		      if (p == NULL)
+ 			return false;
+ 		      p->next = eh->pcrel_relocs_copied;
+ 		      eh->pcrel_relocs_copied = p;
+ 		      p->section = sreloc;
+ 		      p->count = 0;
+ 		    }
+ 
+ 		  ++p->count;
+ 		}
+ 	    }
+ 
+ 	  break;
         }
     }
  
   return true;
 }
 
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static boolean
+elf_sh_finish_dynamic_symbol (output_bfd, info, h, sym)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+     Elf_Internal_Sym *sym;
+{
+  bfd *dynobj;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgot;
+      asection *srel;
+
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      Elf_Internal_Rela rel;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = bfd_get_section_by_name (dynobj, ".plt");
+      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
+      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
+      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+      /* take into account that first .plt entry is the large size */
+      if ( info->without_lazy_binding )
+	plt_index = (h->plt.offset - PLT_ENTRY_SIZE)/ elf_sh_sizeof_plt (info);
+      else
+#endif
+	plt_index = h->plt.offset / elf_sh_sizeof_plt (info) - 1;
+
+      /* Get the offset into the .got table of the entry that
+	 corresponds to this function.  Each .got entry is 4 bytes.
+	 The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+
+      /* Fill in the entry in the procedure linkage table.  */
+      if (! info->shared)
+	{
+	  if (elf_sh_plt_entry == NULL)
+	    {
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+              if (info->without_lazy_binding)
+		elf_sh_plt_entry = (bfd_big_endian (output_bfd)?
+				    elf_sh_small_plt_entry_be :
+				    elf_sh_small_plt_entry_le);
+              else
+#endif
+	      elf_sh_plt_entry = (bfd_big_endian (output_bfd)?
+				  elf_sh_plt_entry_be : elf_sh_plt_entry_le);
+	    }
+	  memcpy (splt->contents + h->plt.offset, elf_sh_plt_entry,
+		  elf_sh_sizeof_plt (info));
+	  bfd_put_32 (output_bfd,
+		      (sgot->output_section->vma
+		       + sgot->output_offset
+		       + got_offset),
+		      (splt->contents + h->plt.offset
+		       + elf_sh_plt_symbol_offset (info)));
+
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+	  if (! info->without_lazy_binding)
+#endif
+	  bfd_put_32 (output_bfd,
+		      (splt->output_section->vma + splt->output_offset),
+		      (splt->contents + h->plt.offset
+		       + elf_sh_plt_plt0_offset (info)));
+	}
+      else
+	{
+	  if (elf_sh_pic_plt_entry == NULL)
+	    {
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+              if (info->without_lazy_binding)
+		elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd)?
+					elf_sh_pic_small_plt_entry_be :
+					elf_sh_pic_small_plt_entry_le);
+              else
+#endif
+	      elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd)?
+				      elf_sh_pic_plt_entry_be :
+				      elf_sh_pic_plt_entry_le);
+	    }
+	  memcpy (splt->contents + h->plt.offset, elf_sh_pic_plt_entry,
+		  elf_sh_sizeof_plt (info));
+	  bfd_put_32 (output_bfd, got_offset,
+		      (splt->contents + h->plt.offset
+		       + elf_sh_plt_symbol_offset (info)));
+	}
+
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+      if (! info->without_lazy_binding)
+#endif
+      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
+		  (splt->contents + h->plt.offset
+		   + elf_sh_plt_reloc_offset (info)));
+
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+      if (! info->without_lazy_binding)
+#endif
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+		  (splt->output_section->vma
+		   + splt->output_offset
+		   + h->plt.offset
+		   + elf_sh_plt_temp_offset (info)),
+		  sgot->contents + got_offset);
+
+      /* Fill in the entry in the .rela.plt section.  */
+      rel.r_offset = (sgot->output_section->vma
+		      + sgot->output_offset
+		      + got_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_JMP_SLOT);
+      rel.r_addend = 0;
+      bfd_elf32_swap_reloca_out (output_bfd, &rel,
+				((Elf32_External_Rela *) srel->contents
+				 + plt_index));
+
+      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	}
+    }
+
+  if (h->got.offset != (bfd_vma) -1)
+    {
+      asection *sgot;
+      asection *srel;
+      Elf_Internal_Rela rel;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+
+      sgot = bfd_get_section_by_name (dynobj, ".got");
+      srel = bfd_get_section_by_name (dynobj, ".rela.got");
+      BFD_ASSERT (sgot != NULL && srel != NULL);
+
+      rel.r_offset = (sgot->output_section->vma
+		      + sgot->output_offset
+		      + (h->got.offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+	 locally, we just want to emit a RELATIVE reloc.  Likewise if
+	 the symbol was forced to be local because of a version file.
+	 The entry in the global offset table will already have been
+	 initialized in the relocate_section function.  */
+      if (info->shared
+	  && (info->symbolic || h->dynindx == -1)
+	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
+	{
+	  rel.r_info = ELF32_R_INFO (0, R_SH_RELATIVE);
+	  rel.r_addend = (h->root.u.def.value
+			  + h->root.u.def.section->output_section->vma
+			  + h->root.u.def.section->output_offset);
+	}
+      else
+	{
+	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
+	  rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_GLOB_DAT);
+	  rel.r_addend = 0;
+	}
+
+      bfd_elf32_swap_reloca_out (output_bfd, &rel,
+				((Elf32_External_Rela *) srel->contents
+				 + srel->reloc_count));
+      ++srel->reloc_count;
+    }
+
+  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
+    {
+      asection *s;
+      Elf_Internal_Rela rel;
+
+      /* This symbol needs a copy reloc.  Set it up.  */
+
+      BFD_ASSERT (h->dynindx != -1
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak));
+
+      s = bfd_get_section_by_name (h->root.u.def.section->owner,
+				   ".rela.bss");
+      BFD_ASSERT (s != NULL);
+
+      rel.r_offset = (h->root.u.def.value
+		      + h->root.u.def.section->output_section->vma
+		      + h->root.u.def.section->output_offset);
+      rel.r_info = ELF32_R_INFO (h->dynindx, R_SH_COPY);
+      rel.r_addend = 0;
+      bfd_elf32_swap_reloca_out (output_bfd, &rel,
+				((Elf32_External_Rela *) s->contents
+				 + s->reloc_count));
+      ++s->reloc_count;
+    }
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
+    sym->st_shndx = SHN_ABS;
+
+  return true;
+}
+
+/* Finish up the dynamic sections.  */
+
+static boolean
+elf_sh_finish_dynamic_sections (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  bfd *dynobj;
+  asection *sgot;
+  asection *sdyn;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
+  BFD_ASSERT (sgot != NULL);
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      asection *splt;
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT (sdyn != NULL);
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  const char *name;
+	  asection *s;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+
+	    case DT_PLTGOT:
+	      name = ".got";
+	      goto get_vma;
+	    case DT_JMPREL:
+	      name = ".rela.plt";
+	    get_vma:
+	      s = bfd_get_section_by_name (output_bfd, name);
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->vma;
+	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	      break;
+
+	    case DT_PLTRELSZ:
+	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
+	      BFD_ASSERT (s != NULL);
+	      if (s->_cooked_size != 0)
+		dyn.d_un.d_val = s->_cooked_size;
+	      else
+		dyn.d_un.d_val = s->_raw_size;
+	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	      break;
+
+	    case DT_RELASZ:
+	      /* My reading of the SVR4 ABI indicates that the
+		 procedure linkage table relocs (DT_JMPREL) should be
+		 included in the overall relocs (DT_RELA).  This is
+		 what Solaris does.  However, UnixWare can not handle
+		 that case.  Therefore, we override the DT_RELASZ entry
+		 here to make it not include the JMPREL relocs.  Since
+		 the linker script arranges for .rela.plt to follow all
+		 other relocation sections, we don't have to worry
+		 about changing the DT_RELA entry.  */
+	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
+	      if (s != NULL)
+		{
+		  if (s->_cooked_size != 0)
+		    dyn.d_un.d_val -= s->_cooked_size;
+		  else
+		    dyn.d_un.d_val -= s->_raw_size;
+		}
+	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	      break;
+	    }
+	}
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      splt = bfd_get_section_by_name (dynobj, ".plt");
+      if (splt && splt->_raw_size > 0)
+	{
+	  if (info->shared)
+	    {
+	      if (elf_sh_pic_plt_entry == NULL)
+		{
+#if defined(USE_SMALL_PLT_WITHOUT_LAZY_BINDING)
+		  if (info->without_lazy_binding)
+		    elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd)?
+					    elf_sh_pic_small_plt_entry_be :
+					    elf_sh_pic_small_plt_entry_le);
+		  else
+#endif
+		  elf_sh_pic_plt_entry = (bfd_big_endian (output_bfd)?
+					  elf_sh_pic_plt_entry_be :
+					  elf_sh_pic_plt_entry_le);
+		}
+	      memcpy (splt->contents, elf_sh_pic_plt_entry,
+		      elf_sh_sizeof_plt (info));
+	    }
+	  else
+	    {
+	      if (elf_sh_plt0_entry == NULL)
+		{
+		  elf_sh_plt0_entry = (bfd_big_endian (output_bfd)?
+				       elf_sh_plt0_entry_be :
+				       elf_sh_plt0_entry_le);
+		}
+	      memcpy (splt->contents, elf_sh_plt0_entry, PLT_ENTRY_SIZE);
+	      bfd_put_32 (output_bfd,
+			  sgot->output_section->vma + sgot->output_offset + 4,
+			  splt->contents + elf_sh_plt0_gotid_offset (info));
+	      bfd_put_32 (output_bfd,
+			  sgot->output_section->vma + sgot->output_offset + 8,
+			  splt->contents + elf_sh_plt0_linker_offset (info));
+	    }
+
+	  /* UnixWare sets the entsize of .plt to 4, although that doesn't
+	     really seem like the right value.  */
+	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
+	}
+    }
+
+  /* Fill in the first three entries in the global offset table.  */
+  if (sgot->_raw_size > 0)
+    {
+      if (sdyn == NULL)
+	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
+      else
+	bfd_put_32 (output_bfd,
+		    sdyn->output_section->vma + sdyn->output_offset,
+		    sgot->contents);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
+    }
+
+  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return true;
+}
+
 boolean
 sh_elf_set_mach_from_flags (abfd)
      bfd *    abfd;
@@ -2204,9 +4272,16 @@
 #define TARGET_LITTLE_NAME	"elf32-shl"
 #define ELF_ARCH		bfd_arch_sh
 #define ELF_MACHINE_CODE	EM_SH
+
+#if 0
 #define ELF_MAXPAGESIZE		0x1
+#else
+#define ELF_MAXPAGESIZE		0x1000
+#endif
 
+#if 0
 #define elf_symbol_leading_char '_'
+#endif
 
 #define bfd_elf32_bfd_reloc_type_lookup	sh_elf_reloc_type_lookup
 #define elf_info_to_howto		sh_elf_info_to_howto
@@ -2222,9 +4297,27 @@
 #define bfd_elf32_bfd_merge_private_bfd_data \
 					sh_elf_merge_private_data
 
+#define elf_backend_create_dynamic_sections \
+					sh_elf_create_dynamic_sections
+#define bfd_elf32_bfd_link_hash_table_create \
+					elf_sh_link_hash_table_create
 #define elf_backend_gc_mark_hook        sh_elf_gc_mark_hook
 #define elf_backend_gc_sweep_hook       sh_elf_gc_sweep_hook
 #define elf_backend_check_relocs        sh_elf_check_relocs
+#define elf_backend_adjust_dynamic_symbol \
+					elf_sh_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections \
+					elf_sh_size_dynamic_sections
+#define elf_backend_finish_dynamic_symbol \
+					elf_sh_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections \
+					elf_sh_finish_dynamic_sections
+
+#define elf_backend_can_gc_sections	1
+#define elf_backend_want_got_plt	1
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_got_header_size	12
+#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
 
-#define elf_backend_can_gc_sections 1
 #include "elf32-target.h"
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/elf.c binutils/bfd/elf.c
--- binutils-2.10.1/bfd/elf.c	2000-09-07 07:24:15.000000000 +1000
+++ binutils/bfd/elf.c	2001-03-01 02:51:39.000000000 +1000
@@ -237,7 +237,7 @@
 {
   char *buf;
 
-  if ((buf = bfd_alloc (abfd, size)) == NULL)
+  if ((buf = bfd_alloc (abfd, size + 1)) == NULL)
     return NULL;
   if (bfd_seek (abfd, offset, SEEK_SET) == -1)
     return NULL;
@@ -247,6 +247,7 @@
 	bfd_set_error (bfd_error_file_truncated);
       return NULL;
     }
+  buf[size] = '\0';
   return buf;
 }
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/elflink.h binutils/bfd/elflink.h
--- binutils-2.10.1/bfd/elflink.h	2000-10-17 03:57:08.000000000 +1000
+++ binutils/bfd/elflink.h	2001-03-01 02:51:39.000000000 +1000
@@ -468,6 +468,26 @@
 	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, false, false));
   if (h == NULL)
     return false;
+
+#if 1
+  /* Copied from: _bfd_elf_link_record_dynamic_symbol
+     XXX: The ABI draft says the linker must turn hidden and
+     internal symbols into STB_LOCAL symbols when producing the
+     DSO. However, if ld.so honors st_other in the dynamic table,
+     this would not be necessary.  */
+  switch (ELF_ST_VISIBILITY (sym->st_other))
+    {
+    case STV_INTERNAL:
+    case STV_HIDDEN:
+      h->other = sym->st_other;
+      if (! info->relocateable)
+	h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
+      break;
+
+    default:
+      break;
+    }
+#endif
   *sym_hash = h;
 
   /* This code is for coping with dynamic objects, and is only useful
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/libbfd.h binutils/bfd/libbfd.h
--- binutils-2.10.1/bfd/libbfd.h	2000-04-29 11:45:48.000000000 +1000
+++ binutils/bfd/libbfd.h	2001-02-27 05:19:38.000000000 +1000
@@ -705,6 +705,7 @@
   "BFD_RELOC_MIPS_GOT_PAGE",
   "BFD_RELOC_MIPS_GOT_OFST",
   "BFD_RELOC_MIPS_GOT_DISP",
+  "BFD_RELOC_MIPS_QNX_COPY",
 
   "BFD_RELOC_386_GOT32",
   "BFD_RELOC_386_PLT32",
@@ -809,6 +810,14 @@
   "BFD_RELOC_SH_CODE",
   "BFD_RELOC_SH_DATA",
   "BFD_RELOC_SH_LABEL",
+  "BFD_RELOC_SH_GOT32",
+  "BFD_RELOC_SH_PLT32",
+  "BFD_RELOC_SH_COPY",
+  "BFD_RELOC_SH_GLOB_DAT",
+  "BFD_RELOC_SH_JMP_SLOT",
+  "BFD_RELOC_SH_RELATIVE",
+  "BFD_RELOC_SH_GOTOFF",
+  "BFD_RELOC_SH_GOTPC",
   "BFD_RELOC_THUMB_PCREL_BRANCH9",
   "BFD_RELOC_THUMB_PCREL_BRANCH12",
   "BFD_RELOC_THUMB_PCREL_BRANCH23",
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/bfd/reloc.c binutils/bfd/reloc.c
--- binutils-2.10.1/bfd/reloc.c	2000-04-12 09:02:50.000000000 +1000
+++ binutils/bfd/reloc.c	2001-02-27 05:19:38.000000000 +1000
@@ -2295,6 +2295,22 @@
   BFD_RELOC_SH_DATA
 ENUMX
   BFD_RELOC_SH_LABEL
+ENUMX
+  BFD_RELOC_SH_GOT32
+ENUMX
+  BFD_RELOC_SH_PLT32
+ENUMX
+  BFD_RELOC_SH_COPY
+ENUMX
+  BFD_RELOC_SH_GLOB_DAT
+ENUMX
+  BFD_RELOC_SH_JMP_SLOT
+ENUMX
+  BFD_RELOC_SH_RELATIVE
+ENUMX
+  BFD_RELOC_SH_GOTOFF
+ENUMX
+  BFD_RELOC_SH_GOTPC
 ENUMDOC
   Hitachi SH relocs.  Not all of these appear in object files.
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/binutils/arlex.c binutils/binutils/arlex.c
--- binutils-2.10.1/binutils/arlex.c	2000-05-30 00:08:52.000000000 +1000
+++ binutils/binutils/arlex.c	2001-02-27 04:45:11.000000000 +1000
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /cvs/src/src/binutils/Attic/arlex.c,v 1.1.2.1 2000/05/29 14:08:52 pb Exp $
+ * $Header: /cvs/tools/binutils/binutils/arlex.c,v 1.1.1.1 2001/02/26 18:45:11 keith Exp $
  */
 
 #define FLEX_SCANNER
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/binutils/deflex.c binutils/binutils/deflex.c
--- binutils-2.10.1/binutils/deflex.c	2000-05-30 00:08:52.000000000 +1000
+++ binutils/binutils/deflex.c	2001-02-27 04:45:11.000000000 +1000
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /cvs/src/src/binutils/Attic/deflex.c,v 1.1.2.1 2000/05/29 14:08:52 pb Exp $
+ * $Header: /cvs/tools/binutils/binutils/deflex.c,v 1.1.1.1 2001/02/26 18:45:11 keith Exp $
  */
 
 #define FLEX_SCANNER
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/binutils/rclex.c binutils/binutils/rclex.c
--- binutils-2.10.1/binutils/rclex.c	2000-05-30 00:08:52.000000000 +1000
+++ binutils/binutils/rclex.c	2001-02-27 04:45:11.000000000 +1000
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /cvs/src/src/binutils/Attic/rclex.c,v 1.1.2.1 2000/05/29 14:08:52 pb Exp $
+ * $Header: /cvs/tools/binutils/binutils/rclex.c,v 1.1.1.1 2001/02/26 18:45:11 keith Exp $
  */
 
 #define FLEX_SCANNER
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/binutils/syslex.c binutils/binutils/syslex.c
--- binutils-2.10.1/binutils/syslex.c	2000-05-30 00:08:52.000000000 +1000
+++ binutils/binutils/syslex.c	2001-02-27 04:45:11.000000000 +1000
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /cvs/src/src/binutils/Attic/syslex.c,v 1.1.2.1 2000/05/29 14:08:52 pb Exp $
+ * $Header: /cvs/tools/binutils/binutils/syslex.c,v 1.1.1.1 2001/02/26 18:45:11 keith Exp $
  */
 
 #define FLEX_SCANNER
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-all-nto binutils/build-all-nto
--- binutils-2.10.1/build-all-nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-all-nto	2001-05-16 06:01:16.000000000 +1000
@@ -0,0 +1,68 @@
+#!/bin/sh
+
+targets=ntox86,ntoppc,ntomips,ntoarm,ntosh
+basedir=`pwd`
+targdir=nto/all
+dir=${dir:-/usr}
+
+if test -z $target ; then
+  echo "Don't run this script without setting a target!"
+  exit 1
+fi
+
+rm -rf $targdir
+mkdir -p $targdir
+cd $targdir
+
+# DO NOT REMOVE THE FOLLOWING LINE!!!!
+# Without inttypes.h, alignments get screwed up 
+# as a result of a compiler bug. 
+export CFLAGS="-Wp,-idirafter -Wp,$QNX_TARGET/usr/include -Wp,-include -Wp,$QNX_TARGET/usr/include/inttypes.h"
+export CC="env QCC_CONF_PATH=$QCC_CONF_PATH QNX_TARGET=$QNX_TARGET QSSL_TARGET=$QNX_TARGET qcc -Vgcc_"$SYSNAME$PROCESSOR
+export CC='qcc -Vgcc_'$SYSNAME$PROCESSOR
+
+if ! $basedir/configure \
+        --srcdir=$basedir \
+        --host=$target \
+        --target=$target \
+        --enable-targets=$targets \
+        --prefix=$dir \
+        --exec-prefix=$dir \
+        --with-local-prefix=$dir \
+		--enable-shared \
+        --verbose
+then
+        echo "Configure Failed."
+else
+        echo "Configured OK."
+        echo "hacking ldemul-list"
+        cd ld
+        make ldemul-list.h
+        tr -d '\000' <ldemul-list.h >x
+        mv -f x ldemul-list.h
+        cd ..
+fi
+
+if ! make
+then
+	echo make failed!
+	exit 1
+fi
+
+for target in $(echo $targets | tr ',' '\012')
+do
+	rm -rf gas-$target
+	mkdir gas-$target
+	cd gas-$target
+	$basedir/gas/configure \
+		--target=$target \
+		--prefix=$dir \
+		--srcdir=$basedir/gas \
+		--exec-prefix=$dir \
+		--enable-shared \
+		--cache=$basedir/nto/ntox86/gas/config.cache \
+		--verbose
+	make
+	cd ..
+done
+
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-all.ntox86 binutils/build-all.ntox86
--- binutils-2.10.1/build-all.ntox86	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-all.ntox86	2001-03-13 06:01:55.000000000 +1000
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+target=ntox86 ./build-all-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-nto binutils/build-nto
--- binutils-2.10.1/build-nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-nto	2001-05-16 06:01:16.000000000 +1000
@@ -0,0 +1,42 @@
+#!/bin/sh
+
+basedir=`pwd`
+targdir=nto/$target
+dir=${dir:-/usr}
+
+if test -z $target ; then
+  echo "Don't run this script without setting a target!"
+  exit 1
+fi
+
+rm -rf $targdir
+mkdir -p $targdir
+cd $targdir
+
+# DO NOT REMOVE THE FOLLOWING LINE!!!!
+# Without inttypes.h, alignments get screwed up 
+# as a result of a compiler bug. 
+export CFLAGS="-Wp,-idirafter -Wp,$QNX_TARGET/usr/include -Wp,-include -Wp,$QNX_TARGET/usr/include/inttypes.h"
+
+export CC="env QCC_CONF_PATH=$QCC_CONF_PATH QNX_TARGET=$QNX_TARGET QSSL_TARGET=$QNX_TARGET qcc -Vgcc_"$SYSNAME$PROCESSOR
+
+if $basedir/configure \
+        --srcdir=$basedir \
+        --target=$target \
+        --prefix=$dir \
+        --exec-prefix=$dir \
+        --with-local-prefix=$dir \
+        --verbose
+then
+        echo "Configured OK."
+        echo "hacking ldemul-list"
+        cd ld
+        make ldemul-list.h
+        tr -d '\000' <ldemul-list.h >x
+        mv -f x ldemul-list.h
+        cd ..
+        make
+else
+        echo "Configure Failed."
+fi
+
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoarm.nto binutils/build-ntoarm.nto
--- binutils-2.10.1/build-ntoarm.nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoarm.nto	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoarm ./build-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoarm.qnx4 binutils/build-ntoarm.qnx4
--- binutils-2.10.1/build-ntoarm.qnx4	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoarm.qnx4	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoarm ./build-qnx4
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoarm.solsparc binutils/build-ntoarm.solsparc
--- binutils-2.10.1/build-ntoarm.solsparc	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoarm.solsparc	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoarm ./build-solsparc
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoarm.win32 binutils/build-ntoarm.win32
--- binutils-2.10.1/build-ntoarm.win32	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoarm.win32	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoarm ./build-win32
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntomips.nto binutils/build-ntomips.nto
--- binutils-2.10.1/build-ntomips.nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntomips.nto	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntomips ./build-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntomips.qnx4 binutils/build-ntomips.qnx4
--- binutils-2.10.1/build-ntomips.qnx4	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntomips.qnx4	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntomips ./build-qnx4
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntomips.solsparc binutils/build-ntomips.solsparc
--- binutils-2.10.1/build-ntomips.solsparc	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntomips.solsparc	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntomips ./build-solsparc
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntomips.win32 binutils/build-ntomips.win32
--- binutils-2.10.1/build-ntomips.win32	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntomips.win32	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntomips ./build-win32
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoppc.nto binutils/build-ntoppc.nto
--- binutils-2.10.1/build-ntoppc.nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoppc.nto	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoppc ./build-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoppc.qnx4 binutils/build-ntoppc.qnx4
--- binutils-2.10.1/build-ntoppc.qnx4	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoppc.qnx4	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoppc ./build-qnx4
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoppc.solsparc binutils/build-ntoppc.solsparc
--- binutils-2.10.1/build-ntoppc.solsparc	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoppc.solsparc	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntoppc ./build-solsparc
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntoppc.win32 binutils/build-ntoppc.win32
--- binutils-2.10.1/build-ntoppc.win32	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntoppc.win32	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,3 @@
+#!/bin/sh -x
+export CFLAGS=-DQNXNTO_POWERPC
+target=ntoppc ./build-win32
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntosh.nto binutils/build-ntosh.nto
--- binutils-2.10.1/build-ntosh.nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntosh.nto	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntosh ./build-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntosh.qnx4 binutils/build-ntosh.qnx4
--- binutils-2.10.1/build-ntosh.qnx4	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntosh.qnx4	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntosh ./build-qnx4
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntosh.solsparc binutils/build-ntosh.solsparc
--- binutils-2.10.1/build-ntosh.solsparc	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntosh.solsparc	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntosh ./build-solsparc
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntosh.win32 binutils/build-ntosh.win32
--- binutils-2.10.1/build-ntosh.win32	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntosh.win32	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntosh ./build-win32
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntox86.nto binutils/build-ntox86.nto
--- binutils-2.10.1/build-ntox86.nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntox86.nto	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntox86 ./build-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntox86.qnx4 binutils/build-ntox86.qnx4
--- binutils-2.10.1/build-ntox86.qnx4	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntox86.qnx4	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntox86 ./build-qnx4
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntox86.solsparc binutils/build-ntox86.solsparc
--- binutils-2.10.1/build-ntox86.solsparc	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntox86.solsparc	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntox86 ./build-solsparc
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-ntox86.win32 binutils/build-ntox86.win32
--- binutils-2.10.1/build-ntox86.win32	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-ntox86.win32	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,2 @@
+#!/bin/sh -x
+target=ntox86 ./build-win32
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-pinfo binutils/build-pinfo
--- binutils-2.10.1/build-pinfo	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-pinfo	2001-04-05 06:16:31.000000000 +1000
@@ -0,0 +1,196 @@
+#!/bin/sh
+
+LICE=GPL
+
+case $1 in
+*libbfd-2.10.1.so)
+	NAME="BFD Shared Library"
+	DESCRIPTION="Provides Binary File Descriptor services to GNU tools"
+	INSTALLDIR=/usr/lib/
+	;;
+*libbfd.a)
+	NAME="BFD Static Library"
+	DESCRIPTION="Provides Binary File Descriptor services to GNU tools"
+	INSTALLDIR=/usr/lib/
+	;;
+*libbfd.la)
+	NAME="BFD Static Library Libtool Descriptor"
+	DESCRIPTION="Provides Libtool Linking Information about libbfd.a"
+	INSTALLDIR=/usr/lib/
+	;;
+*libopcodes-2.10.1.so)
+	NAME="Opcodes Shared Library"
+	DESCRIPTION="Provides Opcodes services to GNU tools"
+	INSTALLDIR=/usr/lib/
+	;;
+*libbfd.a)
+	NAME="Opcodes Static Library"
+	DESCRIPTION="Provides Opcodes services to GNU tools"
+	INSTALLDIR=/usr/lib/
+	;;
+*libbfd.la)
+	NAME="Opcodes Static Library Libtool Descriptor"
+	DESCRIPTION="Provides Libtool Linking Information about libopcodes.a"
+	INSTALLDIR=/usr/lib/
+	;;
+*libiberty.a)
+	NAME="Libiberty Utility Static Library"
+	DESCRIPTION="Provides miscellaneous services to GNU tools"
+	INSTALLDIR=/usr/lib/
+	;;
+*bfd.h)
+	NAME="bfd.h"
+	DESCRIPTION="Defines interface to GNU BFD library"
+	INSTALLDIR=/usr/include/
+	;;
+*bfdlink.h)
+	NAME="bfdlink.h"
+	DESCRIPTION="Header file for BFD link routines"
+	INSTALLDIR=/usr/include/
+	;;
+*ansidecl.h)
+	NAME="ansidecl.h"
+	DESCRIPTION="ANSI and traditional C compatability macros"
+	INSTALLDIR=/usr/include/
+	;;
+*size)
+	NAME="GNU size 2.10.1"
+	DESCRIPTION="GNU size 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*objdump)
+	NAME="GNU objdump 2.10.1"
+	DESCRIPTION="GNU objdump 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*ar)
+	NAME="GNU ar 2.10.1"
+	DESCRIPTION="GNU ar 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*strings)
+	NAME="GNU strings 2.10.1"
+	DESCRIPTION="GNU strings 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*ranlib)
+	NAME="GNU ranlib 2.10.1"
+	DESCRIPTION="GNU ranlib 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*objcopy)
+	NAME="GNU objcopy 2.10.1"
+	DESCRIPTION="GNU objcopy 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*addr2line)
+	NAME="GNU addr2line 2.10.1"
+	DESCRIPTION="GNU addr2line 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*readelf)
+	NAME="GNU readelf 2.10.1"
+	DESCRIPTION="GNU readelf 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+*gprof)
+	NAME="GNU gprof 2.10.1"
+	DESCRIPTION="GNU gprof 2.10.1"
+	INSTALLDIR=/usr/bin/
+	;;
+esac
+
+echo NAME=$NAME > $1.pinfo
+echo DESCRIPTION=$DESCRIPTION >> $1.pinfo
+echo INSTALLDIR=$INSTALLDIR >> $1.pinfo
+echo LICE=$LICE >> $1.pinfo
+echo DATE=`date +%Y%m%d%H` >> $1.pinfo
+
+file=nto/all/ld/.libs/ld-new
+NAME="GNU ld 2.10.1"
+DESCRIPTION="GNU ld 2.10.1"
+INSTALLDIR=/usr/bin/
+INSTALLNAME=ld
+echo NAME=$NAME > ${file}.pinfo
+echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+echo LICE=$LICE >> ${file}.pinfo
+echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
+
+file=nto/all/gas/gasp-new
+NAME="GNU gasp 2.10.1"
+DESCRIPTION="GNU gasp 2.10.1"
+INSTALLDIR=/usr/bin/
+INSTALLNAME=gasp
+echo NAME=$NAME > ${file}.pinfo
+echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+echo LICE=$LICE >> ${file}.pinfo
+echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
+
+file=nto/all/binutils/.libs/nm-new
+NAME="GNU nm 2.10.1"
+DESCRIPTION="GNU nm 2.10.1"
+INSTALLDIR=/usr/bin/
+INSTALLNAME=nm
+echo NAME=$NAME > ${file}.pinfo
+echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+echo LICE=$LICE >> ${file}.pinfo
+echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
+
+file=nto/all/binutils/.libs/strip-new
+NAME="GNU strip 2.10.1"
+DESCRIPTION="GNU strip 2.10.1"
+INSTALLDIR=/usr/bin/
+INSTALLNAME=strip
+echo NAME=$NAME > ${file}.pinfo
+echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+echo LICE=$LICE >> ${file}.pinfo
+echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
+
+file=nto/all/binutils/cxxfilt
+NAME="GNU c++filt 2.10.1"
+DESCRIPTION="GNU c++filt 2.10.1"
+INSTALLDIR=/usr/bin/
+INSTALLNAME=c++filt
+echo NAME=$NAME > ${file}.pinfo
+echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+echo LICE=$LICE >> ${file}.pinfo
+echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
+
+TARGETS="ntoppc ntomips ntosh ntoarm"
+
+for target in $TARGETS
+do
+  file=nto/all/gas-${target}/.libs/as-new
+  NAME="GNU as 2.10.1"
+  DESCRIPTION="GNU as 2.10.1"
+  INSTALLDIR=/usr/bin/
+  INSTALLNAME=${target}-as
+  echo NAME=$NAME > ${file}.pinfo
+  echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+  echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+  echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+  echo LICE=$LICE >> ${file}.pinfo
+  echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
+done
+
+file=nto/all/gas/.libs/as-new
+NAME="GNU as 2.10.1"
+DESCRIPTION="GNU as 2.10.1"
+INSTALLDIR=/usr/bin/
+INSTALLNAME=as
+echo NAME=$NAME > ${file}.pinfo
+echo DESCRIPTION=$DESCRIPTION >> ${file}.pinfo
+echo INSTALLDIR=$INSTALLDIR >> ${file}.pinfo
+echo INSTALLNAME=$INSTALLNAME >> ${file}.pinfo
+echo LICE=$LICE >> ${file}.pinfo
+echo DATE=`date +%Y%m%d%H` >> ${file}.pinfo
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-qnx4 binutils/build-qnx4
--- binutils-2.10.1/build-qnx4	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-qnx4	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,36 @@
+#!/bin/sh
+
+if test -z $target ; then
+  echo "Don't run this script without setting a target!"
+  exit 1
+fi
+
+basedir=`pwd`
+targdir=qnx4/$target
+dir=/usr/gcc
+
+export CC="qcc -Vgcc_$target"
+
+rm -rf $targdir
+mkdir -p $targdir
+cd $targdir
+if $basedir/configure \
+	--target=$target \
+	--srcdir=$basedir \
+	--prefix=$dir \
+	--exec-prefix=$dir \
+	--with-local-prefix=$dir \
+	--verbose
+then
+	echo "Configured OK."
+	echo "hacking ldemul-list"
+	cd ld
+	make ldemul-list.h
+	tr -d '\000' <ldemul-list.h >x
+	mv -f x ldemul-list.h
+	cd ..
+	make
+else
+	echo "Configure Failed!"
+exit 1
+fi
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-solsparc binutils/build-solsparc
--- binutils-2.10.1/build-solsparc	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-solsparc	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,34 @@
+#!/bin/bash -x
+
+basedir=`pwd`
+dir=/opt/QNXsdk/host/solaris/sparc/usr
+
+if [ -z "$target" ]; then
+    echo "Don't run this script without setting target!"
+    exit 1
+fi
+
+rm -rf solsparc/$target
+mkdir -p solsparc/$target
+cd solsparc/$target
+
+if $basedir/configure \
+	--srcdir=$basedir \
+	--target=$target \
+	--prefix=$dir \
+	--exec-prefix=$dir \
+	--with-local-prefix=$dir \
+	--verbose
+then
+	echo "Configured OK."
+	echo "hacking ldemul-list"
+	cd ld
+	make ldemul-list.h
+	tr -d '\000' <ldemul-list.h >x
+	mv -f x ldemul-list.h
+	cd ..
+	make
+else
+	echo "Configure Failed."
+fi
+
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-solsparc.nto binutils/build-solsparc.nto
--- binutils-2.10.1/build-solsparc.nto	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-solsparc.nto	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,5 @@
+#! /bin/sh
+
+export target=sparc-sun-solaris2.6 
+export dir=/opt/QNXsdk/host/qnx6/$PROCESSOR/usr
+./build-nto
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/build-win32 binutils/build-win32
--- binutils-2.10.1/build-win32	1970-01-01 10:00:00.000000000 +1000
+++ binutils/build-win32	2001-02-27 05:19:38.000000000 +1000
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+if test -z $target ; then
+  echo "Don't run this script without setting a target!"
+  exit 1
+fi
+
+basedir=`pwd`
+targdir=win32/$target
+dir=/usr/gcc
+
+rm -rf $targdir
+mkdir -p $targdir
+cd $targdir
+if $basedir/configure \
+	--target=$target \
+	--srcdir=$basedir \
+	--prefix=$dir \
+	--exec-prefix=$dir \
+	--with-local-prefix=$dir \
+	--verbose
+then
+	echo "Configured OK."
+	echo "hacking ldemul-list"
+	cd ld
+	make ldemul-list.h
+	tr -d '\000' <ldemul-list.h >x
+	mv -f x ldemul-list.h
+	cd ..
+	make
+else
+	echo "Configure Failed!"
+exit 1
+fi
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/config.guess binutils/config.guess
--- binutils-2.10.1/config.guess	2000-10-17 03:51:02.000000000 +1000
+++ binutils/config.guess	2001-02-27 05:19:38.000000000 +1000
@@ -2,9 +2,7 @@
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
 #   Free Software Foundation, Inc.
-
-version='2000-09-05'
-
+#
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -38,46 +36,6 @@
 # (but try to keep the structure clean).
 #
 
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION]
-
-Output the configuration name of this system.
-
-Operation modes:
-  -h, --help               print this help, then exit
-  -V, --version            print version number, then exit"
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case "$1" in
-    --version | --vers* | -V )
-       echo "$version" ; exit 0 ;;
-    --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       exec >&2
-       echo "$me: invalid option $1"
-       echo "$help"
-       exit 1 ;;
-    * )
-       break ;;
-  esac
-done
-
-if test $# != 0; then
-  echo "$me: too many arguments$help" >&2
-  exit 1
-fi
-
 # Use $HOST_CC if defined. $CC may point to a cross-compiler
 if test x"$CC_FOR_BUILD" = x; then
   if test x"$HOST_CC" != x; then
@@ -119,7 +77,7 @@
 	# object file format.
 	# Determine the machine/vendor (is the vendor relevant).
 	case "${UNAME_MACHINE}" in
-	    amiga) machine=m68k-unknown ;;
+	    amiga) machine=m68k-cbm ;;
 	    arm32) machine=arm-unknown ;;
 	    atari*) machine=m68k-atari ;;
 	    sun3*) machine=m68k-sun ;;
@@ -215,7 +173,7 @@
 	echo alpha-dec-winnt3.5
 	exit 0 ;;
     Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
+	echo m68k-cbm-sysv4
 	exit 0;;
     amiga:OpenBSD:*:*)
 	echo m68k-unknown-openbsd${UNAME_RELEASE}
@@ -669,9 +627,6 @@
     i*:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit 0 ;;
-    i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
@@ -690,9 +645,6 @@
     *:GNU:*:*)
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit 0 ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
     *:Linux:*:*)
 
 	# The BFD linker knows what the default object file format is, so
@@ -715,7 +667,8 @@
 		exit 0
 		;;
 	  elf_i?86)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		echo "${UNAME_MACHINE}-pc-linux"
+		exit 0
 		;;
 	  i?86coff)
 		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
@@ -773,10 +726,6 @@
 		echo powerpc-unknown-linux-gnu${LIBC}
 		exit 0
 		;;
-	  shelf_linux)
-		echo "${UNAME_MACHINE}-unknown-linux-gnu"
-		exit 0
-		;;
 	esac
 
 	if test "${UNAME_MACHINE}" = "alpha" ; then
@@ -858,8 +807,6 @@
 	  rm -f $dummy.c $dummy
 	elif test "${UNAME_MACHINE}" = "s390"; then
 	  echo s390-ibm-linux && exit 0
-	elif test "${UNAME_MACHINE}" = "x86_64"; then
-	  echo x86_64-unknown-linux-gnu && exit 0
 	else
 	  # Either a pre-BFD a.out linker (linux-gnuoldld)
 	  # or one that does not give us useful --help.
@@ -904,7 +851,6 @@
 EOF
 	  $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
 	  rm -f $dummy.c $dummy
-	  test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
 	fi ;;
 # ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
 # are messed up and put the nodename in both sysname and nodename.
@@ -1041,7 +987,7 @@
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
 	exit 0 ;;
-    news*:NEWS-OS:6*:*)
+    news*:NEWS-OS:*:6*)
 	echo mips-sony-newsos6
 	exit 0 ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
@@ -1084,7 +1030,7 @@
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit 0 ;;
-    NSR-[KW]:NONSTOP_KERNEL:*:*)
+    NSR-W:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
 	exit 0 ;;
     BS2000:POSIX*:*:*)
@@ -1093,17 +1039,6 @@
     DS/*:UNIX_System_V:*:*)
 	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
 	exit 0 ;;
-    *:Plan9:*:*)
-	# "uname -m" is not consistent, so use $cputype instead. 386
-	# is converted to i386 for consistency with other x86
-	# operating systems.
-	if test "$cputype" = "386"; then
-	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
-	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
@@ -1243,47 +1178,6 @@
     esac
 fi
 
-cat >&2 <<EOF
-$0: unable to guess system type
-
-The $version version of this script cannot recognize your system type.
-Please download the most up to date version of the config scripts:
-
-    ftp://ftp.gnu.org/pub/gnu/config/
-
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
-
-config.guess version = $version
-
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
-
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
-
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
-EOF
+#echo '(Unable to guess system type)' 1>&2
 
 exit 1
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "version='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/config.sub binutils/config.sub
--- binutils-2.10.1/config.sub	2000-10-17 03:51:02.000000000 +1000
+++ binutils/config.sub	2001-02-27 05:19:38.000000000 +1000
@@ -1,10 +1,6 @@
 #! /bin/sh
 # Configuration validation subroutine script, version 1.1.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
-#   Free Software Foundation, Inc.
-
-version='2000-09-11'
-
+#   Copyright (C) 1991, 92-97, 1998, 1999 Free Software Foundation, Inc.
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
@@ -29,8 +25,6 @@
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Please send patches to <config-patches@gnu.org>.
-#
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
@@ -51,61 +45,30 @@
 #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
-
-Canonicalize a configuration name.
-
-Operation modes:
-  -h, --help               print this help, then exit
-  -V, --version            print version number, then exit"
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case "$1" in
-    --version | --vers* | -V )
-       echo "$version" ; exit 0 ;;
-    --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       exec >&2
-       echo "$me: invalid option $1"
-       echo "$help"
-       exit 1 ;;
-
-    *local*)
-       # First pass through any local machine types.
-       echo $1
-       exit 0;;
-
-    * )
-       break ;;
-  esac
-done
+if [ x$1 = x ]
+then
+	echo Configuration name missing. 1>&2
+	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
+	echo "or     $0 ALIAS" 1>&2
+	echo where ALIAS is a recognized configuration type. 1>&2
+	exit 1
+fi
 
-case $# in
- 0) echo "$me: missing argument$help" >&2
-    exit 1;;
- 1) ;;
- *) echo "$me: too many arguments$help" >&2
-    exit 1;;
+# First pass through any local machine types.
+case $1 in
+	*local*)
+		echo $1
+		exit 0
+		;;
+	*)
+	;;
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu*)
+  linux-gnu* | nto-qnx*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
@@ -131,7 +94,7 @@
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis)
+	-apple)
 		os=
 		basic_machine=$1
 		;;
@@ -142,7 +105,7 @@
 	-scout)
 		;;
 	-wrs)
-		os=-vxworks
+		os=vxworks
 		basic_machine=$1
 		;;
 	-hiux*)
@@ -181,6 +144,12 @@
 	-isc*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-qnx*)
+		os=-qnx
+		;;
+	-nto*)
+		os=-nto
+		;;
 	-lynx*)
 		os=-lynxos
 		;;
@@ -193,10 +162,6 @@
 	-psos*)
 		os=-psos
 		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
@@ -204,35 +169,27 @@
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
 	tahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \
-		| arme[lb] | armv[2345] | armv[345][lb] | pyramid | mn10200 | mn10300 | tron | a29k \
+		| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \
 		| 580 | i960 | h8300 \
 		| x86 | ppcbe | mipsbe | mipsle | shbe | shle | armbe | armle \
 		| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \
-		| hppa64 \
-		| alpha | alphaev[4-8] | alphaev56 | alphapca5[67] \
-		| alphaev6[78] \
-		| we32k | ns16k | clipper | i370 | sh | sh[34] \
-		| powerpc | powerpcle \
+		| alpha | alphaev[4-7] | alphaev56 | alphapca5[67] \
+		| we32k | ns16k | clipper | i370 | sh | powerpc | ppc | powerpcle \
 		| 1750a | dsp16xx | pdp11 | mips16 | mips64 | mipsel | mips64el \
 		| mips64orion | mips64orionel | mipstx39 | mipstx39el \
 		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
 		| mips64vr5000 | miprs64vr5000el | mcore \
 		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
-		| thumb | d10v | d30v | fr30 | avr)
+		| thumb | d10v)
 		basic_machine=$basic_machine-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
-		basic_machine=$basic_machine-unknown
-		os=-none
-		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65 | pj | pjl)
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65)
 		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
-	i[234567]86 | x86_64)
+	i[34567]86)
 	  basic_machine=$basic_machine-pc
 	  ;;
 	# Object if more than one company name word.
@@ -242,16 +199,14 @@
 		;;
 	# Recognize the basic CPU types with company name.
 	# FIXME: clean up the formatting here.
-	vax-* | tahoe-* | i[234567]86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \
+	vax-* | tahoe-* | i[34567]86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \
 	      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \
 	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
 	      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \
 	      | xmp-* | ymp-* \
 	      | x86-* | ppcbe-* | mipsbe-* | mipsle-* | shbe-* | shle-* | armbe-* | armle-* \
-	      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* \
-	      | hppa2.0n-* | hppa64-* \
-	      | alpha-* | alphaev[4-8]-* | alphaev56-* | alphapca5[67]-* \
-	      | alphaev6[78]-* \
+	      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* | hppa2.0n-* \
+	      | alpha-* | alphaev[4-7]-* | alphaev56-* | alphapca5[67]-* \
 	      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \
 	      | clipper-* | orion-* \
 	      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \
@@ -259,10 +214,9 @@
 	      | mips64el-* | mips64orion-* | mips64orionel-* \
 	      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \
 	      | mipstx39-* | mipstx39el-* | mcore-* \
-	      | f301-* | armv*-* | s390-* | sv1-* | t3e-* \
+	      | f301-* | armv*-* | t3e-* \
 	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
-	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* | fr30-* \
-	      | bs2000-* | tic54x-* | c54x-* | x86_64-*)
+	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* )
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
@@ -299,14 +253,14 @@
 		os=-sysv
 		;;
 	amiga | amiga-*)
-		basic_machine=m68k-unknown
+		basic_machine=m68k-cbm
 		;;
 	amigaos | amigados)
-		basic_machine=m68k-unknown
+		basic_machine=m68k-cbm
 		os=-amigaos
 		;;
 	amigaunix | amix)
-		basic_machine=m68k-unknown
+		basic_machine=m68k-cbm
 		os=-sysv4
 		;;
 	apollo68)
@@ -360,9 +314,6 @@
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
@@ -483,6 +434,7 @@
 		;;
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
+		os=-mvs
 		;;
 # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
 	i[34567]86v32)
@@ -517,10 +469,6 @@
 		basic_machine=i386-unknown
 		os=-mingw32
 		;;
-	i[34567]86-pw32 | pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
 	iris | iris4d)
 		basic_machine=mips-sgi
 		case $os in
@@ -549,7 +497,7 @@
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+	*mint | *MiNT)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
@@ -567,10 +515,6 @@
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
@@ -579,10 +523,6 @@
 		basic_machine=i386-unknown
 		os=-msdos
 		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
@@ -592,7 +532,7 @@
 		os=-netbsd
 		;;
 	netwinder)
-		basic_machine=armv4l-rebel
+		basic_machine=armv4l-corel
 		os=-linux
 		;;
 	news | news700 | news800 | news900)
@@ -636,6 +576,40 @@
 		basic_machine=i960-intel
 		os=-nindy
 		;;
+	ntox86)
+		basic_machine=i386${os:--unknown}
+		os=-nto-qnx
+		;;
+	ntoppc)
+		basic_machine=powerpc${os:--unknown}
+		os=-nto-qnx
+		;;
+	ntoarm)
+		basic_machine=arm${os:--unknown}
+		os=-nto-qnx
+		;;
+	ntosh)
+		basic_machine=sh${os:--unknown}
+		os=-nto-qnx
+		;;
+	ntomips)
+		basic_machine=mips${os:--unknown}
+		os=-nto-qnx
+		;;
+	nto*le | nto*be)
+		basic_machine=${basic_machine%%be}
+		basic_machine=${basic_machine%%le}
+		basic_machine=${basic_machine##nto}${os:--unknown}
+		os=-nto-qnx
+		;;
+	ntomulti)
+		basic_machine=i686${os:--unknown}
+		os=-cygwin32
+		;;
+	nto*)
+		basic_machine=${basic_machine##nto}${os:--unknown}
+		os=-nto-qnx
+		;;
 	mon960)
 		basic_machine=i960-intel
 		os=-mon960
@@ -643,9 +617,6 @@
 	np1)
 		basic_machine=np1-gould
 		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
-		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
@@ -678,7 +649,7 @@
 	pentium | p5 | k5 | k6 | nexen)
 		basic_machine=i586-pc
 		;;
-	pentiumpro | p6 | 6x86 | athlon)
+	pentiumpro | p6 | 6x86)
 		basic_machine=i686-pc
 		;;
 	pentiumii | pentium2)
@@ -687,7 +658,7 @@
 	pentium-* | p5-* | k5-* | k6-* | nexen-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+	pentiumpro-* | p6-* | 6x86-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumii-* | pentium2-*)
@@ -790,10 +761,6 @@
 	sun386 | sun386i | roadrunner)
 		basic_machine=i386-sun
 		;;
-	sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
 	symmetry)
 		basic_machine=i386-sequent
 		os=-dynix
@@ -802,10 +769,6 @@
 		basic_machine=t3e-cray
 		os=-unicos
 		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
@@ -907,9 +870,6 @@
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4)
-		base_machine=sh-unknown
-		;;
 	sparc | sparcv9)
 		basic_machine=sparc-sun
 		;;
@@ -970,6 +930,18 @@
 	-unixware*)
 		os=-sysv4.2uw
 		;;
+	-qnx*)
+		case $basic_machine in
+			x86-* | i[34567]86-*)
+				;;
+			*)
+				os=-nto$os
+				;;
+		esac
+		;;
+	-nto*)
+		os=-nto-qnx
+		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
@@ -990,17 +962,16 @@
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32*)
+	      | -interix* | -uwin* | -rhapsody* | -openstep* | -oskit*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
-		    x86-* | i[34567]86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
+			x86-* | i[34567]86-*)
+				;;
+			*)
+				os=-nto$os
+				;;
 		esac
 		;;
 	-nto*)
@@ -1008,7 +979,7 @@
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
 	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+	      | -macos* | -mpw* | -magic* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
@@ -1022,12 +993,6 @@
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
-	-opened*)
-		os=-openedition
-		;;
-	-wince*)
-		os=-wince
-		;;
 	-osfrose*)
 		os=-osfrose
 		;;
@@ -1052,9 +1017,6 @@
 	-ns2 )
 	        os=-nextstep2
 		;;
-	-nsk*)
-		os=-nsk
-		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
@@ -1117,7 +1079,7 @@
 	*-acorn)
 		os=-riscix1.2
 		;;
-	arm*-rebel)
+	arm*-corel)
 		os=-linux
 		;;
 	arm*-semi)
@@ -1291,7 +1253,7 @@
 			-genix*)
 				vendor=ns
 				;;
-			-mvs* | -opened*)
+			-mvs*)
 				vendor=ibm
 				;;
 			-ptx*)
@@ -1318,11 +1280,3 @@
 esac
 
 echo $basic_machine$os
-exit 0
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "version='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/configure binutils/configure
--- binutils-2.10.1/configure	2000-03-30 12:19:55.000000000 +1000
+++ binutils/configure	2001-02-27 05:19:38.000000000 +1000
@@ -86,7 +86,7 @@
 target_alias=NOTARGET
 target_makefile_frag=
 undefs=NOUNDEFS
-version="$Revision: 1.5 $"
+version="$Revision: 1.1.1.1 $"
 x11=default
 bindir='${exec_prefix}/bin'
 sbindir='${exec_prefix}/sbin'
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/create-package-qpg binutils/create-package-qpg
--- binutils-2.10.1/create-package-qpg	1970-01-01 10:00:00.000000000 +1000
+++ binutils/create-package-qpg	2001-03-21 03:12:43.000000000 +1000
@@ -0,0 +1,117 @@
+#/bin/ksh
+
+# first of all, generate pinfo files for executables and shared objects
+
+echo "\n<!-- All binaries and shared objects that need pinfo files -->"
+while read dest source
+do
+	echo "<QPG:Add file=\"$source\" pinfo=\"$source.pinfo\" />"
+done <<EOF
+/usr/lib/	nto/all/bfd/.libs/libbfd-2.10.1.so
+/usr/lib/	nto/all/opcodes/.libs/libopcodes-2.10.1.so
+/usr/bin/	nto/all/binutils/.libs/size
+/usr/bin/	nto/all/binutils/.libs/objdump
+/usr/bin/	nto/all/binutils/.libs/ar
+/usr/bin/	nto/all/binutils/.libs/strings
+/usr/bin/	nto/all/binutils/.libs/ranlib
+/usr/bin/	nto/all/binutils/.libs/objcopy
+/usr/bin/	nto/all/binutils/.libs/addr2line
+/usr/bin/nm	nto/all/binutils/.libs/nm-new
+/usr/bin/	nto/all/binutils/readelf
+/usr/bin/strip	nto/all/binutils/.libs/strip-new
+/usr/bin/c++filt	nto/all/binutils/cxxfilt
+/usr/bin/as	nto/all/gas/.libs/as-new
+/usr/bin/ntoarm-as      nto/all/gas-ntoarm/.libs/as-new
+/usr/bin/ntoppc-as      nto/all/gas-ntoppc/.libs/as-new
+/usr/bin/ntomips-as     nto/all/gas-ntomips/.libs/as-new
+/usr/bin/ntosh-as       nto/all/gas-ntosh/.libs/as-new
+/usr/bin/gasp	nto/all/gas/gasp-new
+/usr/bin/	nto/all/gprof/.libs/gprof
+/usr/bin/ld	nto/all/ld/.libs/ld-new
+EOF
+
+echo "\n<!-- Next, all real files -->"
+# next, all other real files
+while read dest source
+do
+	echo "<QPG:Add file=\"$source\" install=\"$dest\" />"
+done <<EOF
+/usr/lib/	nto/all/bfd/libbfd.la
+/usr/lib/	nto/all/bfd/.libs/libbfd.a
+/usr/lib/	nto/all/opcodes/libopcodes.la
+/usr/lib/	nto/all/opcodes/.libs/libopcodes.a
+/usr/lib/	nto/all/libiberty/libiberty.a
+/usr/include/	nto/all/bfd/bfd.h
+/usr/include/	include/ansidecl.h
+/usr/include/	include/bfdlink.h
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/armnto.x
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/armnto.xbn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/armnto.xn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/armnto.xr
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/armnto.xs
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/armnto.xu
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32bmipnto.x
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32bmipnto.xbn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32bmipnto.xn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32bmipnto.xr
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32bmipnto.xs
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32bmipnto.xu
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32ppcnto.x
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32ppcnto.xbn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32ppcnto.xn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32ppcnto.xr
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32ppcnto.xs
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/elf32ppcnto.xu
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/i386nto.x
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/i386nto.xbn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/i386nto.xn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/i386nto.xr
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/i386nto.xs
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/i386nto.xu
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shelf_nto.x
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shelf_nto.xbn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shelf_nto.xn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shelf_nto.xr
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shelf_nto.xs
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shelf_nto.xu
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shlelf_nto.x
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shlelf_nto.xbn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shlelf_nto.xn
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shlelf_nto.xr
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shlelf_nto.xs
+/usr/ntox86/lib/ldscripts/	nto/all/ld/ldscripts/shlelf_nto.xu
+/usr/man/man1/	binutils/ar.1
+/usr/man/man1/	binutils/nm.1
+/usr/man/man1/	binutils/objdump.1
+/usr/man/man1/	binutils/ranlib.1
+/usr/man/man1/	binutils/size.1
+/usr/man/man1/	binutils/strings.1
+/usr/man/man1/	binutils/strip.1
+/usr/man/man1/	binutils/objcopy.1
+/usr/man/man1/	binutils/addr2line.1
+/usr/man/man1/	binutils/nlmconv.1
+/usr/man/man1/	binutils/c++filt.1
+/usr/man/man1/	gas/as.1
+/usr/man/man1/	gprof/gprof.1
+/usr/man/man1/	ld/ld.1
+EOF
+
+echo "\n<!-- Last, all symbolic links -->"
+# lastly, create links
+while read dest name link
+do
+	echo "<QPG:Add file=\"$name\" install=\"$dest\" filetype=\"symlink\" linkto=\"$link\" />"
+done << EOF
+/usr/ntox86/bin/	nm	../../bin/nm
+/usr/ntox86/bin/	strip	../../bin/strip
+/usr/ntox86/bin/	ar	../../bin/ar
+/usr/ntox86/bin/	ranlib	../../bin/ranlib
+/usr/ntox86/bin/	as	../../bin/as
+/usr/ntox86/bin/	ld	../../bin/ld
+/usr/bin/	ntox86-nm	nm
+/usr/bin/	ntox86-strip	strip
+/usr/bin/	ntox86-ar	bin/ar
+/usr/bin/	ntox86-ranlib	ranlib
+/usr/bin/	ntox86-as	as
+/usr/bin/	ntox86-ld	ld
+EOF
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/tc-arm.c binutils/gas/config/tc-arm.c
--- binutils-2.10.1/gas/config/tc-arm.c	2000-11-04 03:16:09.000000000 +1000
+++ binutils/gas/config/tc-arm.c	2001-05-31 01:49:06.000000000 +1000
@@ -5240,6 +5240,7 @@
     }
   else
     {
+#if 0
       /* For a 4 byte float the order of elements in `words' is 1 0.  For an
 	 8 byte float the order is 1 0 3 2.  */
       for (i = 0; i < prec; i += 2)
@@ -5248,6 +5249,14 @@
 	  md_number_to_chars (litP + 2, (valueT) words[i], 2);
 	  litP += 4;
 	}
+#else
+/* @@@@ FIXME this should check for ARM-Neutrino target */
+      for (i = prec-1; i >= 0; i--)
+	{
+	  md_number_to_chars (litP, (valueT) words[i], 2);
+	  litP += 2;
+	}
+#endif
     }
 
   return 0;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/tc-mips.c binutils/gas/config/tc-mips.c
--- binutils-2.10.1/gas/config/tc-mips.c	2000-03-11 12:16:25.000000000 +1000
+++ binutils/gas/config/tc-mips.c	2005-09-21 10:57:27.000000000 +1000
@@ -294,8 +294,18 @@
      segment has a maximum size of 64K, all data references are off
      the $gp register, and all text references are PC relative.  This
      is used on some embedded systems.  */
-  EMBEDDED_PIC
+  EMBEDDED_PIC,
+  /* Generate QNX PIC code for use on the MIPS, similar to the SVR4
+     code but the regular GP register is not used. Instead, we do all
+     references to the GOT through $23, and calculate our own adress in
+     every function. */
+  QNX_PIC
 };
+/* Macro to define the GOT pointer register */
+#define GOT_REG ((mips_pic == SVR4_PIC) ? GP : 23)
+
+/* Macro to get rid of some of the nops.. */
+#define NOP_NEEDED ((mips_pic != QNX_PIC) || (mips_opts.isa < 2))
 
 static enum mips_pic_level mips_pic;
 
@@ -675,6 +685,8 @@
 static void s_option PARAMS ((int));
 static void s_mipsset PARAMS ((int));
 static void s_abicalls PARAMS ((int));
+static void s_qnxpiccalls PARAMS ((int));
+static void s_noqnxpiccalls PARAMS ((int));
 static void s_cpload PARAMS ((int));
 static void s_cprestore PARAMS ((int));
 static void s_gpword PARAMS ((int));
@@ -722,6 +734,8 @@
   {"sdata", s_change_sec, 's'},
   {"livereg", s_ignore, 0},
   {"abicalls", s_abicalls, 0},
+  {"qnxpiccalls", s_qnxpiccalls, 0},
+  {"noqnxpiccalls", s_noqnxpiccalls, 0},
   {"cpload", s_cpload, 0},
   {"cprestore", s_cprestore, 0},
   {"gpword", s_gpword, 0},
@@ -849,7 +863,7 @@
   register unsigned int i = 0;
   const char *cpu;
   char *a = NULL;
-  int broken = 0;
+  int broken = 0, explicit_isa = 0;
   int mips_isa_from_cpu;
 
   /* GP relative stuff not working for PE */
@@ -983,6 +997,8 @@
       else
 	mips_opts.isa = 1;
     }
+    else
+    	explicit_isa = 1;
 
   if (mips_opts.mips16 < 0)
     {
@@ -1012,7 +1028,7 @@
       && 0 == strcmp (mips_abi_string,"eabi"))
     mips_eabi64 = 1;
 
-  if (mips_cpu != 0 && mips_cpu != -1)
+  if (mips_cpu != 0 && mips_cpu != -1 && !(explicit_isa) )
     {
       ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, mips_cpu);
       
@@ -3290,7 +3306,7 @@
 		    ? "addiu" : "daddiu"),
 		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
     }
-  else if (mips_pic == SVR4_PIC && ! mips_big_got)
+  else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
     {
       expressionS ex;
 
@@ -3308,10 +3324,12 @@
 		   ((bfd_arch_bits_per_address (stdoutput) == 32
 		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		    ? "lw" : "ld"),
-		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GP);
+		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+      if (NOP_NEEDED) 
       macro_build ((char *) NULL, counter, (expressionS *) NULL, "nop", "");
       p = frag_var (rs_machine_dependent, 4, 0,
-		    RELAX_ENCODE (0, 4, -8, 0, 0, mips_opts.warn_about_macros),
+		    RELAX_ENCODE (0, 4, NOP_NEEDED ? -8 : -4, 
+		    0, 0, mips_opts.warn_about_macros),
 		    ep->X_add_symbol, (offsetT) 0, (char *) NULL);
       macro_build (p, counter, ep,
 		   ((bfd_arch_bits_per_address (stdoutput) == 32
@@ -3330,7 +3348,7 @@
 		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
 	}
     }
-  else if (mips_pic == SVR4_PIC)
+  else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
     {
       expressionS ex;
       int off;
@@ -3347,7 +3365,7 @@
 	 If there is a constant, it must be added in after.  */
       ex.X_add_number = ep->X_add_number;
       ep->X_add_number = 0;
-      if (reg_needs_delay (GP))
+      if (reg_needs_delay (GOT_REG))
 	off = 4;
       else
 	off = 0;
@@ -3358,7 +3376,7 @@
 		   ((bfd_arch_bits_per_address (stdoutput) == 32
 		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		    ? "addu" : "daddu"),
-		   "d,v,t", reg, reg, GP);
+		   "d,v,t", reg, reg, GOT_REG);
       macro_build ((char *) NULL, counter, ep,
 		   ((bfd_arch_bits_per_address (stdoutput) == 32
 		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
@@ -3381,7 +3399,7 @@
 		   ((bfd_arch_bits_per_address (stdoutput) == 32
 		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		    ? "lw" : "ld"),
-		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GP);
+		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
       p += 4;
       macro_build (p, counter, (expressionS *) NULL, "nop", "");
       p += 4;
@@ -4231,7 +4249,7 @@
 			? "addiu" : "daddiu"),
 		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
 	}
-      else if (mips_pic == SVR4_PIC && ! mips_big_got)
+      else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
 	{
 	  /* If this is a reference to an external symbol, and there
 	     is no constant, we want
@@ -4264,13 +4282,15 @@
 	  frag_grow (32);
 	  macro_build ((char *) NULL, &icnt, &offset_expr,
 		       dbl ? "ld" : "lw",
-		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	  if (expr1.X_add_number == 0)
 	    {
 	      int off;
 
-	      if (breg == 0)
+	      if ((breg == 0) && (NOP_NEEDED))
 		off = 0;
+	      else if (!NOP_NEEDED)
+		off = 4;
 	      else
 		{
 		  /* We're going to put in an addu instruction using
@@ -4281,13 +4301,14 @@
 		  off = 4;
 		}
 	      p = frag_var (rs_machine_dependent, 8 - off, 0,
-			    RELAX_ENCODE (0, 8 - off, -4 - off, 4 - off, 0,
+			    RELAX_ENCODE (0, 8 - off, NOP_NEEDED ? (-4 - off) : (0 - off),
+					  4 - off, 0,
 					  (breg == 0
 					   ? mips_opts.warn_about_macros
 					   : 0)),
 			    offset_expr.X_add_symbol, (offsetT) 0,
 			    (char *) NULL);
-	      if (breg == 0)
+	      if ((breg == 0) && (NOP_NEEDED))
 		{
 		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
 		  p += 4;
@@ -4304,7 +4325,8 @@
 	  else if (expr1.X_add_number >= -0x8000
 		   && expr1.X_add_number < 0x8000)
 	    {
-	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+	      if(NOP_NEEDED) 
+			  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
 			   "nop", "");
 	      macro_build ((char *) NULL, &icnt, &expr1,
 			   ((bfd_arch_bits_per_address (stdoutput) == 32
@@ -4312,7 +4334,8 @@
 			    ? "addiu" : "daddiu"),
 			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
 	      (void) frag_var (rs_machine_dependent, 0, 0,
-			       RELAX_ENCODE (0, 0, -12, -4, 0, 0),
+			       RELAX_ENCODE (0, 0, NOP_NEEDED ? -12 : -8, 
+			       -4, 0, 0),
 			       offset_expr.X_add_symbol, (offsetT) 0,
 			       (char *) NULL);
 	    }
@@ -4331,7 +4354,8 @@
 		off1 = 0;
 	      else
 		{
-		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		  if (NOP_NEEDED)
+			  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
 			       "nop", "");
 		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
 			       ((bfd_arch_bits_per_address (stdoutput) == 32
@@ -4340,7 +4364,7 @@
 			       "d,v,t", treg, AT, breg);
 		  breg = 0;
 		  tempreg = treg;
-		  off1 = -8;
+		  off1 = (NOP_NEEDED) ? -8 : -4;
 		}
 
 	      /* Set mips_optimize around the lui instruction to avoid
@@ -4367,7 +4391,7 @@
 	      used_at = 1;
 	    }
 	}
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
 	  int gpdel;
 
@@ -4410,7 +4434,7 @@
 	  expr1.X_add_number = offset_expr.X_add_number;
 	  offset_expr.X_add_number = 0;
 	  frag_grow (52);
-	  if (reg_needs_delay (GP))
+	  if (reg_needs_delay (GOT_REG))
 	    gpdel = 4;
 	  else
 	    gpdel = 0;
@@ -4420,7 +4444,7 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 			? "addu" : "daddu"),
-		       "d,v,t", tempreg, tempreg, GP);
+		       "d,v,t", tempreg, tempreg, GOT_REG);
 	  macro_build ((char *) NULL, &icnt, &offset_expr,
 		       dbl ? "ld" : "lw",
 		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_LO16,
@@ -4538,7 +4562,7 @@
 	    }
 	  macro_build (p, &icnt, &offset_expr,
 		       dbl ? "ld" : "lw",
-		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	  p += 4;
 	  if (expr1.X_add_number >= -0x8000
 	      && expr1.X_add_number < 0x8000)
@@ -4640,15 +4664,16 @@
 	  || mips_pic == EMBEDDED_PIC)
 	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr",
 		     "d,s", dreg, sreg);
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
-	  if (sreg != PIC_CALL_REG)
+	  if ((sreg != PIC_CALL_REG) && (mips_pic != QNX_PIC))
 	    as_warn (_("MIPS PIC call to register other than $25"));
       
 	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr",
 		       "d,s", dreg, sreg);
-	  if (mips_cprestore_offset < 0)
-	    as_warn (_("No .cprestore pseudo-op used in PIC code"));
+	  if (mips_cprestore_offset < 0) {
+	    if (mips_pic != QNX_PIC) as_warn ("No .cprestore pseudo-op used in PIC code");
+	    }
 	  else
 	    {
 	      expr1.X_add_number = mips_cprestore_offset;
@@ -4656,7 +4681,7 @@
 			   ((bfd_arch_bits_per_address (stdoutput) == 32
 			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 			    ? "lw" : "ld"),
-			   "t,o(b)", GP, (int) BFD_RELOC_LO16, mips_frame_reg);
+			   "t,o(b)", GOT_REG, (int) BFD_RELOC_LO16, mips_frame_reg);
 	    }
 	}
       else
@@ -4667,7 +4692,7 @@
     case M_JAL_A:
       if (mips_pic == NO_PIC)
 	macro_build ((char *) NULL, &icnt, &offset_expr, "jal", "a");
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
 	  /* If this is a reference to an external symbol, and we are
 	     using a small GOT, we want
@@ -4695,16 +4720,26 @@
 	  frag_grow (40);
 	  if (! mips_big_got)
 	    {
-	      macro_build ((char *) NULL, &icnt, &offset_expr,
+	      if(mips_pic != QNX_PIC) 
+			  macro_build ((char *) NULL, &icnt, &offset_expr,
+				   ((bfd_arch_bits_per_address (stdoutput) == 32
+					 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+					? "lw" : "ld"),
+				   "t,o(b)", PIC_CALL_REG,
+				   (int) BFD_RELOC_MIPS_CALL16, GOT_REG);
+	      else 
+	          macro_build ((char *) NULL, &icnt, &offset_expr,
 			   ((bfd_arch_bits_per_address (stdoutput) == 32
-			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			     || mips_opts.isa < 3)
 			    ? "lw" : "ld"),
 			   "t,o(b)", PIC_CALL_REG,
-			   (int) BFD_RELOC_MIPS_CALL16, GP);
-	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	      if(NOP_NEEDED) 
+	      	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
 			   "nop", "");
 	      p = frag_var (rs_machine_dependent, 4, 0,
-			    RELAX_ENCODE (0, 4, -8, 0, 0, 0),
+			    RELAX_ENCODE (0, 4, NOP_NEEDED ? -8 : -4, 
+			    0, 0, 0),
 			    offset_expr.X_add_symbol, (offsetT) 0,
 			    (char *) NULL);
 	    }
@@ -4712,7 +4747,7 @@
 	    {
 	      int gpdel;
 
-	      if (reg_needs_delay (GP))
+	      if (reg_needs_delay (GOT_REG))
 		gpdel = 4;
 	      else
 		gpdel = 0;
@@ -4722,7 +4757,7 @@
 			   ((bfd_arch_bits_per_address (stdoutput) == 32
 			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 			    ? "addu" : "daddu"),
-			   "d,v,t", PIC_CALL_REG, PIC_CALL_REG, GP);
+			   "d,v,t", PIC_CALL_REG, PIC_CALL_REG, GOT_REG);
 	      macro_build ((char *) NULL, &icnt, &offset_expr,
 			   ((bfd_arch_bits_per_address (stdoutput) == 32
 			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
@@ -4746,7 +4781,7 @@
 			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 			    ? "lw" : "ld"),
 			   "t,o(b)", PIC_CALL_REG,
-			   (int) BFD_RELOC_MIPS_GOT16, GP);
+			   (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	      p += 4;
 	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
 	      p += 4;
@@ -4760,7 +4795,7 @@
 	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
 		       "jalr", "s", PIC_CALL_REG);
 	  if (mips_cprestore_offset < 0)
-	    as_warn (_("No .cprestore pseudo-op used in PIC code"));
+	    if (mips_pic != QNX_PIC) as_warn ("No .cprestore pseudo-op used in PIC code");
 	  else
 	    {
 	      if (mips_opts.noreorder)
@@ -4771,7 +4806,7 @@
 			   ((bfd_arch_bits_per_address (stdoutput) == 32
 			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 			    ? "lw" : "ld"),
-			   "t,o(b)", GP, (int) BFD_RELOC_LO16,
+			   "t,o(b)", GOT_REG, (int) BFD_RELOC_LO16,
 			   mips_frame_reg);
 	    }
 	}
@@ -5050,7 +5085,7 @@
 			   (int) BFD_RELOC_LO16, tempreg);
 	    }
 	}
-      else if (mips_pic == SVR4_PIC && ! mips_big_got)
+      else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
 	{
 	  /* If this is a reference to an external symbol, we want
 	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
@@ -5078,10 +5113,12 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "lw" : "ld"),
-		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
-	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  if (NOP_NEEDED) 
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
 	  p = frag_var (rs_machine_dependent, 4, 0, 
-			RELAX_ENCODE (0, 4, -8, 0, 0, 0),
+			RELAX_ENCODE (0, 4, NOP_NEEDED ? -8 : -4, 
+			0, 0, 0),
 			offset_expr.X_add_symbol, (offsetT) 0,
 			(char *) NULL);
 	  macro_build (p, &icnt, &offset_expr,
@@ -5098,7 +5135,7 @@
 	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
 		       (int) BFD_RELOC_LO16, tempreg);
 	}
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
 	  int gpdel;
 
@@ -5124,7 +5161,7 @@
 	  if (expr1.X_add_number < -0x8000
 	      || expr1.X_add_number >= 0x8000)
 	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
-	  if (reg_needs_delay (GP))
+	  if (reg_needs_delay (GOT_REG))
 	    gpdel = 4;
 	  else
 	    gpdel = 0;
@@ -5135,7 +5172,7 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "addu" : "daddu"),
-		       "d,v,t", tempreg, tempreg, GP);
+		       "d,v,t", tempreg, tempreg, GOT_REG);
 	  macro_build ((char *) NULL, &icnt, &offset_expr,
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
@@ -5154,7 +5191,7 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "lw" : "ld"),
-		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GP);
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	  p += 4;
 	  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
 	  p += 4;
@@ -5283,13 +5320,13 @@
 	  /* FIXME: This won't work for a 64 bit address.  */
 	  macro_build_lui ((char *) NULL, &icnt, &offset_expr, AT);
 	}
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
 	  macro_build ((char *) NULL, &icnt, &offset_expr,
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "lw" : "ld"),
-		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	}
       else if (mips_pic == EMBEDDED_PIC)
 	{
@@ -5378,12 +5415,12 @@
       else
 	{
 	  assert (strcmp (s, RDATA_SECTION_NAME) == 0);
-	  if (mips_pic == SVR4_PIC)
+	  if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	    macro_build ((char *) NULL, &icnt, &offset_expr,
 			 ((bfd_arch_bits_per_address (stdoutput) == 32
 			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 			  ? "lw" : "ld"),
-			 "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
+			 "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	  else
 	    {
 	      /* FIXME: This won't work for a 64 bit address.  */
@@ -5637,7 +5674,7 @@
 		       coproc ? treg : treg + 1,
 		       (int) BFD_RELOC_LO16, AT);
 	}	  
-      else if (mips_pic == SVR4_PIC && ! mips_big_got)
+      else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
 	{
 	  int off;
 
@@ -5669,8 +5706,9 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "lw" : "ld"),
-		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
-	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  if(NOP_NEEDED) 
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
 	  if (breg != 0)
 	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
 			 ((bfd_arch_bits_per_address (stdoutput) == 32
@@ -5694,11 +5732,12 @@
 	  mips_optimize = hold_mips_optimize;
 
 	  (void) frag_var (rs_machine_dependent, 0, 0,
-			   RELAX_ENCODE (0, 0, -16 - off, -8, 1, 0),
+			   RELAX_ENCODE (0, 0, NOP_NEEDED ? (-16 - off) : (-12 - off), 
+			   -8, 1, 0),
 			   offset_expr.X_add_symbol, (offsetT) 0,
 			   (char *) NULL);
 	}
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
 	  int gpdel, off;
 
@@ -5723,7 +5762,7 @@
 	  if (expr1.X_add_number < -0x8000
 	      || expr1.X_add_number >= 0x8000 - 4)
 	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
-	  if (reg_needs_delay (GP))
+	  if (reg_needs_delay (GOT_REG))
 	    gpdel = 4;
 	  else
 	    gpdel = 0;
@@ -5738,7 +5777,7 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "addu" : "daddu"),
-		       "d,v,t", AT, AT, GP);
+		       "d,v,t", AT, AT, GOT_REG);
 	  macro_build ((char *) NULL, &icnt, &offset_expr,
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
@@ -5782,7 +5821,7 @@
 		       ((bfd_arch_bits_per_address (stdoutput) == 32
 			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		        ? "lw" : "ld"),
-		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GP);
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
 	  p += 4;
 	  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
 	  p += 4;
@@ -8869,6 +8908,7 @@
 #define OPTION_XGOT (OPTION_MD_BASE + 19)
 #define OPTION_32 (OPTION_MD_BASE + 20)
 #define OPTION_64 (OPTION_MD_BASE + 21)
+#define OPTION_QNX_PIC (OPTION_MD_BASE + 28)
 #ifdef OBJ_ELF
   {"KPIC", no_argument, NULL, OPTION_CALL_SHARED},
   {"xgot", no_argument, NULL, OPTION_XGOT},
@@ -8876,6 +8916,7 @@
   {"non_shared", no_argument, NULL, OPTION_NON_SHARED},
   {"32", no_argument, NULL, OPTION_32},
   {"64", no_argument, NULL, OPTION_64},
+  {"qnx_pic", no_argument, NULL, OPTION_QNX_PIC},
 #endif
 
 #define OPTION_GP32 (OPTION_MD_BASE + 41)
@@ -9129,6 +9170,21 @@
       g_switch_value = 0;
       break;
 
+    case OPTION_QNX_PIC:
+      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
+	{
+	  as_bad ("-qnx_pic is supported only for ELF format");
+	  return 0;
+	}
+      mips_pic = QNX_PIC;
+      if (g_switch_seen && g_switch_value != 0)
+	{
+	  as_bad ("-G may not be used with QNX PIC code");
+	  return 0;
+	}
+      g_switch_value = 0;
+      break;
+
     case OPTION_NON_SHARED:
       if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
 	{
@@ -9151,7 +9207,7 @@
 	  as_bad (_("-G is not supported for this configuration"));
 	  return 0;
 	}
-      else if (mips_pic == SVR4_PIC || mips_pic == EMBEDDED_PIC)
+      else if (mips_pic == SVR4_PIC || mips_pic == EMBEDDED_PIC || mips_pic == QNX_PIC)
 	{
 	  as_bad (_("-G may not be used with SVR4 or embedded PIC code"));
 	  return 0;
@@ -9546,6 +9602,12 @@
   if (fixP->fx_addsy != NULL && OUTPUT_FLAVOR == bfd_target_elf_flavour)
     {
     if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16 
+
+/* @@@ CHECK ME - CB */
+    ||  ((S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16)
+	|| (mips_pic == QNX_PIC && S_IS_EXTERN(fixP->fx_addsy)
+		&& fixP->fx_r_type == BFD_RELOC_32 && !S_IS_COMMON(fixP->fx_addsy)))
+
         || S_IS_WEAK (fixP->fx_addsy)
         || (symbol_used_in_reloc_p (fixP->fx_addsy)
             && (((bfd_get_section_flags (stdoutput,
@@ -10377,6 +10439,33 @@
   demand_empty_rest_of_line ();
 }
 
+/* This handles the .qnxpiccalls pseudo-op.i */
+
+static void
+s_qnxpiccalls (ignore)
+     int ignore;
+{
+  mips_pic = QNX_PIC;
+  if (USE_GLOBAL_POINTER_OPT)
+    {
+      if (g_switch_seen && g_switch_value != 0)
+	as_warn ("-G may not be used with QNX PIC code");
+      g_switch_value = 0;
+    }
+  bfd_set_gp_size (stdoutput, 0);
+  demand_empty_rest_of_line ();
+}
+
+/* Allows us to turn off PIC code gen, in case that is needed */
+
+static void
+s_noqnxpiccalls (ignore)
+     int ignore;
+{
+  mips_pic = NO_PIC;
+  demand_empty_rest_of_line ();
+}
+
 /* Handle the .cpload pseudo-op.  This is used when generating SVR4
    PIC code.  It sets the $gp register for the function based on the
    function address, which is in the register named in the argument.
@@ -10385,7 +10474,17 @@
 	lui	$gp,%hi(_gp_disp)
 	addiu	$gp,$gp,%lo(_gp_disp)
 	addu	$gp,$gp,.cpload argument
-   The .cpload argument is normally $25 == $t9.  */
+   The .cpload argument is normally $25 == $t9.  
+   In the case of QNX pic code, we always compute the full address
+   of the GOT, therefore we do:
+	bltzal 0, 0f
+	nop
+    0:  lui	$23, %hi(_gp_disp)
+	addiu   $23, $23, %lo(_gp_disp)
+	addu	$23, $23, $31
+    One possible optimization would be to move the opcode
+    right before the bltzal into the nop slot.
+    */
 
 static void
 s_cpload (ignore)
@@ -10395,14 +10494,14 @@
   int icnt = 0;
 
   /* If we are not generating SVR4 PIC code, .cpload is ignored.  */
-  if (mips_pic != SVR4_PIC)
+  if ((mips_pic != SVR4_PIC) && (mips_pic != QNX_PIC))
     {
       s_ignore (0);
       return;
     }
 
   /* .cpload should be a in .set noreorder section.  */
-  if (mips_opts.noreorder == 0)
+  if ((mips_opts.noreorder == 0) && (mips_pic != QNX_PIC))
     as_warn (_(".cpload not in noreorder section"));
 
   ex.X_op = O_symbol;
@@ -10413,13 +10512,64 @@
   /* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
   symbol_get_bfdsym (ex.X_add_symbol)->flags |= BSF_OBJECT;
 
-  macro_build_lui ((char *) NULL, &icnt, &ex, GP);
-  macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j", GP, GP,
-	       (int) BFD_RELOC_LO16);
+  if(mips_pic == SVR4_PIC) {
+  	macro_build_lui ((char *) NULL, &icnt, &ex, GP);
+  	macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j", GP, GP,
+		       (int) BFD_RELOC_LO16);
+
+  	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "addu", "d,v,t",
+		       GP, GP, tc_get_register (0));
+  } else if (mips_pic == QNX_PIC) {
+	expressionS ep;
+	/* In our case, we do a bltzal first to get the current IP, and
+	 * then add the offset to the got... Thus, we always do "cpload $31"
+	 */
+	ep.X_op = O_constant;
+	ep.X_add_number = 4;
+	tc_get_register(0);  // Flush any arg to cpload...
+
+	/* See if we can swap the bltzal with the previous insn and save
+	 * the nop...
+	 * For simplicity, we only check that the insn is a move or sw, 
+	 * which are really the only two we should encounter. 
+	 * If it is anything else, we don't swap for now.
+	 */
+	if(0 && (mips_optimize > 1) 
+		&& prev_insn_valid
+		&& (mips_opts.isa > 1)
+		&& !(mips_opts.noreorder)
+		&& (((prev_insn.insn_opcode & 0xfc1f07ff) == 0x00000021)
+		  || ((prev_insn.insn_opcode & 0xfc000000) == 0xac000000))) 
+	  {
+		  char *prev_prev_f,*prev_f;
+		  char temp[4];
 
-  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "addu", "d,v,t",
-	       GP, GP, tc_get_register (0));
+		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
+		  memcpy (temp, prev_f, 4);
+		  *(unsigned long *)(prev_f) = 0x04100001;
+//		  prev_insn.insn_opcode = 0x04100001;
+ 		  macro_build ((char *) NULL, &icnt, &ep,
+		       "bltzal", "s,p", 0); 
+
+		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
+		  memcpy (prev_f, temp, 4);
+		  mips_opts.noreorder ++;
+	  }
+	else 
+	  {     /* We need a NOP... */
+		mips_opts.noreorder ++;
+ 		macro_build ((char *) NULL, &icnt, &ep,
+		       "bltzal", "s,p", 0);
+		macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+	  }
+  	macro_build_lui ((char *) NULL, &icnt, &ex, 23);
+  	macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j", 23, 23,
+		       (int) BFD_RELOC_LO16);
+	mips_opts.noreorder --; 
 
+  	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "addu", "d,v,t",
+		       23, 23, RA);
+  }
   demand_empty_rest_of_line ();
 }
 
@@ -10452,7 +10602,7 @@
 	       ((bfd_arch_bits_per_address (stdoutput) == 32
 		 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		? "sw" : "sd"),
-	       "t,o(b)", GP, (int) BFD_RELOC_LO16, SP);
+	       "t,o(b)", GOT_REG, (int) BFD_RELOC_LO16, SP);
 
   demand_empty_rest_of_line ();
 }
@@ -10469,7 +10619,7 @@
   char *p;
 
   /* When not generating PIC code, this is treated as .word.  */
-  if (mips_pic != SVR4_PIC)
+  if ((mips_pic != SVR4_PIC) && (mips_pic != QNX_PIC))
     {
       s_cons (2);
       return;
@@ -10508,7 +10658,7 @@
   int reg;
 
   /* This is ignored when not generating SVR4 PIC code.  */
-  if (mips_pic != SVR4_PIC)
+  if ((mips_pic != SVR4_PIC) && (mips_pic != QNX_PIC))
     {
       s_ignore (0);
       return;
@@ -10520,7 +10670,7 @@
 	       ((bfd_arch_bits_per_address (stdoutput) == 32
 		 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
 		? "addu" : "daddu"),
-	       "d,v,t", reg, reg, GP);
+	       "d,v,t", reg, reg, GOT_REG);
 
   demand_empty_rest_of_line ();  
 }
@@ -10995,7 +11145,7 @@
     {
       change = nopic_need_relax (fragp->fr_symbol, 0);
     }
-  else if (mips_pic == SVR4_PIC)
+  else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
     {
       symbolS *sym;
       asection *symsec;
@@ -11021,6 +11171,7 @@
       /* This must duplicate the test in adjust_reloc_syms.  */
       change = (symsec != &bfd_und_section
 		&& symsec != &bfd_abs_section
+		&& ((mips_pic != QNX_PIC) || ((mips_pic == QNX_PIC) && !S_IS_EXTERN(sym)))
 		&& ! bfd_is_com_section (symsec));
     }
   else
@@ -11064,6 +11215,12 @@
     return 0;
   if (fixp->fx_addsy == NULL)
     return 1;
+  if ((mips_pic == QNX_PIC) && 
+	(fixp->fx_r_type == BFD_RELOC_MIPS_GOT16 || fixp->fx_r_type == BFD_RELOC_32)) 
+    {
+      symbolS * sym = fixp->fx_addsy;
+      if (S_IS_EXTERN(sym) || S_IS_WEAK(sym)) return 0;
+    }
 #ifdef OBJ_ELF
   if (OUTPUT_FLAVOR == bfd_target_elf_flavour
       && S_GET_OTHER (fixp->fx_addsy) == STO_MIPS16
@@ -11201,7 +11358,7 @@
 	  assert (fixp->fx_r_type == BFD_RELOC_MIPS_GPREL);
 	  fixp->fx_r_type = BFD_RELOC_HI16_S;
 	}
-      else if (mips_pic == SVR4_PIC)
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
 	{
 	  switch (fixp->fx_r_type)
 	    {
@@ -11531,7 +11688,7 @@
      sort of BFD interface for this.  */
   if (mips_any_noreorder)
     elf_elfheader (stdoutput)->e_flags |= EF_MIPS_NOREORDER;
-  if (mips_pic != NO_PIC)
+  if (mips_pic != NO_PIC && mips_pic != QNX_PIC)
     elf_elfheader (stdoutput)->e_flags |= EF_MIPS_PIC;
 
   /* Set the MIPS ELF ABI flags. */
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/.#tc-mips.c.1.1.1.1 binutils/gas/config/.#tc-mips.c.1.1.1.1
--- binutils-2.10.1/gas/config/.#tc-mips.c.1.1.1.1	1970-01-01 10:00:00.000000000 +1000
+++ binutils/gas/config/.#tc-mips.c.1.1.1.1	2005-09-20 16:45:57.000000000 +1000
@@ -0,0 +1,12112 @@
+/* tc-mips.c -- assemble code for a MIPS chip.
+   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999, 2000 Free Software Foundation, Inc.
+   Contributed by the OSF and Ralph Campbell.
+   Written by Keith Knowles and Ralph Campbell, working independently.
+   Modified for ECOFF and R4000 support by Ian Lance Taylor of Cygnus
+   Support.
+
+   This file is part of GAS.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "as.h"
+#include "config.h"
+#include "subsegs.h"
+
+#include <ctype.h>
+
+#ifdef USE_STDARG
+#include <stdarg.h>
+#endif
+#ifdef USE_VARARGS
+#include <varargs.h>
+#endif
+
+#include "opcode/mips.h"
+#include "itbl-ops.h"
+
+#ifdef DEBUG
+#define DBG(x) printf x
+#else
+#define DBG(x)
+#endif
+
+#ifdef OBJ_MAYBE_ELF
+/* Clean up namespace so we can include obj-elf.h too.  */
+static int mips_output_flavor PARAMS ((void));
+static int mips_output_flavor () { return OUTPUT_FLAVOR; }
+#undef OBJ_PROCESS_STAB
+#undef OUTPUT_FLAVOR
+#undef S_GET_ALIGN
+#undef S_GET_SIZE
+#undef S_SET_ALIGN
+#undef S_SET_SIZE
+#undef obj_frob_file
+#undef obj_frob_file_after_relocs
+#undef obj_frob_symbol
+#undef obj_pop_insert
+#undef obj_sec_sym_ok_for_reloc
+#undef OBJ_COPY_SYMBOL_ATTRIBUTES
+
+#include "obj-elf.h"
+/* Fix any of them that we actually care about.  */
+#undef OUTPUT_FLAVOR
+#define OUTPUT_FLAVOR mips_output_flavor()
+#endif
+
+#if defined (OBJ_ELF)
+#include "elf/mips.h"
+#endif
+
+#ifndef ECOFF_DEBUGGING
+#define NO_ECOFF_DEBUGGING
+#define ECOFF_DEBUGGING 0
+#endif
+
+#include "ecoff.h"
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+static char *mips_regmask_frag;
+#endif
+
+#define AT  1
+#define TREG 24
+#define PIC_CALL_REG 25
+#define KT0 26
+#define KT1 27
+#define GP  28
+#define SP  29
+#define FP  30
+#define RA  31
+
+#define ILLEGAL_REG (32)
+
+/* Allow override of standard little-endian ECOFF format.  */
+
+#ifndef ECOFF_LITTLE_FORMAT
+#define ECOFF_LITTLE_FORMAT "ecoff-littlemips"
+#endif
+
+extern int target_big_endian;
+
+/* 1 is we should use the 64 bit MIPS ELF ABI, 0 if we should use the
+   32 bit ABI.  This has no meaning for ECOFF.
+   Note that the default is always 32 bit, even if "configured" for
+   64 bit [e.g. --target=mips64-elf].  */
+static int mips_64;
+
+/* The default target format to use.  */
+const char *
+mips_target_format ()
+{
+  switch (OUTPUT_FLAVOR)
+    {
+    case bfd_target_aout_flavour:
+      return target_big_endian ? "a.out-mips-big" : "a.out-mips-little";
+    case bfd_target_ecoff_flavour:
+      return target_big_endian ? "ecoff-bigmips" : ECOFF_LITTLE_FORMAT;
+    case bfd_target_coff_flavour:
+      return "pe-mips";
+    case bfd_target_elf_flavour:
+      return (target_big_endian
+	      ? (mips_64 ? "elf64-bigmips" : "elf32-bigmips")
+	      : (mips_64 ? "elf64-littlemips" : "elf32-littlemips"));
+    default:
+      abort ();
+      return NULL;
+    }
+}
+
+/* The name of the readonly data section.  */
+#define RDATA_SECTION_NAME (OUTPUT_FLAVOR == bfd_target_aout_flavour \
+			    ? ".data" \
+			    : OUTPUT_FLAVOR == bfd_target_ecoff_flavour \
+			    ? ".rdata" \
+			    : OUTPUT_FLAVOR == bfd_target_coff_flavour \
+			    ? ".rdata" \
+			    : OUTPUT_FLAVOR == bfd_target_elf_flavour \
+			    ? ".rodata" \
+			    : (abort (), ""))
+
+/* This is the set of options which may be modified by the .set
+   pseudo-op.  We use a struct so that .set push and .set pop are more
+   reliable.  */
+
+struct mips_set_options
+{
+  /* MIPS ISA (Instruction Set Architecture) level.  This is set to -1
+     if it has not been initialized.  Changed by `.set mipsN', and the
+     -mipsN command line option, and the default CPU.  */
+  int isa;
+  /* Whether we are assembling for the mips16 processor.  0 if we are
+     not, 1 if we are, and -1 if the value has not been initialized.
+     Changed by `.set mips16' and `.set nomips16', and the -mips16 and
+     -nomips16 command line options, and the default CPU.  */
+  int mips16;
+  /* Non-zero if we should not reorder instructions.  Changed by `.set
+     reorder' and `.set noreorder'.  */
+  int noreorder;
+  /* Non-zero if we should not permit the $at ($1) register to be used
+     in instructions.  Changed by `.set at' and `.set noat'.  */
+  int noat;
+  /* Non-zero if we should warn when a macro instruction expands into
+     more than one machine instruction.  Changed by `.set nomacro' and
+     `.set macro'.  */
+  int warn_about_macros;
+  /* Non-zero if we should not move instructions.  Changed by `.set
+     move', `.set volatile', `.set nomove', and `.set novolatile'.  */
+  int nomove;
+  /* Non-zero if we should not optimize branches by moving the target
+     of the branch into the delay slot.  Actually, we don't perform
+     this optimization anyhow.  Changed by `.set bopt' and `.set
+     nobopt'.  */
+  int nobopt;
+  /* Non-zero if we should not autoextend mips16 instructions.
+     Changed by `.set autoextend' and `.set noautoextend'.  */
+  int noautoextend;
+};
+
+/* This is the struct we use to hold the current set of options.  Note
+   that we must set the isa and mips16 fields to -1 to indicate that
+   they have not been initialized.  */
+
+static struct mips_set_options mips_opts = { -1, -1 };
+
+/* These variables are filled in with the masks of registers used.
+   The object format code reads them and puts them in the appropriate
+   place.  */
+unsigned long mips_gprmask;
+unsigned long mips_cprmask[4];
+
+/* MIPS ISA we are using for this output file.  */
+static int file_mips_isa;
+
+/* The CPU type as a number: 2000, 3000, 4000, 4400, etc.  */
+static int mips_cpu = -1;
+
+/* The argument of the -mabi= flag. */
+static char* mips_abi_string = 0;
+
+/* Wether we should mark the file EABI64 or EABI32. */
+static int mips_eabi64 = 0;
+
+/* If they asked for mips1 or mips2 and a cpu that is
+   mips3 or greater, then mark the object file 32BITMODE. */
+static int mips_32bitmode = 0;
+
+/* True if -mgp32 was passed. */
+static int mips_gp32 = 0;
+
+/* Some ISA's have delay slots for instructions which read or write
+   from a coprocessor (eg. mips1-mips3); some don't (eg mips4).
+   Return true if instructions marked INSN_LOAD_COPROC_DELAY, 
+   INSN_COPROC_MOVE_DELAY, or INSN_WRITE_COND_CODE actually have a
+   delay slot in this ISA.  The uses of this macro assume that any
+   ISA that has delay slots for one of these, has them for all.  They
+   also assume that ISAs which don't have delays for these insns, don't
+   have delays for the INSN_LOAD_MEMORY_DELAY instructions either. */
+#define ISA_HAS_COPROC_DELAYS(ISA) (        \
+   (ISA) == 1                               \
+   || (ISA) == 2                            \
+   || (ISA) == 3                            \
+   )
+
+/*  Return true if ISA supports 64 bit gp register instructions. */
+#define ISA_HAS_64BIT_REGS(ISA) (    \
+   (ISA) == 3                        \
+   || (ISA) == 4                     \
+   )
+
+/* Whether the processor uses hardware interlocks to protect 
+   reads from the HI and LO registers, and thus does not
+   require nops to be inserted.
+
+   FIXME: GCC makes a distinction between -mcpu=FOO and -mFOO:
+   -mcpu=FOO schedules for FOO, but still produces code that meets the
+   requirements of MIPS ISA I.  For example, it won't generate any
+   FOO-specific instructions, and it will still assume that any
+   scheduling hazards described in MIPS ISA I are there, even if FOO
+   has interlocks.  -mFOO gives GCC permission to generate code that
+   will only run on a FOO; it will generate FOO-specific instructions,
+   and assume interlocks provided by a FOO.
+
+   However, GAS currently doesn't make this distinction; before Jan 28
+   1999, GAS's -mcpu=FOO implied -mFOO, which violates GCC's
+   assumptions.  The GCC driver passes these flags through to GAS, so
+   if GAS actually does anything that doesn't meet MIPS ISA I with
+   -mFOO, then GCC's -mcpu=FOO flag isn't going to work.
+
+   And furthermore, it did not assume that -mFOO implied -mcpu=FOO,
+   which seems senseless --- why generate code which will only run on
+   a FOO, but schedule for something else?
+
+   So now, at least, -mcpu=FOO and -mFOO are exactly equivalent.
+
+   -- Jim Blandy <jimb@cygnus.com> */
+
+#define hilo_interlocks (mips_cpu == 4010                           \
+                         )
+
+/* Whether the processor uses hardware interlocks to protect reads
+   from the GPRs, and thus does not require nops to be inserted.  */
+#define gpr_interlocks \
+  (mips_opts.isa != 1  \
+   || mips_cpu == 3900)
+
+/* As with other "interlocks" this is used by hardware that has FP
+   (co-processor) interlocks.  */
+/* Itbl support may require additional care here. */
+#define cop_interlocks (mips_cpu == 4300                            \
+			)
+
+/* Is this a mfhi or mflo instruction?  */
+#define MF_HILO_INSN(PINFO) \
+          ((PINFO & INSN_READ_HI) || (PINFO & INSN_READ_LO))
+
+/* MIPS PIC level.  */
+
+enum mips_pic_level
+{
+  /* Do not generate PIC code.  */
+  NO_PIC,
+
+  /* Generate PIC code as in Irix 4.  This is not implemented, and I'm
+     not sure what it is supposed to do.  */
+  IRIX4_PIC,
+
+  /* Generate PIC code as in the SVR4 MIPS ABI.  */
+  SVR4_PIC,
+
+  /* Generate PIC code without using a global offset table: the data
+     segment has a maximum size of 64K, all data references are off
+     the $gp register, and all text references are PC relative.  This
+     is used on some embedded systems.  */
+  EMBEDDED_PIC,
+  /* Generate QNX PIC code for use on the MIPS, similar to the SVR4
+     code but the regular GP register is not used. Instead, we do all
+     references to the GOT through $23, and calculate our own adress in
+     every function. */
+  QNX_PIC
+};
+/* Macro to define the GOT pointer register */
+#define GOT_REG ((mips_pic == SVR4_PIC) ? GP : 23)
+
+/* Macro to get rid of some of the nops.. */
+#define NOP_NEEDED ((mips_pic != QNX_PIC) || (mips_opts.isa < 2))
+
+static enum mips_pic_level mips_pic;
+
+/* 1 if we should generate 32 bit offsets from the GP register in
+   SVR4_PIC mode.  Currently has no meaning in other modes.  */
+static int mips_big_got;
+
+/* 1 if trap instructions should used for overflow rather than break
+   instructions.  */
+static int mips_trap;
+
+/* Non-zero if any .set noreorder directives were used.  */
+
+static int mips_any_noreorder;
+
+/* Non-zero if nops should be inserted when the register referenced in
+   an mfhi/mflo instruction is read in the next two instructions.  */
+static int mips_7000_hilo_fix;
+
+/* The size of the small data section.  */
+static int g_switch_value = 8;
+/* Whether the -G option was used.  */
+static int g_switch_seen = 0;
+
+#define N_RMASK 0xc4
+#define N_VFP   0xd4
+
+/* If we can determine in advance that GP optimization won't be
+   possible, we can skip the relaxation stuff that tries to produce
+   GP-relative references.  This makes delay slot optimization work
+   better.
+
+   This function can only provide a guess, but it seems to work for
+   gcc output.  It needs to guess right for gcc, otherwise gcc
+   will put what it thinks is a GP-relative instruction in a branch
+   delay slot.
+
+   I don't know if a fix is needed for the SVR4_PIC mode.  I've only
+   fixed it for the non-PIC mode.  KR 95/04/07  */
+static int nopic_need_relax PARAMS ((symbolS *, int));
+
+/* handle of the OPCODE hash table */
+static struct hash_control *op_hash = NULL;
+
+/* The opcode hash table we use for the mips16.  */
+static struct hash_control *mips16_op_hash = NULL;
+
+/* This array holds the chars that always start a comment.  If the
+    pre-processor is disabled, these aren't very useful */
+const char comment_chars[] = "#";
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output */
+/* Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+   #NO_APP at the beginning of its output. */
+/* Also note that C style comments are always supported.  */
+const char line_comment_chars[] = "#";
+
+/* This array holds machine specific line separator characters. */
+const char line_separator_chars[] = "";
+
+/* Chars that can be used to separate mant from exp in floating point nums */
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant */
+/* As in 0f12.456 */
+/* or    0d1.2345e12 */
+const char FLT_CHARS[] = "rRsSfFdDxXpP";
+
+/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be
+   changed in read.c .  Ideally it shouldn't have to know about it at all,
+   but nothing is ideal around here.
+ */
+
+static char *insn_error;
+
+static int auto_align = 1;
+
+/* When outputting SVR4 PIC code, the assembler needs to know the
+   offset in the stack frame from which to restore the $gp register.
+   This is set by the .cprestore pseudo-op, and saved in this
+   variable.  */
+static offsetT mips_cprestore_offset = -1;
+
+/* This is the register which holds the stack frame, as set by the
+   .frame pseudo-op.  This is needed to implement .cprestore.  */
+static int mips_frame_reg = SP;
+
+/* To output NOP instructions correctly, we need to keep information
+   about the previous two instructions.  */
+
+/* Whether we are optimizing.  The default value of 2 means to remove
+   unneeded NOPs and swap branch instructions when possible.  A value
+   of 1 means to not swap branches.  A value of 0 means to always
+   insert NOPs.  */
+static int mips_optimize = 2;
+
+/* Debugging level.  -g sets this to 2.  -gN sets this to N.  -g0 is
+   equivalent to seeing no -g option at all.  */
+static int mips_debug = 0;
+
+/* The previous instruction.  */
+static struct mips_cl_insn prev_insn;
+
+/* The instruction before prev_insn.  */
+static struct mips_cl_insn prev_prev_insn;
+
+/* If we don't want information for prev_insn or prev_prev_insn, we
+   point the insn_mo field at this dummy integer.  */
+static const struct mips_opcode dummy_opcode = { 0 };
+
+/* Non-zero if prev_insn is valid.  */
+static int prev_insn_valid;
+
+/* The frag for the previous instruction.  */
+static struct frag *prev_insn_frag;
+
+/* The offset into prev_insn_frag for the previous instruction.  */
+static long prev_insn_where;
+
+/* The reloc type for the previous instruction, if any.  */
+static bfd_reloc_code_real_type prev_insn_reloc_type;
+
+/* The reloc for the previous instruction, if any.  */
+static fixS *prev_insn_fixp;
+
+/* Non-zero if the previous instruction was in a delay slot.  */
+static int prev_insn_is_delay_slot;
+
+/* Non-zero if the previous instruction was in a .set noreorder.  */
+static int prev_insn_unreordered;
+
+/* Non-zero if the previous instruction uses an extend opcode (if
+   mips16).  */
+static int prev_insn_extended;
+
+/* Non-zero if the previous previous instruction was in a .set
+   noreorder.  */
+static int prev_prev_insn_unreordered;
+
+/* If this is set, it points to a frag holding nop instructions which
+   were inserted before the start of a noreorder section.  If those
+   nops turn out to be unnecessary, the size of the frag can be
+   decreased.  */
+static fragS *prev_nop_frag;
+
+/* The number of nop instructions we created in prev_nop_frag.  */
+static int prev_nop_frag_holds;
+
+/* The number of nop instructions that we know we need in
+   prev_nop_frag. */
+static int prev_nop_frag_required;
+
+/* The number of instructions we've seen since prev_nop_frag.  */
+static int prev_nop_frag_since;
+
+/* For ECOFF and ELF, relocations against symbols are done in two
+   parts, with a HI relocation and a LO relocation.  Each relocation
+   has only 16 bits of space to store an addend.  This means that in
+   order for the linker to handle carries correctly, it must be able
+   to locate both the HI and the LO relocation.  This means that the
+   relocations must appear in order in the relocation table.
+
+   In order to implement this, we keep track of each unmatched HI
+   relocation.  We then sort them so that they immediately precede the
+   corresponding LO relocation. */
+
+struct mips_hi_fixup
+{
+  /* Next HI fixup.  */
+  struct mips_hi_fixup *next;
+  /* This fixup.  */
+  fixS *fixp;
+  /* The section this fixup is in.  */
+  segT seg;
+};
+
+/* The list of unmatched HI relocs.  */
+
+static struct mips_hi_fixup *mips_hi_fixup_list;
+
+/* Map normal MIPS register numbers to mips16 register numbers.  */
+
+#define X ILLEGAL_REG
+static const int mips32_to_16_reg_map[] =
+{
+  X, X, 2, 3, 4, 5, 6, 7,
+  X, X, X, X, X, X, X, X,
+  0, 1, X, X, X, X, X, X,
+  X, X, X, X, X, X, X, X
+};
+#undef X
+
+/* Map mips16 register numbers to normal MIPS register numbers.  */
+
+static const int mips16_to_32_reg_map[] =
+{
+  16, 17, 2, 3, 4, 5, 6, 7
+};
+
+/* Since the MIPS does not have multiple forms of PC relative
+   instructions, we do not have to do relaxing as is done on other
+   platforms.  However, we do have to handle GP relative addressing
+   correctly, which turns out to be a similar problem.
+
+   Every macro that refers to a symbol can occur in (at least) two
+   forms, one with GP relative addressing and one without.  For
+   example, loading a global variable into a register generally uses
+   a macro instruction like this:
+     lw $4,i
+   If i can be addressed off the GP register (this is true if it is in
+   the .sbss or .sdata section, or if it is known to be smaller than
+   the -G argument) this will generate the following instruction:
+     lw $4,i($gp)
+   This instruction will use a GPREL reloc.  If i can not be addressed
+   off the GP register, the following instruction sequence will be used:
+     lui $at,i
+     lw $4,i($at)
+   In this case the first instruction will have a HI16 reloc, and the
+   second reloc will have a LO16 reloc.  Both relocs will be against
+   the symbol i.
+
+   The issue here is that we may not know whether i is GP addressable
+   until after we see the instruction that uses it.  Therefore, we
+   want to be able to choose the final instruction sequence only at
+   the end of the assembly.  This is similar to the way other
+   platforms choose the size of a PC relative instruction only at the
+   end of assembly.
+
+   When generating position independent code we do not use GP
+   addressing in quite the same way, but the issue still arises as
+   external symbols and local symbols must be handled differently.
+
+   We handle these issues by actually generating both possible
+   instruction sequences.  The longer one is put in a frag_var with
+   type rs_machine_dependent.  We encode what to do with the frag in
+   the subtype field.  We encode (1) the number of existing bytes to
+   replace, (2) the number of new bytes to use, (3) the offset from
+   the start of the existing bytes to the first reloc we must generate
+   (that is, the offset is applied from the start of the existing
+   bytes after they are replaced by the new bytes, if any), (4) the
+   offset from the start of the existing bytes to the second reloc,
+   (5) whether a third reloc is needed (the third reloc is always four
+   bytes after the second reloc), and (6) whether to warn if this
+   variant is used (this is sometimes needed if .set nomacro or .set
+   noat is in effect).  All these numbers are reasonably small.
+
+   Generating two instruction sequences must be handled carefully to
+   ensure that delay slots are handled correctly.  Fortunately, there
+   are a limited number of cases.  When the second instruction
+   sequence is generated, append_insn is directed to maintain the
+   existing delay slot information, so it continues to apply to any
+   code after the second instruction sequence.  This means that the
+   second instruction sequence must not impose any requirements not
+   required by the first instruction sequence.
+
+   These variant frags are then handled in functions called by the
+   machine independent code.  md_estimate_size_before_relax returns
+   the final size of the frag.  md_convert_frag sets up the final form
+   of the frag.  tc_gen_reloc adjust the first reloc and adds a second
+   one if needed.  */
+#define RELAX_ENCODE(old, new, reloc1, reloc2, reloc3, warn) \
+  ((relax_substateT) \
+   (((old) << 23) \
+    | ((new) << 16) \
+    | (((reloc1) + 64) << 9) \
+    | (((reloc2) + 64) << 2) \
+    | ((reloc3) ? (1 << 1) : 0) \
+    | ((warn) ? 1 : 0)))
+#define RELAX_OLD(i) (((i) >> 23) & 0x7f)
+#define RELAX_NEW(i) (((i) >> 16) & 0x7f)
+#define RELAX_RELOC1(i) ((bfd_vma)(((i) >> 9) & 0x7f) - 64)
+#define RELAX_RELOC2(i) ((bfd_vma)(((i) >> 2) & 0x7f) - 64)
+#define RELAX_RELOC3(i) (((i) >> 1) & 1)
+#define RELAX_WARN(i) ((i) & 1)
+
+/* For mips16 code, we use an entirely different form of relaxation.
+   mips16 supports two versions of most instructions which take
+   immediate values: a small one which takes some small value, and a
+   larger one which takes a 16 bit value.  Since branches also follow
+   this pattern, relaxing these values is required.
+
+   We can assemble both mips16 and normal MIPS code in a single
+   object.  Therefore, we need to support this type of relaxation at
+   the same time that we support the relaxation described above.  We
+   use the high bit of the subtype field to distinguish these cases.
+
+   The information we store for this type of relaxation is the
+   argument code found in the opcode file for this relocation, whether
+   the user explicitly requested a small or extended form, and whether
+   the relocation is in a jump or jal delay slot.  That tells us the
+   size of the value, and how it should be stored.  We also store
+   whether the fragment is considered to be extended or not.  We also
+   store whether this is known to be a branch to a different section,
+   whether we have tried to relax this frag yet, and whether we have
+   ever extended a PC relative fragment because of a shift count.  */
+#define RELAX_MIPS16_ENCODE(type, small, ext, dslot, jal_dslot)	\
+  (0x80000000							\
+   | ((type) & 0xff)						\
+   | ((small) ? 0x100 : 0)					\
+   | ((ext) ? 0x200 : 0)					\
+   | ((dslot) ? 0x400 : 0)					\
+   | ((jal_dslot) ? 0x800 : 0))
+#define RELAX_MIPS16_P(i) (((i) & 0x80000000) != 0)
+#define RELAX_MIPS16_TYPE(i) ((i) & 0xff)
+#define RELAX_MIPS16_USER_SMALL(i) (((i) & 0x100) != 0)
+#define RELAX_MIPS16_USER_EXT(i) (((i) & 0x200) != 0)
+#define RELAX_MIPS16_DSLOT(i) (((i) & 0x400) != 0)
+#define RELAX_MIPS16_JAL_DSLOT(i) (((i) & 0x800) != 0)
+#define RELAX_MIPS16_EXTENDED(i) (((i) & 0x1000) != 0)
+#define RELAX_MIPS16_MARK_EXTENDED(i) ((i) | 0x1000)
+#define RELAX_MIPS16_CLEAR_EXTENDED(i) ((i) &~ 0x1000)
+#define RELAX_MIPS16_LONG_BRANCH(i) (((i) & 0x2000) != 0)
+#define RELAX_MIPS16_MARK_LONG_BRANCH(i) ((i) | 0x2000)
+#define RELAX_MIPS16_CLEAR_LONG_BRANCH(i) ((i) &~ 0x2000)
+
+/* Prototypes for static functions.  */
+
+#ifdef __STDC__
+#define internalError() \
+    as_fatal (_("internal Error, line %d, %s"), __LINE__, __FILE__)
+#else
+#define internalError() as_fatal (_("MIPS internal Error"));
+#endif
+
+enum mips_regclass { MIPS_GR_REG, MIPS_FP_REG, MIPS16_REG };
+
+static int insn_uses_reg PARAMS ((struct mips_cl_insn *ip,
+				  unsigned int reg, enum mips_regclass class));
+static int reg_needs_delay PARAMS ((int));
+static void mips16_mark_labels PARAMS ((void));
+static void append_insn PARAMS ((char *place,
+				 struct mips_cl_insn * ip,
+				 expressionS * p,
+				 bfd_reloc_code_real_type r,
+				 boolean));
+static void mips_no_prev_insn PARAMS ((int));
+static void mips_emit_delays PARAMS ((boolean));
+#ifdef USE_STDARG
+static void macro_build PARAMS ((char *place, int *counter, expressionS * ep,
+				 const char *name, const char *fmt,
+				 ...));
+#else
+static void macro_build ();
+#endif
+static void mips16_macro_build PARAMS ((char *, int *, expressionS *,
+					const char *, const char *,
+					va_list));
+static void macro_build_lui PARAMS ((char *place, int *counter,
+				     expressionS * ep, int regnum));
+static void set_at PARAMS ((int *counter, int reg, int unsignedp));
+static void check_absolute_expr PARAMS ((struct mips_cl_insn * ip,
+					 expressionS *));
+static void load_register PARAMS ((int *, int, expressionS *, int));
+static void load_address PARAMS ((int *counter, int reg, expressionS *ep));
+static void macro PARAMS ((struct mips_cl_insn * ip));
+static void mips16_macro PARAMS ((struct mips_cl_insn * ip));
+#ifdef LOSING_COMPILER
+static void macro2 PARAMS ((struct mips_cl_insn * ip));
+#endif
+static void mips_ip PARAMS ((char *str, struct mips_cl_insn * ip));
+static void mips16_ip PARAMS ((char *str, struct mips_cl_insn * ip));
+static void mips16_immed PARAMS ((char *, unsigned int, int, offsetT, boolean,
+				  boolean, boolean, unsigned long *,
+				  boolean *, unsigned short *));
+static int my_getSmallExpression PARAMS ((expressionS * ep, char *str));
+static void my_getExpression PARAMS ((expressionS * ep, char *str));
+static symbolS *get_symbol PARAMS ((void));
+static void mips_align PARAMS ((int to, int fill, symbolS *label));
+static void s_align PARAMS ((int));
+static void s_change_sec PARAMS ((int));
+static void s_cons PARAMS ((int));
+static void s_float_cons PARAMS ((int));
+static void s_mips_globl PARAMS ((int));
+static void s_option PARAMS ((int));
+static void s_mipsset PARAMS ((int));
+static void s_abicalls PARAMS ((int));
+static void s_qnxpiccalls PARAMS ((int));
+static void s_noqnxpiccalls PARAMS ((int));
+static void s_cpload PARAMS ((int));
+static void s_cprestore PARAMS ((int));
+static void s_gpword PARAMS ((int));
+static void s_cpadd PARAMS ((int));
+static void s_insn PARAMS ((int));
+static void md_obj_begin PARAMS ((void));
+static void md_obj_end PARAMS ((void));
+static long get_number PARAMS ((void));
+static void s_mips_ent PARAMS ((int));
+static void s_mips_end PARAMS ((int));
+static void s_mips_frame PARAMS ((int));
+static void s_mips_mask PARAMS ((int));
+static void s_mips_stab PARAMS ((int));
+static void s_mips_weakext PARAMS ((int));
+static void s_file PARAMS ((int));
+static int mips16_extended_frag PARAMS ((fragS *, asection *, long));
+
+
+static int validate_mips_insn PARAMS ((const struct mips_opcode *));
+
+/* Pseudo-op table.
+
+   The following pseudo-ops from the Kane and Heinrich MIPS book
+   should be defined here, but are currently unsupported: .alias,
+   .galive, .gjaldef, .gjrlive, .livereg, .noalias.
+
+   The following pseudo-ops from the Kane and Heinrich MIPS book are
+   specific to the type of debugging information being generated, and
+   should be defined by the object format: .aent, .begin, .bend,
+   .bgnb, .end, .endb, .ent, .fmask, .frame, .loc, .mask, .verstamp,
+   .vreg.
+
+   The following pseudo-ops from the Kane and Heinrich MIPS book are
+   not MIPS CPU specific, but are also not specific to the object file
+   format.  This file is probably the best place to define them, but
+   they are not currently supported: .asm0, .endr, .lab, .repeat,
+   .struct.  */
+
+static const pseudo_typeS mips_pseudo_table[] =
+{
+ /* MIPS specific pseudo-ops.  */
+  {"option", s_option, 0},
+  {"set", s_mipsset, 0},
+  {"rdata", s_change_sec, 'r'},
+  {"sdata", s_change_sec, 's'},
+  {"livereg", s_ignore, 0},
+  {"abicalls", s_abicalls, 0},
+  {"qnxpiccalls", s_qnxpiccalls, 0},
+  {"noqnxpiccalls", s_noqnxpiccalls, 0},
+  {"cpload", s_cpload, 0},
+  {"cprestore", s_cprestore, 0},
+  {"gpword", s_gpword, 0},
+  {"cpadd", s_cpadd, 0},
+  {"insn", s_insn, 0},
+
+ /* Relatively generic pseudo-ops that happen to be used on MIPS
+     chips.  */
+  {"asciiz", stringer, 1},
+  {"bss", s_change_sec, 'b'},
+  {"err", s_err, 0},
+  {"half", s_cons, 1},
+  {"dword", s_cons, 3},
+  {"weakext", s_mips_weakext, 0},
+
+ /* These pseudo-ops are defined in read.c, but must be overridden
+     here for one reason or another.  */
+  {"align", s_align, 0},
+  {"byte", s_cons, 0},
+  {"data", s_change_sec, 'd'},
+  {"double", s_float_cons, 'd'},
+  {"float", s_float_cons, 'f'},
+  {"globl", s_mips_globl, 0},
+  {"global", s_mips_globl, 0},
+  {"hword", s_cons, 1},
+  {"int", s_cons, 2},
+  {"long", s_cons, 2},
+  {"octa", s_cons, 4},
+  {"quad", s_cons, 3},
+  {"short", s_cons, 1},
+  {"single", s_float_cons, 'f'},
+  {"stabn", s_mips_stab, 'n'},
+  {"text", s_change_sec, 't'},
+  {"word", s_cons, 2},
+  { 0 },
+};
+
+static const pseudo_typeS mips_nonecoff_pseudo_table[] = {
+ /* These pseudo-ops should be defined by the object file format.
+    However, a.out doesn't support them, so we have versions here.  */
+  {"aent", s_mips_ent, 1},
+  {"bgnb", s_ignore, 0},
+  {"end", s_mips_end, 0},
+  {"endb", s_ignore, 0},
+  {"ent", s_mips_ent, 0},
+  {"file", s_file, 0},
+  {"fmask", s_mips_mask, 'F'},
+  {"frame", s_mips_frame, 0},
+  {"loc", s_ignore, 0},
+  {"mask", s_mips_mask, 'R'},
+  {"verstamp", s_ignore, 0},
+  { 0 },
+};
+
+extern void pop_insert PARAMS ((const pseudo_typeS *));
+
+void
+mips_pop_insert ()
+{
+  pop_insert (mips_pseudo_table);
+  if (! ECOFF_DEBUGGING)
+    pop_insert (mips_nonecoff_pseudo_table);
+}
+
+/* Symbols labelling the current insn.  */
+
+struct insn_label_list
+{
+  struct insn_label_list *next;
+  symbolS *label;
+};
+
+static struct insn_label_list *insn_labels;
+static struct insn_label_list *free_insn_labels;
+
+static void mips_clear_insn_labels PARAMS ((void));
+
+static inline void
+mips_clear_insn_labels ()
+{
+  register struct insn_label_list **pl;
+
+  for (pl = &free_insn_labels; *pl != NULL; pl = &(*pl)->next)
+    ;
+  *pl = insn_labels;
+  insn_labels = NULL;
+}
+
+static char *expr_end;
+
+/* Expressions which appear in instructions.  These are set by
+   mips_ip.  */
+
+static expressionS imm_expr;
+static expressionS offset_expr;
+
+/* Relocs associated with imm_expr and offset_expr.  */
+
+static bfd_reloc_code_real_type imm_reloc;
+static bfd_reloc_code_real_type offset_reloc;
+
+/* This is set by mips_ip if imm_reloc is an unmatched HI16_S reloc.  */
+
+static boolean imm_unmatched_hi;
+
+/* These are set by mips16_ip if an explicit extension is used.  */
+
+static boolean mips16_small, mips16_ext;
+
+#ifdef MIPS_STABS_ELF
+/* The pdr segment for per procedure frame/regmask info */
+
+static segT pdr_seg;
+#endif
+
+/*
+ * This function is called once, at assembler startup time.  It should
+ * set up all the tables, etc. that the MD part of the assembler will need.
+ */
+void
+md_begin ()
+{
+  boolean ok = false;
+  register const char *retval = NULL;
+  register unsigned int i = 0;
+  const char *cpu;
+  char *a = NULL;
+  int broken = 0, explicit_isa = 0;
+  int mips_isa_from_cpu;
+
+  /* GP relative stuff not working for PE */
+  if (strncmp (TARGET_OS, "pe", 2) == 0
+      && g_switch_value != 0)
+    {
+      if (g_switch_seen)
+	as_bad (_("-G not supported in this configuration."));
+      g_switch_value = 0;
+    }
+
+  cpu = TARGET_CPU;
+  if (strcmp (cpu + (sizeof TARGET_CPU) - 3, "el") == 0)
+    {
+      a = xmalloc (sizeof TARGET_CPU);
+      strcpy (a, TARGET_CPU);
+      a[(sizeof TARGET_CPU) - 3] = '\0';
+      cpu = a;
+    }
+
+  if (mips_cpu < 0)
+    {
+      /* Set mips_cpu based on TARGET_CPU, unless TARGET_CPU is
+         just the generic 'mips', in which case set mips_cpu based
+         on the given ISA, if any. */
+
+      if (strcmp (cpu, "mips") == 0)
+        {
+	  if (mips_opts.isa < 0)
+	    mips_cpu = 3000;   
+
+	  else if (mips_opts.isa == 2)
+            mips_cpu = 6000;
+
+          else if (mips_opts.isa == 3)
+            mips_cpu = 4000;
+
+          else if (mips_opts.isa == 4)
+            mips_cpu = 8000;
+
+          else 
+            mips_cpu = 3000;
+        }
+      
+      else if (strcmp (cpu, "r3900") == 0
+               || strcmp (cpu, "mipstx39") == 0
+               )
+        mips_cpu = 3900;
+
+      else if (strcmp (cpu, "r6000") == 0
+	       || strcmp (cpu, "mips2") == 0)
+        mips_cpu = 6000;
+
+      else if (strcmp (cpu, "mips64") == 0
+	       || strcmp (cpu, "r4000") == 0
+	       || strcmp (cpu, "mips3") == 0)
+        mips_cpu = 4000;
+
+      else if (strcmp (cpu, "r4400") == 0)
+        mips_cpu = 4400;
+
+      else if (strcmp (cpu, "mips64orion") == 0
+	       || strcmp (cpu, "r4600") == 0)
+        mips_cpu = 4600;
+
+      else if (strcmp (cpu, "r4650") == 0)
+        mips_cpu = 4650;
+
+      else if (strcmp (cpu, "mips64vr4300") == 0)
+        mips_cpu = 4300;
+
+      else if (strcmp (cpu, "mips64vr4111") == 0)
+        mips_cpu = 4111;
+
+      else if (strcmp (cpu, "mips64vr4100") == 0)
+        mips_cpu = 4100;
+
+      else if (strcmp (cpu, "r4010") == 0)
+        mips_cpu = 4010;
+
+
+      else if (strcmp (cpu, "r5000") == 0
+	       || strcmp (cpu, "mips64vr5000") == 0)
+        mips_cpu = 5000;
+
+
+
+      else if (strcmp (cpu, "r8000") == 0
+	       || strcmp (cpu, "mips4") == 0)
+        mips_cpu = 8000;
+      
+      else if (strcmp (cpu, "r10000") == 0)
+        mips_cpu = 10000;
+
+      else if (strcmp (cpu, "mips16") == 0)
+        mips_cpu = 0; /* FIXME */
+
+      else
+        mips_cpu = 3000;
+    }
+
+  if (mips_cpu == 3000
+      || mips_cpu == 3900)
+    mips_isa_from_cpu = 1;
+
+  else if (mips_cpu == 6000
+	   || mips_cpu == 4010)
+    mips_isa_from_cpu = 2;
+
+  else if (mips_cpu == 4000
+	   || mips_cpu == 4100
+	   || mips_cpu == 4111
+	   || mips_cpu == 4400
+	   || mips_cpu == 4300
+	   || mips_cpu == 4600
+	   || mips_cpu == 4650)
+    mips_isa_from_cpu = 3;
+
+  else if (mips_cpu == 5000
+	   || mips_cpu == 8000
+               || mips_cpu == 10000)
+    mips_isa_from_cpu = 4;
+
+  else
+    mips_isa_from_cpu = -1;
+
+  if (mips_opts.isa == -1)
+    {
+      if (mips_isa_from_cpu != -1)
+	mips_opts.isa = mips_isa_from_cpu;
+      else
+	mips_opts.isa = 1;
+    }
+    else
+    	explicit_isa = 1;
+
+  if (mips_opts.mips16 < 0)
+    {
+      if (strncmp (TARGET_CPU, "mips16", sizeof "mips16" - 1) == 0)
+	mips_opts.mips16 = 1;
+      else
+	mips_opts.mips16 = 0;
+    }
+
+  /* End of TARGET_CPU processing, get rid of malloced memory
+     if necessary. */
+  cpu = NULL;
+  if (a != NULL)
+    {
+    free (a);
+    a = NULL;
+    }
+
+  if (mips_opts.isa == 1 && mips_trap)
+    as_bad (_("trap exception not supported at ISA 1"));
+
+  /* Set the EABI kind based on the ISA before the user gets
+     to change the ISA with directives.  This isn't really
+     the best, but then neither is basing the abi on the isa. */     
+  if (ISA_HAS_64BIT_REGS (mips_opts.isa)
+      && mips_abi_string
+      && 0 == strcmp (mips_abi_string,"eabi"))
+    mips_eabi64 = 1;
+
+  if (mips_cpu != 0 && mips_cpu != -1 && !(explicit_isa) )
+    {
+      ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, mips_cpu);
+      
+      /* If they asked for mips1 or mips2 and a cpu that is
+	 mips3 or greater, then mark the object file 32BITMODE. */
+      if (mips_isa_from_cpu != -1
+	  && ! ISA_HAS_64BIT_REGS (mips_opts.isa) 
+	  && ISA_HAS_64BIT_REGS (mips_isa_from_cpu))
+	mips_32bitmode = 1;
+    }
+  else
+    {
+      switch (mips_opts.isa)
+	{
+	case 1:
+	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 3000);
+	  break;
+	case 2:
+	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 6000);
+	  break;
+	case 3:
+	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 4000);
+	  break;
+	case 4:
+	  ok = bfd_set_arch_mach (stdoutput, bfd_arch_mips, 8000);
+	  break;
+	}
+    }
+
+  if (! ok)
+    as_warn (_("Could not set architecture and machine"));
+
+  file_mips_isa = mips_opts.isa;
+
+  op_hash = hash_new ();
+
+  for (i = 0; i < NUMOPCODES;)
+    {
+      const char *name = mips_opcodes[i].name;
+
+      retval = hash_insert (op_hash, name, (PTR) &mips_opcodes[i]);
+      if (retval != NULL)
+	{
+	  fprintf (stderr, _("internal error: can't hash `%s': %s\n"),
+		   mips_opcodes[i].name, retval);
+	  /* Probably a memory allocation problem?  Give up now.  */
+	  as_fatal (_("Broken assembler.  No assembly attempted."));
+	}
+      do
+	{
+	  if (mips_opcodes[i].pinfo != INSN_MACRO)
+	    {
+	      if (!validate_mips_insn (&mips_opcodes[i]))
+		broken = 1;
+	    }
+	  ++i;
+	}
+      while ((i < NUMOPCODES) && !strcmp (mips_opcodes[i].name, name));
+    }
+
+  mips16_op_hash = hash_new ();
+
+  i = 0;
+  while (i < bfd_mips16_num_opcodes)
+    {
+      const char *name = mips16_opcodes[i].name;
+
+      retval = hash_insert (mips16_op_hash, name, (PTR) &mips16_opcodes[i]);
+      if (retval != NULL)
+	as_fatal (_("internal: can't hash `%s': %s"),
+		  mips16_opcodes[i].name, retval);
+      do
+	{
+	  if (mips16_opcodes[i].pinfo != INSN_MACRO
+	      && ((mips16_opcodes[i].match & mips16_opcodes[i].mask)
+		  != mips16_opcodes[i].match))
+	    {
+	      fprintf (stderr, _("internal error: bad mips16 opcode: %s %s\n"),
+		       mips16_opcodes[i].name, mips16_opcodes[i].args);
+	      broken = 1;
+	    }
+	  ++i;
+	}
+      while (i < bfd_mips16_num_opcodes
+	     && strcmp (mips16_opcodes[i].name, name) == 0);
+    }
+
+  if (broken)
+    as_fatal (_("Broken assembler.  No assembly attempted."));
+
+  /* We add all the general register names to the symbol table.  This
+     helps us detect invalid uses of them.  */
+  for (i = 0; i < 32; i++)
+    {
+      char buf[5];
+
+      sprintf (buf, "$%d", i);
+      symbol_table_insert (symbol_new (buf, reg_section, i,
+				       &zero_address_frag));
+    }
+  symbol_table_insert (symbol_new ("$fp", reg_section, FP,
+				   &zero_address_frag));
+  symbol_table_insert (symbol_new ("$sp", reg_section, SP,
+				   &zero_address_frag));
+  symbol_table_insert (symbol_new ("$gp", reg_section, GP,
+				   &zero_address_frag));
+  symbol_table_insert (symbol_new ("$at", reg_section, AT,
+				   &zero_address_frag));
+  symbol_table_insert (symbol_new ("$kt0", reg_section, KT0,
+				   &zero_address_frag));
+  symbol_table_insert (symbol_new ("$kt1", reg_section, KT1,
+				   &zero_address_frag));
+  symbol_table_insert (symbol_new ("$pc", reg_section, -1,
+				   &zero_address_frag));
+
+  mips_no_prev_insn (false);
+
+  mips_gprmask = 0;
+  mips_cprmask[0] = 0;
+  mips_cprmask[1] = 0;
+  mips_cprmask[2] = 0;
+  mips_cprmask[3] = 0;
+
+  /* set the default alignment for the text section (2**2) */
+  record_alignment (text_section, 2);
+
+  if (USE_GLOBAL_POINTER_OPT)
+    bfd_set_gp_size (stdoutput, g_switch_value);
+
+  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+    {
+      /* On a native system, sections must be aligned to 16 byte
+	 boundaries.  When configured for an embedded ELF target, we
+	 don't bother.  */
+      if (strcmp (TARGET_OS, "elf") != 0)
+	{
+	  (void) bfd_set_section_alignment (stdoutput, text_section, 4);
+	  (void) bfd_set_section_alignment (stdoutput, data_section, 4);
+	  (void) bfd_set_section_alignment (stdoutput, bss_section, 4);
+	}
+
+      /* Create a .reginfo section for register masks and a .mdebug
+	 section for debugging information.  */
+      {
+	segT seg;
+	subsegT subseg;
+	flagword flags;
+	segT sec;
+
+	seg = now_seg;
+	subseg = now_subseg;
+
+	/* The ABI says this section should be loaded so that the
+	   running program can access it.  However, we don't load it
+	   if we are configured for an embedded target */
+	flags = SEC_READONLY | SEC_DATA;
+	if (strcmp (TARGET_OS, "elf") != 0)
+	  flags |= SEC_ALLOC | SEC_LOAD;
+
+	if (! mips_64)
+	  {
+	    sec = subseg_new (".reginfo", (subsegT) 0);
+
+
+	    (void) bfd_set_section_flags (stdoutput, sec, flags);
+	    (void) bfd_set_section_alignment (stdoutput, sec, 2);
+	
+#ifdef OBJ_ELF
+	    mips_regmask_frag = frag_more (sizeof (Elf32_External_RegInfo));
+#endif
+	  }
+	else
+	  {
+	    /* The 64-bit ABI uses a .MIPS.options section rather than
+               .reginfo section.  */
+	    sec = subseg_new (".MIPS.options", (subsegT) 0);
+	    (void) bfd_set_section_flags (stdoutput, sec, flags);
+	    (void) bfd_set_section_alignment (stdoutput, sec, 3);
+
+#ifdef OBJ_ELF
+	    /* Set up the option header.  */
+	    {
+	      Elf_Internal_Options opthdr;
+	      char *f;
+
+	      opthdr.kind = ODK_REGINFO;
+	      opthdr.size = (sizeof (Elf_External_Options)
+			     + sizeof (Elf64_External_RegInfo));
+	      opthdr.section = 0;
+	      opthdr.info = 0;
+	      f = frag_more (sizeof (Elf_External_Options));
+	      bfd_mips_elf_swap_options_out (stdoutput, &opthdr,
+					     (Elf_External_Options *) f);
+
+	      mips_regmask_frag = frag_more (sizeof (Elf64_External_RegInfo));
+	    }
+#endif
+	  }
+
+	if (ECOFF_DEBUGGING)
+	  {
+	    sec = subseg_new (".mdebug", (subsegT) 0);
+	    (void) bfd_set_section_flags (stdoutput, sec,
+					  SEC_HAS_CONTENTS | SEC_READONLY);
+	    (void) bfd_set_section_alignment (stdoutput, sec, 2);
+	  }
+
+#ifdef MIPS_STABS_ELF
+	pdr_seg = subseg_new (".pdr", (subsegT) 0);
+	(void) bfd_set_section_flags (stdoutput, pdr_seg,
+			     SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);
+	(void) bfd_set_section_alignment (stdoutput, pdr_seg, 2);
+#endif
+
+	subseg_set (seg, subseg);
+      }
+    }
+
+  if (! ECOFF_DEBUGGING)
+    md_obj_begin ();
+}
+
+void
+md_mips_end ()
+{
+  if (! ECOFF_DEBUGGING)
+    md_obj_end ();
+}
+
+void
+md_assemble (str)
+     char *str;
+{
+  struct mips_cl_insn insn;
+
+  imm_expr.X_op = O_absent;
+  imm_reloc = BFD_RELOC_UNUSED;
+  imm_unmatched_hi = false;
+  offset_expr.X_op = O_absent;
+  offset_reloc = BFD_RELOC_UNUSED;
+
+  if (mips_opts.mips16)
+    mips16_ip (str, &insn);
+  else
+    {
+      mips_ip (str, &insn);
+      DBG((_("returned from mips_ip(%s) insn_opcode = 0x%x\n"), 
+		str, insn.insn_opcode));
+    }
+
+  if (insn_error)
+    {
+      as_bad ("%s `%s'", insn_error, str);
+      return;
+    }
+
+  if (insn.insn_mo->pinfo == INSN_MACRO)
+    {
+      if (mips_opts.mips16)
+	mips16_macro (&insn);
+      else
+	macro (&insn);
+    }
+  else
+    {
+      if (imm_expr.X_op != O_absent)
+	append_insn ((char *) NULL, &insn, &imm_expr, imm_reloc,
+		     imm_unmatched_hi);
+      else if (offset_expr.X_op != O_absent)
+	append_insn ((char *) NULL, &insn, &offset_expr, offset_reloc, false);
+      else
+	append_insn ((char *) NULL, &insn, NULL, BFD_RELOC_UNUSED, false);
+    }
+}
+
+/* See whether instruction IP reads register REG.  CLASS is the type
+   of register.  */
+
+static int
+insn_uses_reg (ip, reg, class)
+     struct mips_cl_insn *ip;
+     unsigned int reg;
+     enum mips_regclass class;
+{
+  if (class == MIPS16_REG)
+    {
+      assert (mips_opts.mips16);
+      reg = mips16_to_32_reg_map[reg];
+      class = MIPS_GR_REG;
+    }
+
+  /* Don't report on general register 0, since it never changes.  */
+  if (class == MIPS_GR_REG && reg == 0)
+    return 0;
+
+  if (class == MIPS_FP_REG)
+    {
+      assert (! mips_opts.mips16);
+      /* If we are called with either $f0 or $f1, we must check $f0.
+	 This is not optimal, because it will introduce an unnecessary
+	 NOP between "lwc1 $f0" and "swc1 $f1".  To fix this we would
+	 need to distinguish reading both $f0 and $f1 or just one of
+	 them.  Note that we don't have to check the other way,
+	 because there is no instruction that sets both $f0 and $f1
+	 and requires a delay.  */
+      if ((ip->insn_mo->pinfo & INSN_READ_FPR_S)
+	  && ((((ip->insn_opcode >> OP_SH_FS) & OP_MASK_FS) &~(unsigned)1)
+	      == (reg &~ (unsigned) 1)))
+	return 1;
+      if ((ip->insn_mo->pinfo & INSN_READ_FPR_T)
+	  && ((((ip->insn_opcode >> OP_SH_FT) & OP_MASK_FT) &~(unsigned)1)
+	      == (reg &~ (unsigned) 1)))
+	return 1;
+    }
+  else if (! mips_opts.mips16)
+    {
+      if ((ip->insn_mo->pinfo & INSN_READ_GPR_S)
+	  && ((ip->insn_opcode >> OP_SH_RS) & OP_MASK_RS) == reg)
+	return 1;
+      if ((ip->insn_mo->pinfo & INSN_READ_GPR_T)
+	  && ((ip->insn_opcode >> OP_SH_RT) & OP_MASK_RT) == reg)
+	return 1;
+    }
+  else
+    {
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_X)
+	  && (mips16_to_32_reg_map[((ip->insn_opcode >> MIPS16OP_SH_RX)
+				    & MIPS16OP_MASK_RX)]
+	      == reg))
+	return 1;
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_Y)
+	  && (mips16_to_32_reg_map[((ip->insn_opcode >> MIPS16OP_SH_RY)
+				    & MIPS16OP_MASK_RY)]
+	      == reg))
+	return 1;
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_Z)
+	  && (mips16_to_32_reg_map[((ip->insn_opcode >> MIPS16OP_SH_MOVE32Z)
+				    & MIPS16OP_MASK_MOVE32Z)]
+	      == reg))
+	return 1;
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_T) && reg == TREG)
+	return 1;
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_SP) && reg == SP)
+	return 1;
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_31) && reg == RA)
+	return 1;
+      if ((ip->insn_mo->pinfo & MIPS16_INSN_READ_GPR_X)
+	  && ((ip->insn_opcode >> MIPS16OP_SH_REGR32)
+	      & MIPS16OP_MASK_REGR32) == reg)
+	return 1;
+    }
+
+  return 0;
+}
+
+/* This function returns true if modifying a register requires a
+   delay.  */
+
+static int
+reg_needs_delay (reg)
+     int reg;
+{
+  unsigned long prev_pinfo;
+
+  prev_pinfo = prev_insn.insn_mo->pinfo;
+  if (! mips_opts.noreorder
+      && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+      && ((prev_pinfo & INSN_LOAD_COPROC_DELAY)
+	  || (! gpr_interlocks
+	      && (prev_pinfo & INSN_LOAD_MEMORY_DELAY))))
+    {
+      /* A load from a coprocessor or from memory.  All load
+	 delays delay the use of general register rt for one
+	 instruction on the r3000.  The r6000 and r4000 use
+	 interlocks.  */
+      /* Itbl support may require additional care here. */
+      know (prev_pinfo & INSN_WRITE_GPR_T);
+      if (reg == ((prev_insn.insn_opcode >> OP_SH_RT) & OP_MASK_RT))
+	return 1;
+    }
+
+  return 0;
+}
+
+/* Mark instruction labels in mips16 mode.  This permits the linker to
+   handle them specially, such as generating jalx instructions when
+   needed.  We also make them odd for the duration of the assembly, in
+   order to generate the right sort of code.  We will make them even
+   in the adjust_symtab routine, while leaving them marked.  This is
+   convenient for the debugger and the disassembler.  The linker knows
+   to make them odd again.  */
+
+static void
+mips16_mark_labels ()
+{
+  if (mips_opts.mips16)
+    {
+      struct insn_label_list *l;
+
+      for (l = insn_labels; l != NULL; l = l->next)
+	{
+#ifdef OBJ_ELF
+	  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+	    S_SET_OTHER (l->label, STO_MIPS16);
+#endif
+	  if ((S_GET_VALUE (l->label) & 1) == 0)
+	    S_SET_VALUE (l->label, S_GET_VALUE (l->label) + 1);
+	}
+    }
+}
+
+/* Output an instruction.  PLACE is where to put the instruction; if
+   it is NULL, this uses frag_more to get room.  IP is the instruction
+   information.  ADDRESS_EXPR is an operand of the instruction to be
+   used with RELOC_TYPE.  */
+
+static void
+append_insn (place, ip, address_expr, reloc_type, unmatched_hi)
+     char *place;
+     struct mips_cl_insn *ip;
+     expressionS *address_expr;
+     bfd_reloc_code_real_type reloc_type;
+     boolean unmatched_hi;
+{
+  register unsigned long prev_pinfo, pinfo;
+  char *f;
+  fixS *fixp;
+  int nops = 0;
+
+  /* Mark instruction labels in mips16 mode.  */
+  if (mips_opts.mips16)
+    mips16_mark_labels ();
+
+  prev_pinfo = prev_insn.insn_mo->pinfo;
+  pinfo = ip->insn_mo->pinfo;
+
+  if (place == NULL && (! mips_opts.noreorder || prev_nop_frag != NULL))
+    {
+      int prev_prev_nop;
+
+      /* If the previous insn required any delay slots, see if we need
+	 to insert a NOP or two.  There are eight kinds of possible
+	 hazards, of which an instruction can have at most one type.
+	 (1) a load from memory delay
+	 (2) a load from a coprocessor delay
+	 (3) an unconditional branch delay
+	 (4) a conditional branch delay
+	 (5) a move to coprocessor register delay
+	 (6) a load coprocessor register from memory delay
+	 (7) a coprocessor condition code delay
+	 (8) a HI/LO special register delay
+
+	 There are a lot of optimizations we could do that we don't.
+	 In particular, we do not, in general, reorder instructions.
+	 If you use gcc with optimization, it will reorder
+	 instructions and generally do much more optimization then we
+	 do here; repeating all that work in the assembler would only
+	 benefit hand written assembly code, and does not seem worth
+	 it.  */
+
+      /* This is how a NOP is emitted.  */
+#define emit_nop()					\
+  (mips_opts.mips16					\
+   ? md_number_to_chars (frag_more (2), 0x6500, 2)	\
+   : md_number_to_chars (frag_more (4), 0, 4))
+
+      /* The previous insn might require a delay slot, depending upon
+	 the contents of the current insn.  */
+      if (! mips_opts.mips16
+	  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+	  && (((prev_pinfo & INSN_LOAD_COPROC_DELAY)
+               && ! cop_interlocks)
+	      || (! gpr_interlocks
+		  && (prev_pinfo & INSN_LOAD_MEMORY_DELAY))))
+	{
+	  /* A load from a coprocessor or from memory.  All load
+	     delays delay the use of general register rt for one
+	     instruction on the r3000.  The r6000 and r4000 use
+	     interlocks.  */
+          /* Itbl support may require additional care here. */
+	  know (prev_pinfo & INSN_WRITE_GPR_T);
+	  if (mips_optimize == 0
+	      || insn_uses_reg (ip,
+				((prev_insn.insn_opcode >> OP_SH_RT)
+				 & OP_MASK_RT),
+				MIPS_GR_REG))
+	    ++nops;
+	}
+      else if (! mips_opts.mips16
+	       && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+	       && (((prev_pinfo & INSN_COPROC_MOVE_DELAY)
+                    && ! cop_interlocks)
+		   || (mips_opts.isa == 1
+		       && (prev_pinfo & INSN_COPROC_MEMORY_DELAY))))
+	{
+	  /* A generic coprocessor delay.  The previous instruction
+	     modified a coprocessor general or control register.  If
+	     it modified a control register, we need to avoid any
+	     coprocessor instruction (this is probably not always
+	     required, but it sometimes is).  If it modified a general
+	     register, we avoid using that register.
+
+	     On the r6000 and r4000 loading a coprocessor register
+	     from memory is interlocked, and does not require a delay.
+
+	     This case is not handled very well.  There is no special
+	     knowledge of CP0 handling, and the coprocessors other
+	     than the floating point unit are not distinguished at
+	     all.  */
+          /* Itbl support may require additional care here. FIXME!
+             Need to modify this to include knowledge about 
+             user specified delays!  */
+	  if (prev_pinfo & INSN_WRITE_FPR_T)
+	    {
+	      if (mips_optimize == 0
+		  || insn_uses_reg (ip,
+				    ((prev_insn.insn_opcode >> OP_SH_FT)
+				     & OP_MASK_FT),
+				    MIPS_FP_REG))
+		++nops;
+	    }
+	  else if (prev_pinfo & INSN_WRITE_FPR_S)
+	    {
+	      if (mips_optimize == 0
+		  || insn_uses_reg (ip,
+				    ((prev_insn.insn_opcode >> OP_SH_FS)
+				     & OP_MASK_FS),
+				    MIPS_FP_REG))
+		++nops;
+	    }
+	  else
+	    {
+	      /* We don't know exactly what the previous instruction
+		 does.  If the current instruction uses a coprocessor
+		 register, we must insert a NOP.  If previous
+		 instruction may set the condition codes, and the
+		 current instruction uses them, we must insert two
+		 NOPS.  */
+              /* Itbl support may require additional care here. */
+	      if (mips_optimize == 0
+		  || ((prev_pinfo & INSN_WRITE_COND_CODE)
+		      && (pinfo & INSN_READ_COND_CODE)))
+		nops += 2;
+	      else if (pinfo & INSN_COP)
+		++nops;
+	    }
+	}
+      else if (! mips_opts.mips16
+	       && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+	       && (prev_pinfo & INSN_WRITE_COND_CODE)
+               && ! cop_interlocks)
+	{
+	  /* The previous instruction sets the coprocessor condition
+	     codes, but does not require a general coprocessor delay
+	     (this means it is a floating point comparison
+	     instruction).  If this instruction uses the condition
+	     codes, we need to insert a single NOP.  */
+          /* Itbl support may require additional care here. */
+	  if (mips_optimize == 0
+	      || (pinfo & INSN_READ_COND_CODE))
+	    ++nops;
+	}
+
+      /* If we're fixing up mfhi/mflo for the r7000 and the
+	 previous insn was an mfhi/mflo and the current insn
+	 reads the register that the mfhi/mflo wrote to, then
+	 insert two nops.  */
+
+      else if (mips_7000_hilo_fix
+	       && MF_HILO_INSN (prev_pinfo)
+	       && insn_uses_reg (ip, ((prev_insn.insn_opcode >> OP_SH_RD)
+                                       & OP_MASK_RD),
+                                    MIPS_GR_REG))
+
+	{
+	  nops += 2;
+	}
+
+      /* If we're fixing up mfhi/mflo for the r7000 and the
+	 2nd previous insn was an mfhi/mflo and the current insn
+	 reads the register that the mfhi/mflo wrote to, then
+	 insert one nop.  */
+
+      else if (mips_7000_hilo_fix
+	       && MF_HILO_INSN (prev_prev_insn.insn_opcode)
+	       && insn_uses_reg (ip, ((prev_prev_insn.insn_opcode >> OP_SH_RD)
+                                       & OP_MASK_RD),
+                                    MIPS_GR_REG))
+     
+	{
+	  nops += 1;
+	}
+ 
+      else if (prev_pinfo & INSN_READ_LO)
+	{
+	  /* The previous instruction reads the LO register; if the
+	     current instruction writes to the LO register, we must
+	     insert two NOPS.  Some newer processors have interlocks. 
+	     Also the tx39's multiply instructions can be exectuted 
+             immediatly after a read from HI/LO (without the delay),
+             though the tx39's divide insns still do require the 
+	     delay. */
+	  if (! (hilo_interlocks
+		 || (mips_cpu == 3900 && (pinfo & INSN_MULT)))
+	      && (mips_optimize == 0
+		  || (pinfo & INSN_WRITE_LO)))
+	    nops += 2;
+	  /* Most mips16 branch insns don't have a delay slot.
+	     If a read from LO is immediately followed by a branch
+	     to a write to LO we have a read followed by a write
+	     less than 2 insns away.  We assume the target of
+	     a branch might be a write to LO, and insert a nop
+	     between a read and an immediately following branch. */
+	  else if (mips_opts.mips16
+		   && (mips_optimize == 0
+		       || (pinfo & MIPS16_INSN_BRANCH)))
+	    nops += 1;
+	}
+      else if (prev_insn.insn_mo->pinfo & INSN_READ_HI)
+	{
+	  /* The previous instruction reads the HI register; if the
+	     current instruction writes to the HI register, we must
+	     insert a NOP.  Some newer processors have interlocks.
+	     Also the note tx39's multiply above. */
+	  if (! (hilo_interlocks
+		 || (mips_cpu == 3900 && (pinfo & INSN_MULT)))
+	      && (mips_optimize == 0
+		  || (pinfo & INSN_WRITE_HI)))
+	    nops += 2;
+	  /* Most mips16 branch insns don't have a delay slot.
+	     If a read from HI is immediately followed by a branch
+	     to a write to HI we have a read followed by a write
+	     less than 2 insns away.  We assume the target of
+	     a branch might be a write to HI, and insert a nop
+	     between a read and an immediately following branch. */
+	  else if (mips_opts.mips16
+		   && (mips_optimize == 0
+		       || (pinfo & MIPS16_INSN_BRANCH)))
+	    nops += 1;
+	}
+
+      /* If the previous instruction was in a noreorder section, then
+         we don't want to insert the nop after all.  */
+      /* Itbl support may require additional care here. */
+      if (prev_insn_unreordered)
+	nops = 0;
+
+      /* There are two cases which require two intervening
+	 instructions: 1) setting the condition codes using a move to
+	 coprocessor instruction which requires a general coprocessor
+	 delay and then reading the condition codes 2) reading the HI
+	 or LO register and then writing to it (except on processors
+	 which have interlocks).  If we are not already emitting a NOP
+	 instruction, we must check for these cases compared to the
+	 instruction previous to the previous instruction.  */
+      if ((! mips_opts.mips16
+	   && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+	   && (prev_prev_insn.insn_mo->pinfo & INSN_COPROC_MOVE_DELAY)
+	   && (prev_prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE)
+	   && (pinfo & INSN_READ_COND_CODE)
+	   && ! cop_interlocks)
+	  || ((prev_prev_insn.insn_mo->pinfo & INSN_READ_LO)
+	      && (pinfo & INSN_WRITE_LO)
+	      && ! (hilo_interlocks
+		    || (mips_cpu == 3900 && (pinfo & INSN_MULT))))
+	  || ((prev_prev_insn.insn_mo->pinfo & INSN_READ_HI)
+	      && (pinfo & INSN_WRITE_HI)
+	      && ! (hilo_interlocks
+		    || (mips_cpu == 3900 && (pinfo & INSN_MULT)))))
+	prev_prev_nop = 1;
+      else
+	prev_prev_nop = 0;
+
+      if (prev_prev_insn_unreordered)
+	prev_prev_nop = 0;
+
+      if (prev_prev_nop && nops == 0)
+	++nops;
+
+      /* If we are being given a nop instruction, don't bother with
+	 one of the nops we would otherwise output.  This will only
+	 happen when a nop instruction is used with mips_optimize set
+	 to 0.  */
+      if (nops > 0
+	  && ! mips_opts.noreorder
+	  && ip->insn_opcode == (mips_opts.mips16 ? 0x6500 : 0))
+	--nops;
+
+      /* Now emit the right number of NOP instructions.  */
+      if (nops > 0 && ! mips_opts.noreorder)
+	{
+	  fragS *old_frag;
+	  unsigned long old_frag_offset;
+	  int i;
+	  struct insn_label_list *l;
+
+	  old_frag = frag_now;
+	  old_frag_offset = frag_now_fix ();
+
+	  for (i = 0; i < nops; i++)
+	    emit_nop ();
+
+	  if (listing)
+	    {
+	      listing_prev_line ();
+	      /* We may be at the start of a variant frag.  In case we
+                 are, make sure there is enough space for the frag
+                 after the frags created by listing_prev_line.  The
+                 argument to frag_grow here must be at least as large
+                 as the argument to all other calls to frag_grow in
+                 this file.  We don't have to worry about being in the
+                 middle of a variant frag, because the variants insert
+                 all needed nop instructions themselves.  */
+	      frag_grow (40);
+	    }
+
+	  for (l = insn_labels; l != NULL; l = l->next)
+	    {
+	      assert (S_GET_SEGMENT (l->label) == now_seg);
+	      symbol_set_frag (l->label, frag_now);
+	      S_SET_VALUE (l->label, (valueT) frag_now_fix ());
+	      /* mips16 text labels are stored as odd.  */
+	      if (mips_opts.mips16)
+		S_SET_VALUE (l->label, S_GET_VALUE (l->label) + 1);
+	    }
+
+#ifndef NO_ECOFF_DEBUGGING
+	  if (ECOFF_DEBUGGING)
+	    ecoff_fix_loc (old_frag, old_frag_offset);
+#endif
+	}
+      else if (prev_nop_frag != NULL)
+	{
+	  /* We have a frag holding nops we may be able to remove.  If
+             we don't need any nops, we can decrease the size of
+             prev_nop_frag by the size of one instruction.  If we do
+             need some nops, we count them in prev_nops_required. */
+	  if (prev_nop_frag_since == 0)
+	    {
+	      if (nops == 0)
+		{
+		  prev_nop_frag->fr_fix -= mips_opts.mips16 ? 2 : 4;
+		  --prev_nop_frag_holds;
+		}
+	      else
+		prev_nop_frag_required += nops;
+	    }
+	  else
+	    {
+	      if (prev_prev_nop == 0)
+		{
+		  prev_nop_frag->fr_fix -= mips_opts.mips16 ? 2 : 4;
+		  --prev_nop_frag_holds;
+		}
+	      else
+		++prev_nop_frag_required;
+	    }
+
+	  if (prev_nop_frag_holds <= prev_nop_frag_required)
+	    prev_nop_frag = NULL;
+
+	  ++prev_nop_frag_since;
+
+	  /* Sanity check: by the time we reach the second instruction
+             after prev_nop_frag, we should have used up all the nops
+             one way or another.  */
+	  assert (prev_nop_frag_since <= 1 || prev_nop_frag == NULL);
+	}
+    }
+
+  if (reloc_type > BFD_RELOC_UNUSED)
+    {
+      /* We need to set up a variant frag.  */
+      assert (mips_opts.mips16 && address_expr != NULL);
+      f = frag_var (rs_machine_dependent, 4, 0,
+		    RELAX_MIPS16_ENCODE (reloc_type - BFD_RELOC_UNUSED,
+					 mips16_small, mips16_ext,
+					 (prev_pinfo
+					  & INSN_UNCOND_BRANCH_DELAY),
+					 (prev_insn_reloc_type
+					  == BFD_RELOC_MIPS16_JMP)),
+		    make_expr_symbol (address_expr), (offsetT) 0,
+		    (char *) NULL);
+    }
+  else if (place != NULL)
+    f = place;
+  else if (mips_opts.mips16
+	   && ! ip->use_extend
+	   && reloc_type != BFD_RELOC_MIPS16_JMP)
+    {
+      /* Make sure there is enough room to swap this instruction with
+         a following jump instruction.  */
+      frag_grow (6);
+      f = frag_more (2);
+    }
+  else
+    {
+      if (mips_opts.mips16
+	  && mips_opts.noreorder
+	  && (prev_pinfo & INSN_UNCOND_BRANCH_DELAY) != 0)
+	as_warn (_("extended instruction in delay slot"));
+
+      f = frag_more (4);
+    }
+
+  fixp = NULL;
+  if (address_expr != NULL && reloc_type < BFD_RELOC_UNUSED)
+    {
+      if (address_expr->X_op == O_constant)
+	{
+	  switch (reloc_type)
+	    {
+	    case BFD_RELOC_32:
+	      ip->insn_opcode |= address_expr->X_add_number;
+	      break;
+
+	    case BFD_RELOC_LO16:
+	      ip->insn_opcode |= address_expr->X_add_number & 0xffff;
+	      break;
+
+	    case BFD_RELOC_MIPS_JMP:
+	      if ((address_expr->X_add_number & 3) != 0)
+		as_bad (_("jump to misaligned address (0x%lx)"),
+			(unsigned long) address_expr->X_add_number);
+	      ip->insn_opcode |= (address_expr->X_add_number >> 2) & 0x3ffffff;
+	      break;
+
+	    case BFD_RELOC_MIPS16_JMP:
+	      if ((address_expr->X_add_number & 3) != 0)
+		as_bad (_("jump to misaligned address (0x%lx)"),
+			(unsigned long) address_expr->X_add_number);
+	      ip->insn_opcode |=
+		(((address_expr->X_add_number & 0x7c0000) << 3)
+		 | ((address_expr->X_add_number & 0xf800000) >> 7)
+		 | ((address_expr->X_add_number & 0x3fffc) >> 2));
+	      break;
+
+
+	    case BFD_RELOC_16_PCREL_S2:
+	      goto need_reloc;
+
+	    default:
+	      internalError ();
+	    }
+	}
+      else
+	{
+	need_reloc:
+	  /* Don't generate a reloc if we are writing into a variant
+	     frag.  */
+	  if (place == NULL)
+	    {
+	      fixp = fix_new_exp (frag_now, f - frag_now->fr_literal, 4,
+				  address_expr,
+				  reloc_type == BFD_RELOC_16_PCREL_S2,
+				  reloc_type);
+	      if (unmatched_hi)
+		{
+		  struct mips_hi_fixup *hi_fixup;
+
+		  assert (reloc_type == BFD_RELOC_HI16_S);
+		  hi_fixup = ((struct mips_hi_fixup *)
+			      xmalloc (sizeof (struct mips_hi_fixup)));
+		  hi_fixup->fixp = fixp;
+		  hi_fixup->seg = now_seg;
+		  hi_fixup->next = mips_hi_fixup_list;
+		  mips_hi_fixup_list = hi_fixup;
+		}
+	    }
+	}
+    }
+
+  if (! mips_opts.mips16)
+    md_number_to_chars (f, ip->insn_opcode, 4);
+  else if (reloc_type == BFD_RELOC_MIPS16_JMP)
+    {
+      md_number_to_chars (f, ip->insn_opcode >> 16, 2);
+      md_number_to_chars (f + 2, ip->insn_opcode & 0xffff, 2);
+    }
+  else
+    {
+      if (ip->use_extend)
+	{
+	  md_number_to_chars (f, 0xf000 | ip->extend, 2);
+	  f += 2;
+	}
+      md_number_to_chars (f, ip->insn_opcode, 2);
+    }
+
+  /* Update the register mask information.  */
+  if (! mips_opts.mips16)
+    {
+      if (pinfo & INSN_WRITE_GPR_D)
+	mips_gprmask |= 1 << ((ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD);
+      if ((pinfo & (INSN_WRITE_GPR_T | INSN_READ_GPR_T)) != 0)
+	mips_gprmask |= 1 << ((ip->insn_opcode >> OP_SH_RT) & OP_MASK_RT);
+      if (pinfo & INSN_READ_GPR_S)
+	mips_gprmask |= 1 << ((ip->insn_opcode >> OP_SH_RS) & OP_MASK_RS);
+      if (pinfo & INSN_WRITE_GPR_31)
+	mips_gprmask |= 1 << 31;
+      if (pinfo & INSN_WRITE_FPR_D)
+	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FD) & OP_MASK_FD);
+      if ((pinfo & (INSN_WRITE_FPR_S | INSN_READ_FPR_S)) != 0)
+	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FS) & OP_MASK_FS);
+      if ((pinfo & (INSN_WRITE_FPR_T | INSN_READ_FPR_T)) != 0)
+	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FT) & OP_MASK_FT);
+      if ((pinfo & INSN_READ_FPR_R) != 0)
+	mips_cprmask[1] |= 1 << ((ip->insn_opcode >> OP_SH_FR) & OP_MASK_FR);
+      if (pinfo & INSN_COP)
+	{
+	  /* We don't keep enough information to sort these cases out. 
+	     The itbl support does keep this information however, although 
+	     we currently don't support itbl fprmats as part of the cop 
+	     instruction.  May want to add this support in the future. */
+	}
+      /* Never set the bit for $0, which is always zero.  */
+      mips_gprmask &=~ 1 << 0;
+    }
+  else
+    {
+      if (pinfo & (MIPS16_INSN_WRITE_X | MIPS16_INSN_READ_X))
+	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_RX)
+			      & MIPS16OP_MASK_RX);
+      if (pinfo & (MIPS16_INSN_WRITE_Y | MIPS16_INSN_READ_Y))
+	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_RY)
+			      & MIPS16OP_MASK_RY);
+      if (pinfo & MIPS16_INSN_WRITE_Z)
+	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_RZ)
+			      & MIPS16OP_MASK_RZ);
+      if (pinfo & (MIPS16_INSN_WRITE_T | MIPS16_INSN_READ_T))
+	mips_gprmask |= 1 << TREG;
+      if (pinfo & (MIPS16_INSN_WRITE_SP | MIPS16_INSN_READ_SP))
+	mips_gprmask |= 1 << SP;
+      if (pinfo & (MIPS16_INSN_WRITE_31 | MIPS16_INSN_READ_31))
+	mips_gprmask |= 1 << RA;
+      if (pinfo & MIPS16_INSN_WRITE_GPR_Y)
+	mips_gprmask |= 1 << MIPS16OP_EXTRACT_REG32R (ip->insn_opcode);
+      if (pinfo & MIPS16_INSN_READ_Z)
+	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_MOVE32Z)
+			      & MIPS16OP_MASK_MOVE32Z);
+      if (pinfo & MIPS16_INSN_READ_GPR_X)
+	mips_gprmask |= 1 << ((ip->insn_opcode >> MIPS16OP_SH_REGR32)
+			      & MIPS16OP_MASK_REGR32);
+    }
+
+  if (place == NULL && ! mips_opts.noreorder)
+    {
+      /* Filling the branch delay slot is more complex.  We try to
+	 switch the branch with the previous instruction, which we can
+	 do if the previous instruction does not set up a condition
+	 that the branch tests and if the branch is not itself the
+	 target of any branch.  */
+      if ((pinfo & INSN_UNCOND_BRANCH_DELAY)
+	  || (pinfo & INSN_COND_BRANCH_DELAY))
+	{
+	  if (mips_optimize < 2
+	      /* If we have seen .set volatile or .set nomove, don't
+		 optimize.  */
+	      || mips_opts.nomove != 0
+	      /* If we had to emit any NOP instructions, then we
+		 already know we can not swap.  */
+	      || nops != 0
+	      /* If we don't even know the previous insn, we can not
+		 swap. */
+	      || ! prev_insn_valid
+	      /* If the previous insn is already in a branch delay
+		 slot, then we can not swap.  */
+	      || prev_insn_is_delay_slot
+	      /* If the previous previous insn was in a .set
+		 noreorder, we can't swap.  Actually, the MIPS
+		 assembler will swap in this situation.  However, gcc
+		 configured -with-gnu-as will generate code like
+		   .set noreorder
+		   lw	$4,XXX
+		   .set	reorder
+		   INSN
+		   bne	$4,$0,foo
+		 in which we can not swap the bne and INSN.  If gcc is
+		 not configured -with-gnu-as, it does not output the
+		 .set pseudo-ops.  We don't have to check
+		 prev_insn_unreordered, because prev_insn_valid will
+		 be 0 in that case.  We don't want to use
+		 prev_prev_insn_valid, because we do want to be able
+		 to swap at the start of a function.  */
+	      || prev_prev_insn_unreordered
+	      /* If the branch is itself the target of a branch, we
+		 can not swap.  We cheat on this; all we check for is
+		 whether there is a label on this instruction.  If
+		 there are any branches to anything other than a
+		 label, users must use .set noreorder.  */
+	      || insn_labels != NULL
+	      /* If the previous instruction is in a variant frag, we
+		 can not do the swap.  This does not apply to the
+		 mips16, which uses variant frags for different
+		 purposes.  */
+	      || (! mips_opts.mips16
+		  && prev_insn_frag->fr_type == rs_machine_dependent)
+	      /* If the branch reads the condition codes, we don't
+		 even try to swap, because in the sequence
+		   ctc1 $X,$31
+		   INSN
+		   INSN
+		   bc1t LABEL
+		 we can not swap, and I don't feel like handling that
+		 case.  */
+	      || (! mips_opts.mips16
+		  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+		  && (pinfo & INSN_READ_COND_CODE))
+	      /* We can not swap with an instruction that requires a
+		 delay slot, becase the target of the branch might
+		 interfere with that instruction.  */
+	      || (! mips_opts.mips16
+		  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+		  && (prev_pinfo
+              /* Itbl support may require additional care here. */
+		      & (INSN_LOAD_COPROC_DELAY
+			 | INSN_COPROC_MOVE_DELAY
+			 | INSN_WRITE_COND_CODE)))
+	      || (! (hilo_interlocks
+		     || (mips_cpu == 3900 && (pinfo & INSN_MULT)))
+		  && (prev_pinfo
+		      & (INSN_READ_LO
+			 | INSN_READ_HI)))
+	      || (! mips_opts.mips16
+		  && ! gpr_interlocks
+		  && (prev_pinfo & INSN_LOAD_MEMORY_DELAY))
+	      || (! mips_opts.mips16
+		  && mips_opts.isa == 1
+                  /* Itbl support may require additional care here. */
+		  && (prev_pinfo & INSN_COPROC_MEMORY_DELAY))
+	      /* We can not swap with a branch instruction.  */
+	      || (prev_pinfo
+		  & (INSN_UNCOND_BRANCH_DELAY
+		     | INSN_COND_BRANCH_DELAY
+		     | INSN_COND_BRANCH_LIKELY))
+	      /* We do not swap with a trap instruction, since it
+		 complicates trap handlers to have the trap
+		 instruction be in a delay slot.  */
+	      || (prev_pinfo & INSN_TRAP)
+	      /* If the branch reads a register that the previous
+		 instruction sets, we can not swap.  */
+	      || (! mips_opts.mips16
+		  && (prev_pinfo & INSN_WRITE_GPR_T)
+		  && insn_uses_reg (ip,
+				    ((prev_insn.insn_opcode >> OP_SH_RT)
+				     & OP_MASK_RT),
+				    MIPS_GR_REG))
+	      || (! mips_opts.mips16
+		  && (prev_pinfo & INSN_WRITE_GPR_D)
+		  && insn_uses_reg (ip,
+				    ((prev_insn.insn_opcode >> OP_SH_RD)
+				     & OP_MASK_RD),
+				    MIPS_GR_REG))
+	      || (mips_opts.mips16
+		  && (((prev_pinfo & MIPS16_INSN_WRITE_X)
+		       && insn_uses_reg (ip,
+					 ((prev_insn.insn_opcode
+					   >> MIPS16OP_SH_RX)
+					  & MIPS16OP_MASK_RX),
+					 MIPS16_REG))
+		      || ((prev_pinfo & MIPS16_INSN_WRITE_Y)
+			  && insn_uses_reg (ip,
+					    ((prev_insn.insn_opcode
+					      >> MIPS16OP_SH_RY)
+					     & MIPS16OP_MASK_RY),
+					    MIPS16_REG))
+		      || ((prev_pinfo & MIPS16_INSN_WRITE_Z)
+			  && insn_uses_reg (ip,
+					    ((prev_insn.insn_opcode
+					      >> MIPS16OP_SH_RZ)
+					     & MIPS16OP_MASK_RZ),
+					    MIPS16_REG))
+		      || ((prev_pinfo & MIPS16_INSN_WRITE_T)
+			  && insn_uses_reg (ip, TREG, MIPS_GR_REG))
+		      || ((prev_pinfo & MIPS16_INSN_WRITE_31)
+			  && insn_uses_reg (ip, RA, MIPS_GR_REG))
+		      || ((prev_pinfo & MIPS16_INSN_WRITE_GPR_Y)
+			  && insn_uses_reg (ip,
+					    MIPS16OP_EXTRACT_REG32R (prev_insn.
+								     insn_opcode),
+					    MIPS_GR_REG))))
+	      /* If the branch writes a register that the previous
+		 instruction sets, we can not swap (we know that
+		 branches write only to RD or to $31).  */
+	      || (! mips_opts.mips16
+		  && (prev_pinfo & INSN_WRITE_GPR_T)
+		  && (((pinfo & INSN_WRITE_GPR_D)
+		       && (((prev_insn.insn_opcode >> OP_SH_RT) & OP_MASK_RT)
+			   == ((ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD)))
+		      || ((pinfo & INSN_WRITE_GPR_31)
+			  && (((prev_insn.insn_opcode >> OP_SH_RT)
+			       & OP_MASK_RT)
+			      == 31))))
+	      || (! mips_opts.mips16
+		  && (prev_pinfo & INSN_WRITE_GPR_D)
+		  && (((pinfo & INSN_WRITE_GPR_D)
+		       && (((prev_insn.insn_opcode >> OP_SH_RD) & OP_MASK_RD)
+			   == ((ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD)))
+		      || ((pinfo & INSN_WRITE_GPR_31)
+			  && (((prev_insn.insn_opcode >> OP_SH_RD)
+			       & OP_MASK_RD)
+			      == 31))))
+	      || (mips_opts.mips16
+		  && (pinfo & MIPS16_INSN_WRITE_31)
+		  && ((prev_pinfo & MIPS16_INSN_WRITE_31)
+		      || ((prev_pinfo & MIPS16_INSN_WRITE_GPR_Y)
+			  && (MIPS16OP_EXTRACT_REG32R (prev_insn.insn_opcode)
+			      == RA))))
+	      /* If the branch writes a register that the previous
+		 instruction reads, we can not swap (we know that
+		 branches only write to RD or to $31).  */
+	      || (! mips_opts.mips16
+		  && (pinfo & INSN_WRITE_GPR_D)
+		  && insn_uses_reg (&prev_insn,
+				    ((ip->insn_opcode >> OP_SH_RD)
+				     & OP_MASK_RD),
+				    MIPS_GR_REG))
+	      || (! mips_opts.mips16
+		  && (pinfo & INSN_WRITE_GPR_31)
+		  && insn_uses_reg (&prev_insn, 31, MIPS_GR_REG))
+	      || (mips_opts.mips16
+		  && (pinfo & MIPS16_INSN_WRITE_31)
+		  && insn_uses_reg (&prev_insn, RA, MIPS_GR_REG))
+	      /* If we are generating embedded PIC code, the branch
+		 might be expanded into a sequence which uses $at, so
+		 we can't swap with an instruction which reads it.  */
+	      || (mips_pic == EMBEDDED_PIC
+		  && insn_uses_reg (&prev_insn, AT, MIPS_GR_REG))
+	      /* If the previous previous instruction has a load
+		 delay, and sets a register that the branch reads, we
+		 can not swap.  */
+	      || (! mips_opts.mips16
+		  && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+              /* Itbl support may require additional care here. */
+		  && ((prev_prev_insn.insn_mo->pinfo & INSN_LOAD_COPROC_DELAY)
+		      || (! gpr_interlocks
+			  && (prev_prev_insn.insn_mo->pinfo
+			      & INSN_LOAD_MEMORY_DELAY)))
+		  && insn_uses_reg (ip,
+				    ((prev_prev_insn.insn_opcode >> OP_SH_RT)
+				     & OP_MASK_RT),
+				    MIPS_GR_REG))
+	      /* If one instruction sets a condition code and the
+                 other one uses a condition code, we can not swap.  */
+	      || ((pinfo & INSN_READ_COND_CODE)
+		  && (prev_pinfo & INSN_WRITE_COND_CODE))
+	      || ((pinfo & INSN_WRITE_COND_CODE)
+		  && (prev_pinfo & INSN_READ_COND_CODE))
+	      /* If the previous instruction uses the PC, we can not
+                 swap.  */
+	      || (mips_opts.mips16
+		  && (prev_pinfo & MIPS16_INSN_READ_PC))
+	      /* If the previous instruction was extended, we can not
+                 swap.  */
+	      || (mips_opts.mips16 && prev_insn_extended)
+	      /* If the previous instruction had a fixup in mips16
+                 mode, we can not swap.  This normally means that the
+                 previous instruction was a 4 byte branch anyhow.  */
+	      || (mips_opts.mips16 && prev_insn_fixp)
+	      /* If the previous instruction is a sync, sync.l, or 
+		 sync.p, we can not swap. */
+	      || (prev_pinfo & INSN_SYNC))
+	    {
+	      /* We could do even better for unconditional branches to
+		 portions of this object file; we could pick up the
+		 instruction at the destination, put it in the delay
+		 slot, and bump the destination address.  */
+	      emit_nop ();
+	      /* Update the previous insn information.  */
+	      prev_prev_insn = *ip;
+	      prev_insn.insn_mo = &dummy_opcode;
+	    }
+	  else
+	    {
+	      /* It looks like we can actually do the swap.  */
+	      if (! mips_opts.mips16)
+		{
+		  char *prev_f;
+		  char temp[4];
+
+		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
+		  memcpy (temp, prev_f, 4);
+		  memcpy (prev_f, f, 4);
+		  memcpy (f, temp, 4);
+		  if (prev_insn_fixp)
+		    {
+		      prev_insn_fixp->fx_frag = frag_now;
+		      prev_insn_fixp->fx_where = f - frag_now->fr_literal;
+		    }
+		  if (fixp)
+		    {
+		      fixp->fx_frag = prev_insn_frag;
+		      fixp->fx_where = prev_insn_where;
+		    }
+		}
+	      else
+		{
+		  char *prev_f;
+		  char temp[2];
+
+		  assert (prev_insn_fixp == NULL);
+		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
+		  memcpy (temp, prev_f, 2);
+		  memcpy (prev_f, f, 2);
+		  if (reloc_type != BFD_RELOC_MIPS16_JMP)
+		    {
+		      assert (reloc_type == BFD_RELOC_UNUSED);
+		      memcpy (f, temp, 2);
+		    }
+		  else
+		    {
+		      memcpy (f, f + 2, 2);
+		      memcpy (f + 2, temp, 2);
+		    }
+		  if (fixp)
+		    {
+		      fixp->fx_frag = prev_insn_frag;
+		      fixp->fx_where = prev_insn_where;
+		    }
+		}
+
+	      /* Update the previous insn information; leave prev_insn
+		 unchanged.  */
+	      prev_prev_insn = *ip;
+	    }
+	  prev_insn_is_delay_slot = 1;
+
+	  /* If that was an unconditional branch, forget the previous
+	     insn information.  */
+	  if (pinfo & INSN_UNCOND_BRANCH_DELAY)
+	    {
+	      prev_prev_insn.insn_mo = &dummy_opcode;
+	      prev_insn.insn_mo = &dummy_opcode;
+	    }
+
+	  prev_insn_fixp = NULL;
+	  prev_insn_reloc_type = BFD_RELOC_UNUSED;
+	  prev_insn_extended = 0;
+	}
+      else if (pinfo & INSN_COND_BRANCH_LIKELY)
+	{
+	  /* We don't yet optimize a branch likely.  What we should do
+	     is look at the target, copy the instruction found there
+	     into the delay slot, and increment the branch to jump to
+	     the next instruction.  */
+	  emit_nop ();
+	  /* Update the previous insn information.  */
+	  prev_prev_insn = *ip;
+	  prev_insn.insn_mo = &dummy_opcode;
+	  prev_insn_fixp = NULL;
+	  prev_insn_reloc_type = BFD_RELOC_UNUSED;
+	  prev_insn_extended = 0;
+	}
+      else
+	{
+	  /* Update the previous insn information.  */
+	  if (nops > 0)
+	    prev_prev_insn.insn_mo = &dummy_opcode;
+	  else
+	    prev_prev_insn = prev_insn;
+	  prev_insn = *ip;
+
+	  /* Any time we see a branch, we always fill the delay slot
+	     immediately; since this insn is not a branch, we know it
+	     is not in a delay slot.  */
+	  prev_insn_is_delay_slot = 0;
+
+	  prev_insn_fixp = fixp;
+	  prev_insn_reloc_type = reloc_type;
+	  if (mips_opts.mips16)
+	    prev_insn_extended = (ip->use_extend
+				  || reloc_type > BFD_RELOC_UNUSED);
+	}
+
+      prev_prev_insn_unreordered = prev_insn_unreordered;
+      prev_insn_unreordered = 0;
+      prev_insn_frag = frag_now;
+      prev_insn_where = f - frag_now->fr_literal;
+      prev_insn_valid = 1;
+    }
+  else if (place == NULL)
+    {
+      /* We need to record a bit of information even when we are not
+         reordering, in order to determine the base address for mips16
+         PC relative relocs.  */
+      prev_prev_insn = prev_insn;
+      prev_insn = *ip;
+      prev_insn_reloc_type = reloc_type;
+      prev_prev_insn_unreordered = prev_insn_unreordered;
+      prev_insn_unreordered = 1;
+    }
+
+  /* We just output an insn, so the next one doesn't have a label.  */
+  mips_clear_insn_labels ();
+
+  /* We must ensure that a fixup associated with an unmatched %hi
+     reloc does not become a variant frag.  Otherwise, the
+     rearrangement of %hi relocs in frob_file may confuse
+     tc_gen_reloc.  */
+  if (unmatched_hi)
+    {
+      frag_wane (frag_now);
+      frag_new (0);
+    }
+}
+
+/* This function forgets that there was any previous instruction or
+   label.  If PRESERVE is non-zero, it remembers enough information to
+   know whether nops are needed before a noreorder section. */
+
+static void
+mips_no_prev_insn (preserve)
+     int preserve;
+{
+  if (! preserve)
+    {
+      prev_insn.insn_mo = &dummy_opcode;
+      prev_prev_insn.insn_mo = &dummy_opcode;
+      prev_nop_frag = NULL;
+      prev_nop_frag_holds = 0;
+      prev_nop_frag_required = 0;
+      prev_nop_frag_since = 0;
+    }
+  prev_insn_valid = 0;
+  prev_insn_is_delay_slot = 0;
+  prev_insn_unreordered = 0;
+  prev_insn_extended = 0;
+  prev_insn_reloc_type = BFD_RELOC_UNUSED;
+  prev_prev_insn_unreordered = 0;
+  mips_clear_insn_labels ();
+}
+
+/* This function must be called whenever we turn on noreorder or emit
+   something other than instructions.  It inserts any NOPS which might
+   be needed by the previous instruction, and clears the information
+   kept for the previous instructions.  The INSNS parameter is true if
+   instructions are to follow. */
+
+static void
+mips_emit_delays (insns)
+     boolean insns;
+{
+  if (! mips_opts.noreorder)
+    {
+      int nops;
+
+      nops = 0;
+      if ((! mips_opts.mips16
+	   && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+	   && (! cop_interlocks
+               && (prev_insn.insn_mo->pinfo
+                   & (INSN_LOAD_COPROC_DELAY
+                      | INSN_COPROC_MOVE_DELAY
+                      | INSN_WRITE_COND_CODE))))
+	  || (! hilo_interlocks
+	      && (prev_insn.insn_mo->pinfo
+		  & (INSN_READ_LO
+		     | INSN_READ_HI)))
+	  || (! mips_opts.mips16
+	      && ! gpr_interlocks
+	      && (prev_insn.insn_mo->pinfo 
+                  & INSN_LOAD_MEMORY_DELAY))
+	  || (! mips_opts.mips16
+	      && mips_opts.isa == 1
+	      && (prev_insn.insn_mo->pinfo
+		  & INSN_COPROC_MEMORY_DELAY)))
+	{
+          /* Itbl support may require additional care here. */
+	  ++nops;
+	  if ((! mips_opts.mips16
+	       && ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+	       && (! cop_interlocks
+                   && prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE))
+	      || (! hilo_interlocks
+		  && ((prev_insn.insn_mo->pinfo & INSN_READ_HI)
+		      || (prev_insn.insn_mo->pinfo & INSN_READ_LO))))
+	    ++nops;
+
+	  if (prev_insn_unreordered)
+	    nops = 0;
+	}
+      else if ((! mips_opts.mips16
+		&& ISA_HAS_COPROC_DELAYS (mips_opts.isa)
+		&& (! cop_interlocks
+                    && prev_prev_insn.insn_mo->pinfo & INSN_WRITE_COND_CODE))
+	       || (! hilo_interlocks
+		   && ((prev_prev_insn.insn_mo->pinfo & INSN_READ_HI)
+		       || (prev_prev_insn.insn_mo->pinfo & INSN_READ_LO))))
+	{
+          /* Itbl support may require additional care here. */
+	  if (! prev_prev_insn_unreordered)
+	    ++nops;
+	}
+
+      if (nops > 0)
+	{
+	  struct insn_label_list *l;
+
+	  if (insns)
+	    {
+	      /* Record the frag which holds the nop instructions, so
+                 that we can remove them if we don't need them.  */
+	      frag_grow (mips_opts.mips16 ? nops * 2 : nops * 4);
+	      prev_nop_frag = frag_now;
+	      prev_nop_frag_holds = nops;
+	      prev_nop_frag_required = 0;
+	      prev_nop_frag_since = 0;
+	    }
+
+	  for (; nops > 0; --nops)
+	    emit_nop ();
+
+	  if (insns)
+	    {
+	      /* Move on to a new frag, so that it is safe to simply
+                 decrease the size of prev_nop_frag. */
+	      frag_wane (frag_now);
+	      frag_new (0);
+	    }
+
+	  for (l = insn_labels; l != NULL; l = l->next)
+	    {
+	      assert (S_GET_SEGMENT (l->label) == now_seg);
+	      symbol_set_frag (l->label, frag_now);
+	      S_SET_VALUE (l->label, (valueT) frag_now_fix ());
+	      /* mips16 text labels are stored as odd.  */
+	      if (mips_opts.mips16)
+		S_SET_VALUE (l->label, S_GET_VALUE (l->label) + 1);
+	    }
+	}
+    }
+
+  /* Mark instruction labels in mips16 mode.  */
+  if (mips_opts.mips16 && insns)
+    mips16_mark_labels ();
+
+  mips_no_prev_insn (insns);
+}
+
+/* Build an instruction created by a macro expansion.  This is passed
+   a pointer to the count of instructions created so far, an
+   expression, the name of the instruction to build, an operand format
+   string, and corresponding arguments.  */
+
+#ifdef USE_STDARG
+static void
+macro_build (char *place,
+	     int *counter,
+	     expressionS * ep,
+	     const char *name,
+	     const char *fmt,
+	     ...)
+#else
+static void
+macro_build (place, counter, ep, name, fmt, va_alist)
+     char *place;
+     int *counter;
+     expressionS *ep;
+     const char *name;
+     const char *fmt;
+     va_dcl
+#endif
+{
+  struct mips_cl_insn insn;
+  bfd_reloc_code_real_type r;
+  va_list args;
+
+#ifdef USE_STDARG
+  va_start (args, fmt);
+#else
+  va_start (args);
+#endif
+
+  /*
+   * If the macro is about to expand into a second instruction,
+   * print a warning if needed. We need to pass ip as a parameter
+   * to generate a better warning message here...
+   */
+  if (mips_opts.warn_about_macros && place == NULL && *counter == 1)
+    as_warn (_("Macro instruction expanded into multiple instructions"));
+
+  if (place == NULL)
+    *counter += 1;		/* bump instruction counter */
+
+  if (mips_opts.mips16)
+    {
+      mips16_macro_build (place, counter, ep, name, fmt, args);
+      va_end (args);
+      return;
+    }
+
+  r = BFD_RELOC_UNUSED;
+  insn.insn_mo = (struct mips_opcode *) hash_find (op_hash, name);
+  assert (insn.insn_mo);
+  assert (strcmp (name, insn.insn_mo->name) == 0);
+
+  /* Search until we get a match for NAME.  */
+  while (1)
+    {
+      if (strcmp (fmt, insn.insn_mo->args) == 0
+	  && insn.insn_mo->pinfo != INSN_MACRO
+	  && OPCODE_IS_MEMBER (insn.insn_mo, mips_opts.isa, mips_cpu, 
+			       mips_gp32)
+	  && (mips_cpu != 4650 || (insn.insn_mo->pinfo & FP_D) == 0))
+	break;
+
+      ++insn.insn_mo;
+      assert (insn.insn_mo->name);
+      assert (strcmp (name, insn.insn_mo->name) == 0);
+    }
+
+  insn.insn_opcode = insn.insn_mo->match;
+  for (;;)
+    {
+      switch (*fmt++)
+	{
+	case '\0':
+	  break;
+
+	case ',':
+	case '(':
+	case ')':
+	  continue;
+
+	case 't':
+	case 'w':
+	case 'E':
+	  insn.insn_opcode |= va_arg (args, int) << 16;
+	  continue;
+
+	case 'c':
+	case 'T':
+	case 'W':
+	  insn.insn_opcode |= va_arg (args, int) << 16;
+	  continue;
+
+	case 'd':
+	case 'G':
+	  insn.insn_opcode |= va_arg (args, int) << 11;
+	  continue;
+
+	case 'V':
+	case 'S':
+	  insn.insn_opcode |= va_arg (args, int) << 11;
+	  continue;
+
+	case 'z':
+	  continue;
+
+	case '<':
+	  insn.insn_opcode |= va_arg (args, int) << 6;
+	  continue;
+
+	case 'D':
+	  insn.insn_opcode |= va_arg (args, int) << 6;
+	  continue;
+
+	case 'B':
+	  insn.insn_opcode |= va_arg (args, int) << 6;
+	  continue;
+
+	case 'q':
+	  insn.insn_opcode |= va_arg (args, int) << 6;
+	  continue;
+
+	case 'b':
+	case 's':
+	case 'r':
+	case 'v':
+	  insn.insn_opcode |= va_arg (args, int) << 21;
+	  continue;
+
+	case 'i':
+	case 'j':
+	case 'o':
+	  r = (bfd_reloc_code_real_type) va_arg (args, int);
+	  assert (r == BFD_RELOC_MIPS_GPREL
+		  || r == BFD_RELOC_MIPS_LITERAL
+		  || r == BFD_RELOC_LO16
+		  || r == BFD_RELOC_MIPS_GOT16
+		  || r == BFD_RELOC_MIPS_CALL16
+		  || r == BFD_RELOC_MIPS_GOT_LO16
+		  || r == BFD_RELOC_MIPS_CALL_LO16
+		  || (ep->X_op == O_subtract
+		      && r == BFD_RELOC_PCREL_LO16));
+	  continue;
+
+	case 'u':
+	  r = (bfd_reloc_code_real_type) va_arg (args, int);
+	  assert (ep != NULL
+		  && (ep->X_op == O_constant
+		      || (ep->X_op == O_symbol
+			  && (r == BFD_RELOC_HI16_S
+			      || r == BFD_RELOC_HI16
+			      || r == BFD_RELOC_MIPS_GOT_HI16
+			      || r == BFD_RELOC_MIPS_CALL_HI16))
+		      || (ep->X_op == O_subtract
+			  && r == BFD_RELOC_PCREL_HI16_S)));
+	  if (ep->X_op == O_constant)
+	    {
+	      insn.insn_opcode |= (ep->X_add_number >> 16) & 0xffff;
+	      ep = NULL;
+	      r = BFD_RELOC_UNUSED;
+	    }
+	  continue;
+
+	case 'p':
+	  assert (ep != NULL);
+	  /*
+	   * This allows macro() to pass an immediate expression for
+	   * creating short branches without creating a symbol.
+	   * Note that the expression still might come from the assembly
+	   * input, in which case the value is not checked for range nor
+	   * is a relocation entry generated (yuck).
+	   */
+	  if (ep->X_op == O_constant)
+	    {
+	      insn.insn_opcode |= (ep->X_add_number >> 2) & 0xffff;
+	      ep = NULL;
+	    }
+	  else
+	    r = BFD_RELOC_16_PCREL_S2;
+	  continue;
+
+	case 'a':
+	  assert (ep != NULL);
+	  r = BFD_RELOC_MIPS_JMP;
+	  continue;
+
+	case 'C':
+	  insn.insn_opcode |= va_arg (args, unsigned long);
+	  continue;
+
+	default:
+	  internalError ();
+	}
+      break;
+    }
+  va_end (args);
+  assert (r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);
+
+  append_insn (place, &insn, ep, r, false);
+}
+
+static void
+mips16_macro_build (place, counter, ep, name, fmt, args)
+     char *place;
+     int *counter;
+     expressionS *ep;
+     const char *name;
+     const char *fmt;
+     va_list args;
+{
+  struct mips_cl_insn insn;
+  bfd_reloc_code_real_type r;
+
+  r = BFD_RELOC_UNUSED;
+  insn.insn_mo = (struct mips_opcode *) hash_find (mips16_op_hash, name);
+  assert (insn.insn_mo);
+  assert (strcmp (name, insn.insn_mo->name) == 0);
+
+  while (strcmp (fmt, insn.insn_mo->args) != 0
+	 || insn.insn_mo->pinfo == INSN_MACRO)
+    {
+      ++insn.insn_mo;
+      assert (insn.insn_mo->name);
+      assert (strcmp (name, insn.insn_mo->name) == 0);
+    }
+
+  insn.insn_opcode = insn.insn_mo->match;
+  insn.use_extend = false;
+
+  for (;;)
+    {
+      int c;
+
+      c = *fmt++;
+      switch (c)
+	{
+	case '\0':
+	  break;
+
+	case ',':
+	case '(':
+	case ')':
+	  continue;
+
+	case 'y':
+	case 'w':
+	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_RY;
+	  continue;
+
+	case 'x':
+	case 'v':
+	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_RX;
+	  continue;
+
+	case 'z':
+	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_RZ;
+	  continue;
+
+	case 'Z':
+	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_MOVE32Z;
+	  continue;
+
+	case '0':
+	case 'S':
+	case 'P':
+	case 'R':
+	  continue;
+
+	case 'X':
+	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_REGR32;
+	  continue;
+
+	case 'Y':
+	  {
+	    int regno;
+
+	    regno = va_arg (args, int);
+	    regno = ((regno & 7) << 2) | ((regno & 0x18) >> 3);
+	    insn.insn_opcode |= regno << MIPS16OP_SH_REG32R;
+	  }
+	  continue;
+
+	case '<':
+	case '>':
+	case '4':
+	case '5':
+	case 'H':
+	case 'W':
+	case 'D':
+	case 'j':
+	case '8':
+	case 'V':
+	case 'C':
+	case 'U':
+	case 'k':
+	case 'K':
+	case 'p':
+	case 'q':
+	  {
+	    assert (ep != NULL);
+
+	    if (ep->X_op != O_constant)
+	      r = BFD_RELOC_UNUSED + c;
+	    else
+	      {
+		mips16_immed ((char *) NULL, 0, c, ep->X_add_number, false,
+			      false, false, &insn.insn_opcode,
+			      &insn.use_extend, &insn.extend);
+		ep = NULL;
+		r = BFD_RELOC_UNUSED;
+	      }
+	  }
+	  continue;
+
+	case '6':
+	  insn.insn_opcode |= va_arg (args, int) << MIPS16OP_SH_IMM6;
+	  continue;
+	}
+
+      break;
+    }
+
+  assert (r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);
+
+  append_insn (place, &insn, ep, r, false);
+}
+
+/*
+ * Generate a "lui" instruction.
+ */
+static void
+macro_build_lui (place, counter, ep, regnum)
+     char *place;
+     int *counter;
+     expressionS *ep;
+     int regnum;
+{
+  expressionS high_expr;
+  struct mips_cl_insn insn;
+  bfd_reloc_code_real_type r;
+  CONST char *name = "lui";
+  CONST char *fmt = "t,u";
+
+  assert (! mips_opts.mips16);
+
+  if (place == NULL)
+    high_expr = *ep;
+  else
+    {
+      high_expr.X_op = O_constant;
+      high_expr.X_add_number = ep->X_add_number;
+    }
+
+  if (high_expr.X_op == O_constant)
+    {
+      /* we can compute the instruction now without a relocation entry */
+      if (high_expr.X_add_number & 0x8000)
+	high_expr.X_add_number += 0x10000;
+      high_expr.X_add_number =
+	((unsigned long) high_expr.X_add_number >> 16) & 0xffff;
+      r = BFD_RELOC_UNUSED;
+    }
+  else
+    {
+      assert (ep->X_op == O_symbol);
+      /* _gp_disp is a special case, used from s_cpload.  */
+      assert (mips_pic == NO_PIC
+	      || strcmp (S_GET_NAME (ep->X_add_symbol), "_gp_disp") == 0);
+      r = BFD_RELOC_HI16_S;
+    }
+
+  /*
+   * If the macro is about to expand into a second instruction,
+   * print a warning if needed. We need to pass ip as a parameter
+   * to generate a better warning message here...
+   */
+  if (mips_opts.warn_about_macros && place == NULL && *counter == 1)
+    as_warn (_("Macro instruction expanded into multiple instructions"));
+
+  if (place == NULL)
+    *counter += 1;		/* bump instruction counter */
+
+  insn.insn_mo = (struct mips_opcode *) hash_find (op_hash, name);
+  assert (insn.insn_mo);
+  assert (strcmp (name, insn.insn_mo->name) == 0);
+  assert (strcmp (fmt, insn.insn_mo->args) == 0);
+
+  insn.insn_opcode = insn.insn_mo->match | (regnum << OP_SH_RT);
+  if (r == BFD_RELOC_UNUSED)
+    {
+      insn.insn_opcode |= high_expr.X_add_number;
+      append_insn (place, &insn, NULL, r, false);
+    }
+  else
+    append_insn (place, &insn, &high_expr, r, false);
+}
+
+/*			set_at()
+ * Generates code to set the $at register to true (one)
+ * if reg is less than the immediate expression.
+ */
+static void
+set_at (counter, reg, unsignedp)
+     int *counter;
+     int reg;
+     int unsignedp;
+{
+  if (imm_expr.X_op == O_constant
+      && imm_expr.X_add_number >= -0x8000
+      && imm_expr.X_add_number < 0x8000)
+    macro_build ((char *) NULL, counter, &imm_expr,
+		 unsignedp ? "sltiu" : "slti",
+		 "t,r,j", AT, reg, (int) BFD_RELOC_LO16);
+  else
+    {
+      load_register (counter, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, counter, NULL,
+		   unsignedp ? "sltu" : "slt",
+		   "d,v,t", AT, reg, AT);
+    }
+}
+
+/* Warn if an expression is not a constant.  */
+
+static void
+check_absolute_expr (ip, ex)
+     struct mips_cl_insn *ip;
+     expressionS *ex;
+{
+  if (ex->X_op == O_big)
+    as_bad (_("unsupported large constant"));
+  else if (ex->X_op != O_constant)
+    as_bad (_("Instruction %s requires absolute expression"), ip->insn_mo->name);
+}
+
+/* Count the leading zeroes by performing a binary chop. This is a
+   bulky bit of source, but performance is a LOT better for the
+   majority of values than a simple loop to count the bits:
+       for (lcnt = 0; (lcnt < 32); lcnt++)
+         if ((v) & (1 << (31 - lcnt)))
+           break;
+  However it is not code size friendly, and the gain will drop a bit
+  on certain cached systems.
+*/
+#define COUNT_TOP_ZEROES(v)             \
+  (((v) & ~0xffff) == 0                 \
+   ? ((v) & ~0xff) == 0                 \
+     ? ((v) & ~0xf) == 0                \
+       ? ((v) & ~0x3) == 0              \
+         ? ((v) & ~0x1) == 0            \
+           ? !(v)                       \
+             ? 32                       \
+             : 31                       \
+           : 30                         \
+         : ((v) & ~0x7) == 0            \
+           ? 29                         \
+           : 28                         \
+       : ((v) & ~0x3f) == 0             \
+         ? ((v) & ~0x1f) == 0           \
+           ? 27                         \
+           : 26                         \
+         : ((v) & ~0x7f) == 0           \
+           ? 25                         \
+           : 24                         \
+     : ((v) & ~0xfff) == 0              \
+       ? ((v) & ~0x3ff) == 0            \
+         ? ((v) & ~0x1ff) == 0          \
+           ? 23                         \
+           : 22                         \
+         : ((v) & ~0x7ff) == 0          \
+           ? 21                         \
+           : 20                         \
+       : ((v) & ~0x3fff) == 0           \
+         ? ((v) & ~0x1fff) == 0         \
+           ? 19                         \
+           : 18                         \
+         : ((v) & ~0x7fff) == 0         \
+           ? 17                         \
+           : 16                         \
+   : ((v) & ~0xffffff) == 0             \
+     ? ((v) & ~0xfffff) == 0            \
+       ? ((v) & ~0x3ffff) == 0          \
+         ? ((v) & ~0x1ffff) == 0        \
+           ? 15                         \
+           : 14                         \
+         : ((v) & ~0x7ffff) == 0        \
+           ? 13                         \
+           : 12                         \
+       : ((v) & ~0x3fffff) == 0         \
+         ? ((v) & ~0x1fffff) == 0       \
+           ? 11                         \
+           : 10                         \
+         : ((v) & ~0x7fffff) == 0       \
+           ? 9                          \
+           : 8                          \
+     : ((v) & ~0xfffffff) == 0          \
+       ? ((v) & ~0x3ffffff) == 0        \
+         ? ((v) & ~0x1ffffff) == 0      \
+           ? 7                          \
+           : 6                          \
+         : ((v) & ~0x7ffffff) == 0      \
+           ? 5                          \
+           : 4                          \
+       : ((v) & ~0x3fffffff) == 0       \
+         ? ((v) & ~0x1fffffff) == 0     \
+           ? 3                          \
+           : 2                          \
+         : ((v) & ~0x7fffffff) == 0     \
+           ? 1                          \
+           : 0)
+
+/*			load_register()
+ *  This routine generates the least number of instructions neccessary to load
+ *  an absolute expression value into a register.
+ */
+static void
+load_register (counter, reg, ep, dbl)
+     int *counter;
+     int reg;
+     expressionS *ep;
+     int dbl;
+{
+  int freg;
+  expressionS hi32, lo32;
+
+  if (ep->X_op != O_big)
+    {
+      assert (ep->X_op == O_constant);
+      if (ep->X_add_number < 0x8000
+	  && (ep->X_add_number >= 0
+	      || (ep->X_add_number >= -0x8000
+		  && (! dbl
+		      || ! ep->X_unsigned
+		      || sizeof (ep->X_add_number) > 4))))
+	{
+	  /* We can handle 16 bit signed values with an addiu to
+	     $zero.  No need to ever use daddiu here, since $zero and
+	     the result are always correct in 32 bit mode.  */
+	  macro_build ((char *) NULL, counter, ep, "addiu", "t,r,j", reg, 0,
+		       (int) BFD_RELOC_LO16);
+	  return;
+	}
+      else if (ep->X_add_number >= 0 && ep->X_add_number < 0x10000)
+	{
+	  /* We can handle 16 bit unsigned values with an ori to
+             $zero.  */
+	  macro_build ((char *) NULL, counter, ep, "ori", "t,r,i", reg, 0,
+		       (int) BFD_RELOC_LO16);
+	  return;
+	}
+      else if ((((ep->X_add_number &~ (offsetT) 0x7fffffff) == 0
+		 || ((ep->X_add_number &~ (offsetT) 0x7fffffff)
+		     == ~ (offsetT) 0x7fffffff))
+		&& (! dbl
+		    || ! ep->X_unsigned
+		    || sizeof (ep->X_add_number) > 4
+		    || (ep->X_add_number & 0x80000000) == 0))
+	       || ((! ISA_HAS_64BIT_REGS (mips_opts.isa) || ! dbl)
+		   && (ep->X_add_number &~ (offsetT) 0xffffffff) == 0)
+	       || (! ISA_HAS_64BIT_REGS (mips_opts.isa)
+		   && ! dbl
+		   && ((ep->X_add_number &~ (offsetT) 0xffffffff)
+		       == ~ (offsetT) 0xffffffff)))
+	{
+	  /* 32 bit values require an lui.  */
+	  macro_build ((char *) NULL, counter, ep, "lui", "t,u", reg,
+		       (int) BFD_RELOC_HI16);
+	  if ((ep->X_add_number & 0xffff) != 0)
+	    macro_build ((char *) NULL, counter, ep, "ori", "t,r,i", reg, reg,
+			 (int) BFD_RELOC_LO16);
+	  return;
+	}
+    }
+
+  /* The value is larger than 32 bits.  */
+
+  if (! ISA_HAS_64BIT_REGS (mips_opts.isa))
+    {
+      as_bad (_("Number larger than 32 bits"));
+      macro_build ((char *) NULL, counter, ep, "addiu", "t,r,j", reg, 0,
+		   (int) BFD_RELOC_LO16);
+      return;
+    }
+
+  if (ep->X_op != O_big)
+    {
+      hi32 = *ep;
+      hi32.X_add_number = (valueT) hi32.X_add_number >> 16;
+      hi32.X_add_number = (valueT) hi32.X_add_number >> 16;
+      hi32.X_add_number &= 0xffffffff;
+      lo32 = *ep;
+      lo32.X_add_number &= 0xffffffff;
+    }
+  else
+    {
+      assert (ep->X_add_number > 2);
+      if (ep->X_add_number == 3)
+	generic_bignum[3] = 0;
+      else if (ep->X_add_number > 4)
+	as_bad (_("Number larger than 64 bits"));
+      lo32.X_op = O_constant;
+      lo32.X_add_number = generic_bignum[0] + (generic_bignum[1] << 16);
+      hi32.X_op = O_constant;
+      hi32.X_add_number = generic_bignum[2] + (generic_bignum[3] << 16);
+    }
+
+  if (hi32.X_add_number == 0)
+    freg = 0;
+  else
+    {
+      int shift, bit;
+      unsigned long hi, lo;
+
+      if (hi32.X_add_number == 0xffffffff)
+        {
+          if ((lo32.X_add_number & 0xffff8000) == 0xffff8000)
+            {
+              macro_build ((char *) NULL, counter, &lo32, "addiu", "t,r,j",
+			   reg, 0, (int) BFD_RELOC_LO16);
+              return;
+            }
+          if (lo32.X_add_number & 0x80000000)
+            {
+              macro_build ((char *) NULL, counter, &lo32, "lui", "t,u", reg,
+                           (int) BFD_RELOC_HI16);
+	      if (lo32.X_add_number & 0xffff)
+		macro_build ((char *) NULL, counter, &lo32, "ori", "t,r,i",
+			     reg, reg, (int) BFD_RELOC_LO16);
+              return;
+            }
+        }
+
+      /* Check for 16bit shifted constant.  We know that hi32 is
+         non-zero, so start the mask on the first bit of the hi32
+         value.  */
+      shift = 17;
+      do
+       {
+	 unsigned long himask, lomask;
+
+	 if (shift < 32)
+	   {
+	     himask = 0xffff >> (32 - shift);
+	     lomask = (0xffff << shift) & 0xffffffff;
+	   }
+	 else
+	   {
+	     himask = 0xffff << (shift - 32);
+	     lomask = 0;
+	   }
+	 if ((hi32.X_add_number & ~ (offsetT) himask) == 0
+	     && (lo32.X_add_number & ~ (offsetT) lomask) == 0)
+	   {
+	     expressionS tmp;
+
+	     tmp.X_op = O_constant;
+	     if (shift < 32)
+	       tmp.X_add_number = ((hi32.X_add_number << (32 - shift))
+				   | (lo32.X_add_number >> shift));
+	     else
+	       tmp.X_add_number = hi32.X_add_number >> (shift - 32);
+	     macro_build ((char *) NULL, counter, &tmp, "ori", "t,r,i", reg, 0,
+			  (int) BFD_RELOC_LO16);
+	     macro_build ((char *) NULL, counter, NULL,
+			  (shift >= 32) ? "dsll32" : "dsll",
+			  "d,w,<", reg, reg,
+			  (shift >= 32) ? shift - 32 : shift);
+	     return;
+	   }
+         shift++;
+       } while (shift <= (64 - 16));
+
+      /* Find the bit number of the lowest one bit, and store the
+         shifted value in hi/lo.  */
+      hi = (unsigned long) (hi32.X_add_number & 0xffffffff);
+      lo = (unsigned long) (lo32.X_add_number & 0xffffffff);
+      if (lo != 0)
+	{
+	  bit = 0;
+	  while ((lo & 1) == 0)
+	    {
+	      lo >>= 1;
+	      ++bit;
+	    }
+	  lo |= (hi & (((unsigned long) 1 << bit) - 1)) << (32 - bit);
+	  hi >>= bit;
+	}
+      else
+	{
+	  bit = 32;
+	  while ((hi & 1) == 0)
+	    {
+	      hi >>= 1;
+	      ++bit;
+	    }
+	  lo = hi;
+	  hi = 0;
+	}
+
+      /* Optimize if the shifted value is a (power of 2) - 1.  */
+      if ((hi == 0 && ((lo + 1) & lo) == 0)
+	  || (lo == 0xffffffff && ((hi + 1) & hi) == 0))
+        {
+          shift = COUNT_TOP_ZEROES ((unsigned int) hi32.X_add_number);
+	  if (shift != 0)
+            {
+	      expressionS tmp;
+
+	      /* This instruction will set the register to be all
+                 ones.  */
+              tmp.X_op = O_constant;
+              tmp.X_add_number = (offsetT) -1;
+              macro_build ((char *) NULL, counter, &tmp, "addiu", "t,r,j",
+			   reg, 0, (int) BFD_RELOC_LO16);
+              if (bit != 0)
+                {
+                  bit += shift;
+                  macro_build ((char *) NULL, counter, NULL,
+                               (bit >= 32) ? "dsll32" : "dsll",
+                               "d,w,<", reg, reg,
+                               (bit >= 32) ? bit - 32 : bit);
+                }
+              macro_build ((char *) NULL, counter, NULL,
+			   (shift >= 32) ? "dsrl32" : "dsrl",
+                           "d,w,<", reg, reg,
+			   (shift >= 32) ? shift - 32 : shift);
+              return;
+            }
+        }
+
+      /* Sign extend hi32 before calling load_register, because we can
+         generally get better code when we load a sign extended value.  */
+      if ((hi32.X_add_number & 0x80000000) != 0)
+	hi32.X_add_number |= ~ (offsetT) 0xffffffff;
+      load_register (counter, reg, &hi32, 0);
+      freg = reg;
+    }
+  if ((lo32.X_add_number & 0xffff0000) == 0)
+    {
+      if (freg != 0)
+	{
+	  macro_build ((char *) NULL, counter, NULL, "dsll32", "d,w,<", reg,
+		       freg, 0);
+	  freg = reg;
+	}
+    }
+  else
+    {
+      expressionS mid16;
+
+      if ((freg == 0) && (lo32.X_add_number == 0xffffffff))
+        {
+	  macro_build ((char *) NULL, counter, &lo32, "lui", "t,u", reg,
+		       (int) BFD_RELOC_HI16);
+          macro_build ((char *) NULL, counter, NULL, "dsrl32", "d,w,<", reg,
+                       reg, 0);
+          return;
+        }
+
+      if (freg != 0)
+	{
+	  macro_build ((char *) NULL, counter, NULL, "dsll", "d,w,<", reg,
+		       freg, 16);
+	  freg = reg;
+	}
+      mid16 = lo32;
+      mid16.X_add_number >>= 16;
+      macro_build ((char *) NULL, counter, &mid16, "ori", "t,r,i", reg,
+		   freg, (int) BFD_RELOC_LO16);
+      macro_build ((char *) NULL, counter, NULL, "dsll", "d,w,<", reg,
+		   reg, 16);
+      freg = reg;
+    }
+  if ((lo32.X_add_number & 0xffff) != 0)
+    macro_build ((char *) NULL, counter, &lo32, "ori", "t,r,i", reg, freg,
+		 (int) BFD_RELOC_LO16);
+}
+
+/* Load an address into a register.  */
+
+static void
+load_address (counter, reg, ep)
+     int *counter;
+     int reg;
+     expressionS *ep;
+{
+  char *p;
+
+  if (ep->X_op != O_constant
+      && ep->X_op != O_symbol)
+    {
+      as_bad (_("expression too complex"));
+      ep->X_op = O_constant;
+    }
+
+  if (ep->X_op == O_constant)
+    {
+      load_register (counter, reg, ep, 0);
+      return;
+    }
+
+  if (mips_pic == NO_PIC)
+    {
+      /* If this is a reference to a GP relative symbol, we want
+	   addiu	$reg,$gp,<sym>		(BFD_RELOC_MIPS_GPREL)
+	 Otherwise we want
+	   lui		$reg,<sym>		(BFD_RELOC_HI16_S)
+	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16)
+	 If we have an addend, we always use the latter form.  */
+      if ((valueT) ep->X_add_number >= MAX_GPREL_OFFSET
+          || nopic_need_relax (ep->X_add_symbol, 1))
+	p = NULL;
+      else
+	{
+	  frag_grow (20);
+	  macro_build ((char *) NULL, counter, ep,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", reg, GP, (int) BFD_RELOC_MIPS_GPREL);
+	  p = frag_var (rs_machine_dependent, 8, 0,
+			RELAX_ENCODE (4, 8, 0, 4, 0,
+				      mips_opts.warn_about_macros),
+			ep->X_add_symbol, (offsetT) 0, (char *) NULL);
+	}
+      macro_build_lui (p, counter, ep, reg);
+      if (p != NULL)
+	p += 4;
+      macro_build (p, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "addiu" : "daddiu"),
+		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
+    }
+  else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
+    {
+      expressionS ex;
+
+      /* If this is a reference to an external symbol, we want
+	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	 Otherwise we want
+	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	   nop
+	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16)
+	 If there is a constant, it must be added in after.  */
+      ex.X_add_number = ep->X_add_number;
+      ep->X_add_number = 0;
+      frag_grow (20);
+      macro_build ((char *) NULL, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "lw" : "ld"),
+		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+      if (NOP_NEEDED) 
+      macro_build ((char *) NULL, counter, (expressionS *) NULL, "nop", "");
+      p = frag_var (rs_machine_dependent, 4, 0,
+		    RELAX_ENCODE (0, 4, NOP_NEEDED ? -8 : -4, 
+		    0, 0, mips_opts.warn_about_macros),
+		    ep->X_add_symbol, (offsetT) 0, (char *) NULL);
+      macro_build (p, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "addiu" : "daddiu"),
+		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
+      if (ex.X_add_number != 0)
+	{
+	  if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
+	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
+	  ex.X_op = O_constant;
+	  macro_build ((char *) NULL, counter, &ex,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addiu" : "daddiu"),
+		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
+	}
+    }
+  else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+    {
+      expressionS ex;
+      int off;
+
+      /* This is the large GOT case.  If this is a reference to an
+	 external symbol, we want
+	   lui		$reg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
+	   addu		$reg,$reg,$gp
+	   lw		$reg,<sym>($reg)	(BFD_RELOC_MIPS_GOT_LO16)
+	 Otherwise, for a reference to a local symbol, we want
+	   lw		$reg,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	   nop
+	   addiu	$reg,$reg,<sym>		(BFD_RELOC_LO16)
+	 If there is a constant, it must be added in after.  */
+      ex.X_add_number = ep->X_add_number;
+      ep->X_add_number = 0;
+      if (reg_needs_delay (GOT_REG))
+	off = 4;
+      else
+	off = 0;
+      frag_grow (32);
+      macro_build ((char *) NULL, counter, ep, "lui", "t,u", reg,
+		   (int) BFD_RELOC_MIPS_GOT_HI16);
+      macro_build ((char *) NULL, counter, (expressionS *) NULL,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "addu" : "daddu"),
+		   "d,v,t", reg, reg, GOT_REG);
+      macro_build ((char *) NULL, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "lw" : "ld"),
+		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT_LO16, reg);
+      p = frag_var (rs_machine_dependent, 12 + off, 0,
+		    RELAX_ENCODE (12, 12 + off, off, 8 + off, 0,
+				  mips_opts.warn_about_macros),
+		    ep->X_add_symbol, (offsetT) 0, (char *) NULL);
+      if (off > 0)
+	{
+	  /* We need a nop before loading from $gp.  This special
+             check is required because the lui which starts the main
+             instruction stream does not refer to $gp, and so will not
+             insert the nop which may be required.  */
+	  macro_build (p, counter, (expressionS *) NULL, "nop", "");
+	  p += 4;
+	}
+      macro_build (p, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "lw" : "ld"),
+		   "t,o(b)", reg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+      p += 4;
+      macro_build (p, counter, (expressionS *) NULL, "nop", "");
+      p += 4;
+      macro_build (p, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "addiu" : "daddiu"),
+		   "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
+      if (ex.X_add_number != 0)
+	{
+	  if (ex.X_add_number < -0x8000 || ex.X_add_number >= 0x8000)
+	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
+	  ex.X_op = O_constant;
+	  macro_build ((char *) NULL, counter, &ex,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+		         || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addiu" : "daddiu"),
+		       "t,r,j", reg, reg, (int) BFD_RELOC_LO16);
+	}
+    }
+  else if (mips_pic == EMBEDDED_PIC)
+    {
+      /* We always do
+	   addiu	$reg,$gp,<sym>		(BFD_RELOC_MIPS_GPREL)
+	 */
+      macro_build ((char *) NULL, counter, ep,
+		   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		    ? "addiu" : "daddiu"),
+		   "t,r,j", reg, GP, (int) BFD_RELOC_MIPS_GPREL);
+    }
+  else
+    abort ();
+}
+
+/*
+ *			Build macros
+ *   This routine implements the seemingly endless macro or synthesized
+ * instructions and addressing modes in the mips assembly language. Many
+ * of these macros are simple and are similar to each other. These could
+ * probably be handled by some kind of table or grammer aproach instead of
+ * this verbose method. Others are not simple macros but are more like
+ * optimizing code generation.
+ *   One interesting optimization is when several store macros appear
+ * consecutivly that would load AT with the upper half of the same address.
+ * The ensuing load upper instructions are ommited. This implies some kind
+ * of global optimization. We currently only optimize within a single macro.
+ *   For many of the load and store macros if the address is specified as a
+ * constant expression in the first 64k of memory (ie ld $2,0x4000c) we
+ * first load register 'at' with zero and use it as the base register. The
+ * mips assembler simply uses register $zero. Just one tiny optimization
+ * we're missing.
+ */
+static void
+macro (ip)
+     struct mips_cl_insn *ip;
+{
+  register int treg, sreg, dreg, breg;
+  int tempreg;
+  int mask;
+  int icnt = 0;
+  int used_at;
+  expressionS expr1;
+  const char *s;
+  const char *s2;
+  const char *fmt;
+  int likely = 0;
+  int dbl = 0;
+  int coproc = 0;
+  int lr = 0;
+  int imm = 0;
+  offsetT maxnum;
+  int off;
+  bfd_reloc_code_real_type r;
+  char *p;
+  int hold_mips_optimize;
+
+  assert (! mips_opts.mips16);
+
+  treg = (ip->insn_opcode >> 16) & 0x1f;
+  dreg = (ip->insn_opcode >> 11) & 0x1f;
+  sreg = breg = (ip->insn_opcode >> 21) & 0x1f;
+  mask = ip->insn_mo->mask;
+
+  expr1.X_op = O_constant;
+  expr1.X_op_symbol = NULL;
+  expr1.X_add_symbol = NULL;
+  expr1.X_add_number = 1;
+
+  switch (mask)
+    {
+    case M_DABS:
+      dbl = 1;
+    case M_ABS:
+      /* bgez $a0,.+12
+	 move v0,$a0
+	 sub v0,$zero,$a0
+	 */
+
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+
+      expr1.X_add_number = 8;
+      macro_build ((char *) NULL, &icnt, &expr1, "bgez", "s,p", sreg);
+      if (dreg == sreg)
+	macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
+      else
+	macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, sreg, 0);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dsub" : "sub",
+		   "d,v,t", dreg, 0, sreg);
+
+      --mips_opts.noreorder;
+      return;
+
+    case M_ADD_I:
+      s = "addi";
+      s2 = "add";
+      goto do_addi;
+    case M_ADDU_I:
+      s = "addiu";
+      s2 = "addu";
+      goto do_addi;
+    case M_DADD_I:
+      dbl = 1;
+      s = "daddi";
+      s2 = "dadd";
+      goto do_addi;
+    case M_DADDU_I:
+      dbl = 1;
+      s = "daddiu";
+      s2 = "daddu";
+    do_addi:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= -0x8000
+	  && imm_expr.X_add_number < 0x8000)
+	{
+	  macro_build ((char *) NULL, &icnt, &imm_expr, s, "t,r,j", treg, sreg,
+		       (int) BFD_RELOC_LO16);
+	  return;
+	}
+      load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL, s2, "d,v,t", treg, sreg, AT);
+      break;
+
+    case M_AND_I:
+      s = "andi";
+      s2 = "and";
+      goto do_bit;
+    case M_OR_I:
+      s = "ori";
+      s2 = "or";
+      goto do_bit;
+    case M_NOR_I:
+      s = "";
+      s2 = "nor";
+      goto do_bit;
+    case M_XOR_I:
+      s = "xori";
+      s2 = "xor";
+    do_bit:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= 0
+	  && imm_expr.X_add_number < 0x10000)
+	{
+	  if (mask != M_NOR_I)
+	    macro_build ((char *) NULL, &icnt, &imm_expr, s, "t,r,i", treg,
+			 sreg, (int) BFD_RELOC_LO16);
+	  else
+	    {
+	      macro_build ((char *) NULL, &icnt, &imm_expr, "ori", "t,r,i",
+			   treg, sreg, (int) BFD_RELOC_LO16);
+	      macro_build ((char *) NULL, &icnt, NULL, "nor", "d,v,t",
+			   treg, treg, 0);
+	    }
+	  return;
+	}
+
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, NULL, s2, "d,v,t", treg, sreg, AT);
+      break;
+
+    case M_BEQ_I:
+      s = "beq";
+      goto beq_i;
+    case M_BEQL_I:
+      s = "beql";
+      likely = 1;
+      goto beq_i;
+    case M_BNE_I:
+      s = "bne";
+      goto beq_i;
+    case M_BNEL_I:
+      s = "bnel";
+      likely = 1;
+    beq_i:
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr, s, "s,t,p", sreg,
+		       0);
+	  return;
+	}
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, &offset_expr, s, "s,t,p", sreg, AT);
+      break;
+
+    case M_BGEL:
+      likely = 1;
+    case M_BGE:
+      if (treg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bgezl" : "bgez",
+		       "s,p", sreg);
+	  return;
+	}
+      if (sreg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "blezl" : "blez",
+		       "s,p", treg);
+	  return;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, sreg, treg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "beql" : "beq",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BGTL_I:
+      likely = 1;
+    case M_BGT_I:
+      /* check for > max integer */
+      maxnum = 0x7fffffff;
+      if (ISA_HAS_64BIT_REGS (mips_opts.isa) && sizeof (maxnum) > 4)
+	{
+	  maxnum <<= 16;
+	  maxnum |= 0xffff;
+	  maxnum <<= 16;
+	  maxnum |= 0xffff;
+	}
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= maxnum
+	  && (! ISA_HAS_64BIT_REGS (mips_opts.isa) || sizeof (maxnum) > 4))
+	{
+	do_false:
+	  /* result is always false */
+	  if (! likely)
+	    {
+	      as_warn (_("Branch %s is always false (nop)"), ip->insn_mo->name);
+	      macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
+	    }
+	  else
+	    {
+	      as_warn (_("Branch likely %s is always false"), ip->insn_mo->name);
+	      macro_build ((char *) NULL, &icnt, &offset_expr, "bnel",
+			   "s,t,p", 0, 0);
+	    }
+	  return;
+	}
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number++;
+      /* FALLTHROUGH */
+    case M_BGE_I:
+    case M_BGEL_I:
+      if (mask == M_BGEL_I)
+	likely = 1;
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bgezl" : "bgez",
+		       "s,p", sreg);
+	  return;
+	}
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bgtzl" : "bgtz",
+		       "s,p", sreg);
+	  return;
+	}
+      maxnum = 0x7fffffff;
+      if (ISA_HAS_64BIT_REGS (mips_opts.isa) && sizeof (maxnum) > 4)
+	{
+	  maxnum <<= 16;
+	  maxnum |= 0xffff;
+	  maxnum <<= 16;
+	  maxnum |= 0xffff;
+	}
+      maxnum = - maxnum - 1;
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number <= maxnum
+	  && (! ISA_HAS_64BIT_REGS (mips_opts.isa) || sizeof (maxnum) > 4))
+	{
+	do_true:
+	  /* result is always true */
+	  as_warn (_("Branch %s is always true"), ip->insn_mo->name);
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "b", "p");
+	  return;
+	}
+      set_at (&icnt, sreg, 0);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "beql" : "beq",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BGEUL:
+      likely = 1;
+    case M_BGEU:
+      if (treg == 0)
+	goto do_true;
+      if (sreg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "beql" : "beq",
+		       "s,t,p", 0, treg);
+	  return;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, sreg,
+		   treg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "beql" : "beq",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BGTUL_I:
+      likely = 1;
+    case M_BGTU_I:
+      if (sreg == 0
+	  || (! ISA_HAS_64BIT_REGS (mips_opts.isa)
+	      && imm_expr.X_op == O_constant
+	      && imm_expr.X_add_number == 0xffffffff))
+	goto do_false;
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number++;
+      /* FALLTHROUGH */
+    case M_BGEU_I:
+    case M_BGEUL_I:
+      if (mask == M_BGEUL_I)
+	likely = 1;
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	goto do_true;
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bnel" : "bne",
+		       "s,t,p", sreg, 0);
+	  return;
+	}
+      set_at (&icnt, sreg, 1);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "beql" : "beq",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BGTL:
+      likely = 1;
+    case M_BGT:
+      if (treg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bgtzl" : "bgtz",
+		       "s,p", sreg);
+	  return;
+	}
+      if (sreg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bltzl" : "bltz",
+		       "s,p", treg);
+	  return;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, treg, sreg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "bnel" : "bne",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BGTUL:
+      likely = 1;
+    case M_BGTU:
+      if (treg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bnel" : "bne",
+		       "s,t,p", sreg, 0);
+	  return;
+	}
+      if (sreg == 0)
+	goto do_false;
+      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, treg,
+		   sreg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "bnel" : "bne",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BLEL:
+      likely = 1;
+    case M_BLE:
+      if (treg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "blezl" : "blez",
+		       "s,p", sreg);
+	  return;
+	}
+      if (sreg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bgezl" : "bgez",
+		       "s,p", treg);
+	  return;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, treg, sreg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "beql" : "beq",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BLEL_I:
+      likely = 1;
+    case M_BLE_I:
+      maxnum = 0x7fffffff;
+      if (ISA_HAS_64BIT_REGS (mips_opts.isa) && sizeof (maxnum) > 4)
+	{
+	  maxnum <<= 16;
+	  maxnum |= 0xffff;
+	  maxnum <<= 16;
+	  maxnum |= 0xffff;
+	}
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= maxnum
+	  && (! ISA_HAS_64BIT_REGS (mips_opts.isa) || sizeof (maxnum) > 4))
+	goto do_true;
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number++;
+      /* FALLTHROUGH */
+    case M_BLT_I:
+    case M_BLTL_I:
+      if (mask == M_BLTL_I)
+	likely = 1;
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bltzl" : "bltz",
+		       "s,p", sreg);
+	  return;
+	}
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "blezl" : "blez",
+		       "s,p", sreg);
+	  return;
+	}
+      set_at (&icnt, sreg, 0);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "bnel" : "bne",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BLEUL:
+      likely = 1;
+    case M_BLEU:
+      if (treg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "beql" : "beq",
+		       "s,t,p", sreg, 0);
+	  return;
+	}
+      if (sreg == 0)
+	goto do_true;
+      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, treg,
+		   sreg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "beql" : "beq",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BLEUL_I:
+      likely = 1;
+    case M_BLEU_I:
+      if (sreg == 0
+	  || (! ISA_HAS_64BIT_REGS (mips_opts.isa)
+	      && imm_expr.X_op == O_constant
+	      && imm_expr.X_add_number == 0xffffffff))
+	goto do_true;
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number++;
+      /* FALLTHROUGH */
+    case M_BLTU_I:
+    case M_BLTUL_I:
+      if (mask == M_BLTUL_I)
+	likely = 1;
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	goto do_false;
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "beql" : "beq",
+		       "s,t,p", sreg, 0);
+	  return;
+	}
+      set_at (&icnt, sreg, 1);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "bnel" : "bne",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BLTL:
+      likely = 1;
+    case M_BLT:
+      if (treg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bltzl" : "bltz",
+		       "s,p", sreg);
+	  return;
+	}
+      if (sreg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bgtzl" : "bgtz",
+		       "s,p", treg);
+	  return;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", AT, sreg, treg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "bnel" : "bne",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_BLTUL:
+      likely = 1;
+    case M_BLTU:
+      if (treg == 0)
+	goto do_false;
+      if (sreg == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       likely ? "bnel" : "bne",
+		       "s,t,p", 0, treg);
+	  return;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", AT, sreg,
+		   treg);
+      macro_build ((char *) NULL, &icnt, &offset_expr,
+		   likely ? "bnel" : "bne",
+		   "s,t,p", AT, 0);
+      break;
+
+    case M_DDIV_3:
+      dbl = 1;
+    case M_DIV_3:
+      s = "mflo";
+      goto do_div3;
+    case M_DREM_3:
+      dbl = 1;
+    case M_REM_3:
+      s = "mfhi";
+    do_div3:
+      if (treg == 0)
+	{
+	  as_warn (_("Divide by zero."));
+	  if (mips_trap)
+	    macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", 0, 0);
+	  else
+	      macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
+	  return;
+	}
+
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      if (mips_trap)
+	{
+	  macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", treg, 0);
+	  macro_build ((char *) NULL, &icnt, NULL,
+		       dbl ? "ddiv" : "div",
+		       "z,s,t", sreg, treg);
+	}
+      else
+	{
+	  expr1.X_add_number = 8;
+	  macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", treg, 0);
+	  macro_build ((char *) NULL, &icnt, NULL,
+		       dbl ? "ddiv" : "div",
+		       "z,s,t", sreg, treg);
+	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
+	}
+      expr1.X_add_number = -1;
+      macro_build ((char *) NULL, &icnt, &expr1,
+		   dbl ? "daddiu" : "addiu",
+		   "t,r,j", AT, 0, (int) BFD_RELOC_LO16);
+      expr1.X_add_number = mips_trap ? (dbl ? 12 : 8) : (dbl ? 20 : 16);
+      macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", treg, AT);
+      if (dbl)
+	{
+	  expr1.X_add_number = 1;
+	  macro_build ((char *) NULL, &icnt, &expr1, "daddiu", "t,r,j", AT, 0,
+		       (int) BFD_RELOC_LO16);
+	  macro_build ((char *) NULL, &icnt, NULL, "dsll32", "d,w,<", AT, AT,
+		       31);
+	}
+      else
+	{
+	  expr1.X_add_number = 0x80000000;
+	  macro_build ((char *) NULL, &icnt, &expr1, "lui", "t,u", AT,
+		       (int) BFD_RELOC_HI16);
+	}
+      if (mips_trap)
+	{
+	  macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", sreg, AT);
+	  /* We want to close the noreorder block as soon as possible, so
+	     that later insns are available for delay slot filling.  */
+	  --mips_opts.noreorder;
+	}
+      else
+	{
+	  expr1.X_add_number = 8;
+	  macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", sreg, AT);
+	  macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
+
+	  /* We want to close the noreorder block as soon as possible, so
+	     that later insns are available for delay slot filling.  */
+	  --mips_opts.noreorder;
+
+	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
+	}
+      macro_build ((char *) NULL, &icnt, NULL, s, "d", dreg);
+      break;
+
+    case M_DIV_3I:
+      s = "div";
+      s2 = "mflo";
+      goto do_divi;
+    case M_DIVU_3I:
+      s = "divu";
+      s2 = "mflo";
+      goto do_divi;
+    case M_REM_3I:
+      s = "div";
+      s2 = "mfhi";
+      goto do_divi;
+    case M_REMU_3I:
+      s = "divu";
+      s2 = "mfhi";
+      goto do_divi;
+    case M_DDIV_3I:
+      dbl = 1;
+      s = "ddiv";
+      s2 = "mflo";
+      goto do_divi;
+    case M_DDIVU_3I:
+      dbl = 1;
+      s = "ddivu";
+      s2 = "mflo";
+      goto do_divi;
+    case M_DREM_3I:
+      dbl = 1;
+      s = "ddiv";
+      s2 = "mfhi";
+      goto do_divi;
+    case M_DREMU_3I:
+      dbl = 1;
+      s = "ddivu";
+      s2 = "mfhi";
+    do_divi:
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	{
+	  as_warn (_("Divide by zero."));
+	  if (mips_trap)
+	    macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", 0, 0);
+	  else
+	      macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
+	  return;
+	}
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 1)
+	{
+	  if (strcmp (s2, "mflo") == 0)
+	    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg,
+			 sreg);
+	  else
+	    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, 0);
+	  return;
+	}
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number == -1
+	  && s[strlen (s) - 1] != 'u')
+	{
+	  if (strcmp (s2, "mflo") == 0)
+	    {
+	      if (dbl)
+		macro_build ((char *) NULL, &icnt, NULL, "dneg", "d,w", dreg,
+			     sreg);
+	      else
+		macro_build ((char *) NULL, &icnt, NULL, "neg", "d,w", dreg,
+			     sreg);
+	    }
+	  else
+	    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, 0);
+	  return;
+	}
+
+      load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL, s, "z,s,t", sreg, AT);
+      macro_build ((char *) NULL, &icnt, NULL, s2, "d", dreg);
+      break;
+
+    case M_DIVU_3:
+      s = "divu";
+      s2 = "mflo";
+      goto do_divu3;
+    case M_REMU_3:
+      s = "divu";
+      s2 = "mfhi";
+      goto do_divu3;
+    case M_DDIVU_3:
+      s = "ddivu";
+      s2 = "mflo";
+      goto do_divu3;
+    case M_DREMU_3:
+      s = "ddivu";
+      s2 = "mfhi";
+    do_divu3:
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      if (mips_trap)
+	{
+	  macro_build ((char *) NULL, &icnt, NULL, "teq", "s,t", treg, 0);
+	  macro_build ((char *) NULL, &icnt, NULL, s, "z,s,t", sreg, treg);
+	  /* We want to close the noreorder block as soon as possible, so
+	     that later insns are available for delay slot filling.  */
+	  --mips_opts.noreorder;
+	}
+      else
+	{
+	  expr1.X_add_number = 8;
+	  macro_build ((char *) NULL, &icnt, &expr1, "bne", "s,t,p", treg, 0);
+	  macro_build ((char *) NULL, &icnt, NULL, s, "z,s,t", sreg, treg);
+
+	  /* We want to close the noreorder block as soon as possible, so
+	     that later insns are available for delay slot filling.  */
+	  --mips_opts.noreorder;
+	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 7);
+	}
+      macro_build ((char *) NULL, &icnt, NULL, s2, "d", dreg);
+      return;
+
+    case M_DLA_AB:
+      dbl = 1;
+    case M_LA_AB:
+      /* Load the address of a symbol into a register.  If breg is not
+	 zero, we then add a base register to it.  */
+
+      /* When generating embedded PIC code, we permit expressions of
+	 the form
+	   la	$4,foo-bar
+	 where bar is an address in the current section.  These are used
+	 when getting the addresses of functions.  We don't permit
+	 X_add_number to be non-zero, because if the symbol is
+	 external the relaxing code needs to know that any addend is
+	 purely the offset to X_op_symbol.  */
+      if (mips_pic == EMBEDDED_PIC
+	  && offset_expr.X_op == O_subtract
+	  && (symbol_constant_p (offset_expr.X_op_symbol)
+	      ? S_GET_SEGMENT (offset_expr.X_op_symbol) == now_seg
+	      : (symbol_equated_p (offset_expr.X_op_symbol)
+		 && (S_GET_SEGMENT
+		     (symbol_get_value_expression (offset_expr.X_op_symbol)
+		      ->X_add_symbol)
+		     == now_seg)))
+	  && breg == 0
+	  && (offset_expr.X_add_number == 0
+	      || OUTPUT_FLAVOR == bfd_target_elf_flavour))
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
+		       treg, (int) BFD_RELOC_PCREL_HI16_S);
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+		         || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addiu" : "daddiu"),
+		       "t,r,j", treg, treg, (int) BFD_RELOC_PCREL_LO16);
+	  return;
+	}
+
+      if (offset_expr.X_op != O_symbol
+	  && offset_expr.X_op != O_constant)
+	{
+	  as_bad (_("expression too complex"));
+	  offset_expr.X_op = O_constant;
+	}
+
+      if (treg == breg)
+	{
+	  tempreg = AT;
+	  used_at = 1;
+	}
+      else
+	{
+	  tempreg = treg;
+	  used_at = 0;
+	}
+
+      if (offset_expr.X_op == O_constant)
+	load_register (&icnt, tempreg, &offset_expr, dbl);
+      else if (mips_pic == NO_PIC)
+	{
+	  /* If this is a reference to an GP relative symbol, we want
+	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_MIPS_GPREL)
+	     Otherwise we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)
+	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
+	     If we have a constant, we need two instructions anyhow,
+	     so we may as well always use the latter form.  */
+	  if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
+	      || nopic_need_relax (offset_expr.X_add_symbol, 1))
+	    p = NULL;
+	  else
+	    {
+	      frag_grow (20);
+	      macro_build ((char *) NULL, &icnt, &offset_expr,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+		     	     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", tempreg, GP, (int) BFD_RELOC_MIPS_GPREL);
+	      p = frag_var (rs_machine_dependent, 8, 0,
+			    RELAX_ENCODE (4, 8, 0, 4, 0,
+					  mips_opts.warn_about_macros),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+	    }
+	  macro_build_lui (p, &icnt, &offset_expr, tempreg);
+	  if (p != NULL)
+	    p += 4;
+	  macro_build (p, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addiu" : "daddiu"),
+		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+	}
+      else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
+	{
+	  /* If this is a reference to an external symbol, and there
+	     is no constant, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	     For a local symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
+
+	     If we have a small constant, and this is a reference to
+	     an external symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$tempreg,$tempreg,<constant>
+	     For a local symbol, we want the same instruction
+	     sequence, but we output a BFD_RELOC_LO16 reloc on the
+	     addiu instruction.
+
+	     If we have a large constant, and this is a reference to
+	     an external symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       lui	$at,<hiconstant>
+	       addiu	$at,$at,<loconstant>
+	       addu	$tempreg,$tempreg,$at
+	     For a local symbol, we want the same instruction
+	     sequence, but we output a BFD_RELOC_LO16 reloc on the
+	     addiu instruction.  */
+	  expr1.X_add_number = offset_expr.X_add_number;
+	  offset_expr.X_add_number = 0;
+	  frag_grow (32);
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       dbl ? "ld" : "lw",
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  if (expr1.X_add_number == 0)
+	    {
+	      int off;
+
+	      if ((breg == 0) && (NOP_NEEDED))
+		off = 0;
+	      else if (!NOP_NEEDED)
+		off = 4;
+	      else
+		{
+		  /* We're going to put in an addu instruction using
+		     tempreg, so we may as well insert the nop right
+		     now.  */
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       "nop", "");
+		  off = 4;
+		}
+	      p = frag_var (rs_machine_dependent, 8 - off, 0,
+			    RELAX_ENCODE (0, 8 - off, NOP_NEEDED ? (-4 - off) : (0 - off),
+					  4 - off, 0,
+					  (breg == 0
+					   ? mips_opts.warn_about_macros
+					   : 0)),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+	      if ((breg == 0) && (NOP_NEEDED))
+		{
+		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+		  p += 4;
+		}
+	      macro_build (p, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+	      /* FIXME: If breg == 0, and the next instruction uses
+		 $tempreg, then if this variant case is used an extra
+		 nop will be generated.  */
+	    }
+	  else if (expr1.X_add_number >= -0x8000
+		   && expr1.X_add_number < 0x8000)
+	    {
+	      if(NOP_NEEDED) 
+			  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   "nop", "");
+	      macro_build ((char *) NULL, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+	      (void) frag_var (rs_machine_dependent, 0, 0,
+			       RELAX_ENCODE (0, 0, NOP_NEEDED ? -12 : -8, 
+			       -4, 0, 0),
+			       offset_expr.X_add_symbol, (offsetT) 0,
+			       (char *) NULL);
+	    }
+	  else
+	    {
+	      int off1;
+
+	      /* If we are going to add in a base register, and the
+		 target register and the base register are the same,
+		 then we are using AT as a temporary register.  Since
+		 we want to load the constant into AT, we add our
+		 current AT (from the global offset table) and the
+		 register into the register now, and pretend we were
+		 not using a base register.  */
+	      if (breg != treg)
+		off1 = 0;
+	      else
+		{
+		  if (NOP_NEEDED)
+			  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       "nop", "");
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       ((bfd_arch_bits_per_address (stdoutput) == 32
+				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+				? "addu" : "daddu"),
+			       "d,v,t", treg, AT, breg);
+		  breg = 0;
+		  tempreg = treg;
+		  off1 = (NOP_NEEDED) ? -8 : -4;
+		}
+
+	      /* Set mips_optimize around the lui instruction to avoid
+		 inserting an unnecessary nop after the lw.  */
+	      hold_mips_optimize = mips_optimize;
+	      mips_optimize = 2;
+	      macro_build_lui ((char *) NULL, &icnt, &expr1, AT);
+	      mips_optimize = hold_mips_optimize;
+
+	      macro_build ((char *) NULL, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", tempreg, tempreg, AT);
+	      (void) frag_var (rs_machine_dependent, 0, 0,
+			       RELAX_ENCODE (0, 0, -16 + off1, -8, 0, 0),
+			       offset_expr.X_add_symbol, (offsetT) 0,
+			       (char *) NULL);
+	      used_at = 1;
+	    }
+	}
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  int gpdel;
+
+	  /* This is the large GOT case.  If this is a reference to an
+	     external symbol, and there is no constant, we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
+	       addu	$tempreg,$tempreg,$gp
+	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
+	     For a local symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
+
+	     If we have a small constant, and this is a reference to
+	     an external symbol, we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
+	       addu	$tempreg,$tempreg,$gp
+	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
+	       nop
+	       addiu	$tempreg,$tempreg,<constant>
+	     For a local symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$tempreg,$tempreg,<constant> (BFD_RELOC_LO16)
+
+	     If we have a large constant, and this is a reference to
+	     an external symbol, we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
+	       addu	$tempreg,$tempreg,$gp
+	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
+	       lui	$at,<hiconstant>
+	       addiu	$at,$at,<loconstant>
+	       addu	$tempreg,$tempreg,$at
+	     For a local symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       lui	$at,<hiconstant>
+	       addiu	$at,$at,<loconstant>	(BFD_RELOC_LO16)
+	       addu	$tempreg,$tempreg,$at
+	     */
+	  expr1.X_add_number = offset_expr.X_add_number;
+	  offset_expr.X_add_number = 0;
+	  frag_grow (52);
+	  if (reg_needs_delay (GOT_REG))
+	    gpdel = 4;
+	  else
+	    gpdel = 0;
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
+		       tempreg, (int) BFD_RELOC_MIPS_GOT_HI16);
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addu" : "daddu"),
+		       "d,v,t", tempreg, tempreg, GOT_REG);
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       dbl ? "ld" : "lw",
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_LO16,
+		       tempreg);
+	  if (expr1.X_add_number == 0)
+	    {
+	      int off;
+
+	      if (breg == 0)
+		off = 0;
+	      else
+		{
+		  /* We're going to put in an addu instruction using
+		     tempreg, so we may as well insert the nop right
+		     now.  */
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       "nop", "");
+		  off = 4;
+		}
+
+	      p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
+			    RELAX_ENCODE (12 + off, 12 + gpdel, gpdel,
+					  8 + gpdel, 0,
+					  (breg == 0
+					   ? mips_opts.warn_about_macros
+					   : 0)),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+	    }
+	  else if (expr1.X_add_number >= -0x8000
+		   && expr1.X_add_number < 0x8000)
+	    {
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   "nop", "");
+	      macro_build ((char *) NULL, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+
+	      p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
+			    RELAX_ENCODE (20, 12 + gpdel, gpdel, 8 + gpdel, 0,
+					  (breg == 0
+					   ? mips_opts.warn_about_macros
+					   : 0)),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+	    }
+	  else
+	    {
+	      int adj, dreg;
+
+	      /* If we are going to add in a base register, and the
+		 target register and the base register are the same,
+		 then we are using AT as a temporary register.  Since
+		 we want to load the constant into AT, we add our
+		 current AT (from the global offset table) and the
+		 register into the register now, and pretend we were
+		 not using a base register.  */
+	      if (breg != treg)
+		{
+		  adj = 0;
+		  dreg = tempreg;
+		}
+	      else
+		{
+		  assert (tempreg == AT);
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       "nop", "");
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       ((bfd_arch_bits_per_address (stdoutput) == 32
+				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+				? "addu" : "daddu"),
+			       "d,v,t", treg, AT, breg);
+		  dreg = treg;
+		  adj = 8;
+		}
+
+	      /* Set mips_optimize around the lui instruction to avoid
+		 inserting an unnecessary nop after the lw.  */
+	      hold_mips_optimize = mips_optimize;
+	      mips_optimize = 2;
+	      macro_build_lui ((char *) NULL, &icnt, &expr1, AT);
+	      mips_optimize = hold_mips_optimize;
+
+	      macro_build ((char *) NULL, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", dreg, dreg, AT);
+
+	      p = frag_var (rs_machine_dependent, 16 + gpdel + adj, 0,
+			    RELAX_ENCODE (24 + adj, 16 + gpdel + adj, gpdel,
+					  8 + gpdel, 0,
+					  (breg == 0
+					   ? mips_opts.warn_about_macros
+					   : 0)),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+
+	      used_at = 1;
+	    }
+
+	  if (gpdel > 0)
+	    {
+	      /* This is needed because this instruction uses $gp, but
+                 the first instruction on the main stream does not.  */
+	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	      p += 4;
+	    }
+	  macro_build (p, &icnt, &offset_expr,
+		       dbl ? "ld" : "lw",
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  p += 4;
+	  if (expr1.X_add_number >= -0x8000
+	      && expr1.X_add_number < 0x8000)
+	    {
+	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	      p += 4;
+	      macro_build (p, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+	      /* FIXME: If add_number is 0, and there was no base
+                 register, the external symbol case ended with a load,
+                 so if the symbol turns out to not be external, and
+                 the next instruction uses tempreg, an unnecessary nop
+                 will be inserted.  */
+	    }
+	  else
+	    {
+	      if (breg == treg)
+		{
+		  /* We must add in the base register now, as in the
+                     external symbol case.  */
+		  assert (tempreg == AT);
+		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+		  p += 4;
+		  macro_build (p, &icnt, (expressionS *) NULL,
+			       ((bfd_arch_bits_per_address (stdoutput) == 32
+				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+				? "addu" : "daddu"),
+			       "d,v,t", treg, AT, breg);
+		  p += 4;
+		  tempreg = treg;
+		  /* We set breg to 0 because we have arranged to add
+                     it in in both cases.  */
+		  breg = 0;
+		}
+
+	      macro_build_lui (p, &icnt, &expr1, AT);
+	      p += 4;
+	      macro_build (p, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addiu" : "daddiu"),
+			   "t,r,j", AT, AT, (int) BFD_RELOC_LO16);
+	      p += 4;
+	      macro_build (p, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", tempreg, tempreg, AT);
+	      p += 4;
+	    }
+	}
+      else if (mips_pic == EMBEDDED_PIC)
+	{
+	  /* We use
+	       addiu	$tempreg,$gp,<sym>	(BFD_RELOC_MIPS_GPREL)
+	     */
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addiu" : "daddiu"),
+		       "t,r,j", tempreg, GP, (int) BFD_RELOC_MIPS_GPREL);
+	}
+      else
+	abort ();
+
+      if (breg != 0)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		     ((bfd_arch_bits_per_address (stdoutput) == 32
+		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		      ? "addu" : "daddu"),
+		     "d,v,t", treg, tempreg, breg);
+
+      if (! used_at)
+	return;
+
+      break;
+
+    case M_J_A:
+      /* The j instruction may not be used in PIC code, since it
+	 requires an absolute address.  We convert it to a b
+	 instruction.  */
+      if (mips_pic == NO_PIC)
+	macro_build ((char *) NULL, &icnt, &offset_expr, "j", "a");
+      else
+	macro_build ((char *) NULL, &icnt, &offset_expr, "b", "p");
+      return;
+
+      /* The jal instructions must be handled as macros because when
+	 generating PIC code they expand to multi-instruction
+	 sequences.  Normally they are simple instructions.  */
+    case M_JAL_1:
+      dreg = RA;
+      /* Fall through.  */
+    case M_JAL_2:
+      if (mips_pic == NO_PIC
+	  || mips_pic == EMBEDDED_PIC)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr",
+		     "d,s", dreg, sreg);
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  if ((sreg != PIC_CALL_REG) && (mips_pic != QNX_PIC))
+	    as_warn (_("MIPS PIC call to register other than $25"));
+      
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "jalr",
+		       "d,s", dreg, sreg);
+	  if (mips_cprestore_offset < 0) {
+	    if (mips_pic != QNX_PIC) as_warn ("No .cprestore pseudo-op used in PIC code");
+	    }
+	  else
+	    {
+	      expr1.X_add_number = mips_cprestore_offset;
+	      macro_build ((char *) NULL, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "lw" : "ld"),
+			   "t,o(b)", GOT_REG, (int) BFD_RELOC_LO16, mips_frame_reg);
+	    }
+	}
+      else
+	abort ();
+
+      return;
+
+    case M_JAL_A:
+      if (mips_pic == NO_PIC)
+	macro_build ((char *) NULL, &icnt, &offset_expr, "jal", "a");
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  /* If this is a reference to an external symbol, and we are
+	     using a small GOT, we want
+	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_CALL16)
+	       nop
+	       jalr	$25
+	       nop
+	       lw	$gp,cprestore($sp)
+	     The cprestore value is set using the .cprestore
+	     pseudo-op.  If we are using a big GOT, we want
+	       lui	$25,<sym>		(BFD_RELOC_MIPS_CALL_HI16)
+	       addu	$25,$25,$gp
+	       lw	$25,<sym>($25)		(BFD_RELOC_MIPS_CALL_LO16)
+	       nop
+	       jalr	$25
+	       nop
+	       lw	$gp,cprestore($sp)
+	     If the symbol is not external, we want
+	       lw	$25,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$25,$25,<sym>		(BFD_RELOC_LO16)
+	       jalr	$25
+	       nop
+	       lw $gp,cprestore($sp) */
+	  frag_grow (40);
+	  if (! mips_big_got)
+	    {
+	      if(mips_pic != QNX_PIC) 
+			  macro_build ((char *) NULL, &icnt, &offset_expr,
+				   ((bfd_arch_bits_per_address (stdoutput) == 32
+					 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+					? "lw" : "ld"),
+				   "t,o(b)", PIC_CALL_REG,
+				   (int) BFD_RELOC_MIPS_CALL16, GOT_REG);
+	      else 
+	          macro_build ((char *) NULL, &icnt, &offset_expr,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || mips_opts.isa < 3)
+			    ? "lw" : "ld"),
+			   "t,o(b)", PIC_CALL_REG,
+			   (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	      if(NOP_NEEDED) 
+	      	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   "nop", "");
+	      p = frag_var (rs_machine_dependent, 4, 0,
+			    RELAX_ENCODE (0, 4, NOP_NEEDED ? -8 : -4, 
+			    0, 0, 0),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+	    }
+	  else
+	    {
+	      int gpdel;
+
+	      if (reg_needs_delay (GOT_REG))
+		gpdel = 4;
+	      else
+		gpdel = 0;
+	      macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
+			   PIC_CALL_REG, (int) BFD_RELOC_MIPS_CALL_HI16);
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", PIC_CALL_REG, PIC_CALL_REG, GOT_REG);
+	      macro_build ((char *) NULL, &icnt, &offset_expr,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "lw" : "ld"),
+			   "t,o(b)", PIC_CALL_REG,
+			   (int) BFD_RELOC_MIPS_CALL_LO16, PIC_CALL_REG);
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   "nop", "");
+	      p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
+			    RELAX_ENCODE (16, 12 + gpdel, gpdel, 8 + gpdel,
+					  0, 0),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+	      if (gpdel > 0)
+		{
+		  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+		  p += 4;
+		}
+	      macro_build (p, &icnt, &offset_expr,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "lw" : "ld"),
+			   "t,o(b)", PIC_CALL_REG,
+			   (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	      p += 4;
+	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	      p += 4;
+	    }			   
+	  macro_build (p, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			? "addiu" : "daddiu"),
+		       "t,r,j", PIC_CALL_REG, PIC_CALL_REG,
+		       (int) BFD_RELOC_LO16);
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		       "jalr", "s", PIC_CALL_REG);
+	  if (mips_cprestore_offset < 0)
+	    {
+	      if (mips_pic != QNX_PIC) as_warn ("No .cprestore pseudo-op used in PIC code");
+		}
+	  else
+	    {
+	      if (mips_opts.noreorder)
+		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			     "nop", "");
+	      expr1.X_add_number = mips_cprestore_offset;
+	      macro_build ((char *) NULL, &icnt, &expr1,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "lw" : "ld"),
+			   "t,o(b)", GOT_REG, (int) BFD_RELOC_LO16,
+			   mips_frame_reg);
+	    }
+	}
+      else if (mips_pic == EMBEDDED_PIC)
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "bal", "p");
+	  /* The linker may expand the call to a longer sequence which
+	     uses $at, so we must break rather than return.  */
+	  break;
+	}
+      else
+	abort ();
+
+      return;
+
+    case M_LB_AB:
+      s = "lb";
+      goto ld;
+    case M_LBU_AB:
+      s = "lbu";
+      goto ld;
+    case M_LH_AB:
+      s = "lh";
+      goto ld;
+    case M_LHU_AB:
+      s = "lhu";
+      goto ld;
+    case M_LW_AB:
+      s = "lw";
+      goto ld;
+    case M_LWC0_AB:
+      s = "lwc0";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LWC1_AB:
+      s = "lwc1";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LWC2_AB:
+      s = "lwc2";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LWC3_AB:
+      s = "lwc3";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LWL_AB:
+      s = "lwl";
+      lr = 1;
+      goto ld;
+    case M_LWR_AB:
+      s = "lwr";
+      lr = 1;
+      goto ld;
+    case M_LDC1_AB:
+      if (mips_cpu == 4650)
+	{
+	  as_bad (_("opcode not supported on this processor"));
+	  return;
+	}
+      s = "ldc1";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LDC2_AB:
+      s = "ldc2";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LDC3_AB:
+      s = "ldc3";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ld;
+    case M_LDL_AB:
+      s = "ldl";
+      lr = 1;
+      goto ld;
+    case M_LDR_AB:
+      s = "ldr";
+      lr = 1;
+      goto ld;
+    case M_LL_AB:
+      s = "ll";
+      goto ld;
+    case M_LLD_AB:
+      s = "lld";
+      goto ld;
+    case M_LWU_AB:
+      s = "lwu";
+    ld:
+      if (breg == treg || coproc || lr)
+	{
+	  tempreg = AT;
+	  used_at = 1;
+	}
+      else
+	{
+	  tempreg = treg;
+	  used_at = 0;
+	}
+      goto ld_st;
+    case M_SB_AB:
+      s = "sb";
+      goto st;
+    case M_SH_AB:
+      s = "sh";
+      goto st;
+    case M_SW_AB:
+      s = "sw";
+      goto st;
+    case M_SWC0_AB:
+      s = "swc0";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto st;
+    case M_SWC1_AB:
+      s = "swc1";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto st;
+    case M_SWC2_AB:
+      s = "swc2";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto st;
+    case M_SWC3_AB:
+      s = "swc3";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto st;
+    case M_SWL_AB:
+      s = "swl";
+      goto st;
+    case M_SWR_AB:
+      s = "swr";
+      goto st;
+    case M_SC_AB:
+      s = "sc";
+      goto st;
+    case M_SCD_AB:
+      s = "scd";
+      goto st;
+    case M_SDC1_AB:
+      if (mips_cpu == 4650)
+	{
+	  as_bad (_("opcode not supported on this processor"));
+	  return;
+	}
+      s = "sdc1";
+      coproc = 1;
+      /* Itbl support may require additional care here. */
+      goto st;
+    case M_SDC2_AB:
+      s = "sdc2";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto st;
+    case M_SDC3_AB:
+      s = "sdc3";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto st;
+    case M_SDL_AB:
+      s = "sdl";
+      goto st;
+    case M_SDR_AB:
+      s = "sdr";
+    st:
+      tempreg = AT;
+      used_at = 1;
+    ld_st:
+      /* Itbl support may require additional care here. */
+      if (mask == M_LWC1_AB
+	  || mask == M_SWC1_AB
+	  || mask == M_LDC1_AB
+	  || mask == M_SDC1_AB
+	  || mask == M_L_DAB
+	  || mask == M_S_DAB)
+	fmt = "T,o(b)";
+      else if (coproc)
+	fmt = "E,o(b)";
+      else
+	fmt = "t,o(b)";
+
+      if (offset_expr.X_op != O_constant
+	  && offset_expr.X_op != O_symbol)
+	{
+	  as_bad (_("expression too complex"));
+	  offset_expr.X_op = O_constant;
+	}
+
+      /* A constant expression in PIC code can be handled just as it
+	 is in non PIC code.  */
+      if (mips_pic == NO_PIC
+	  || offset_expr.X_op == O_constant)
+	{
+	  /* If this is a reference to a GP relative symbol, and there
+	     is no base register, we want
+	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
+	     Otherwise, if there is no base register, we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)
+	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
+	     If we have a constant, we need two instructions anyhow,
+	     so we always use the latter form.
+
+	     If we have a base register, and this is a reference to a
+	     GP relative symbol, we want
+	       addu	$tempreg,$breg,$gp
+	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_MIPS_GPREL)
+	     Otherwise we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_HI16_S)
+	       addu	$tempreg,$tempreg,$breg
+	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_LO16)
+	     With a constant we always use the latter case.  */
+	  if (breg == 0)
+	    {
+	      if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
+		  || nopic_need_relax (offset_expr.X_add_symbol, 1))
+		p = NULL;
+	      else
+		{
+		  frag_grow (20);
+		  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+			       treg, (int) BFD_RELOC_MIPS_GPREL, GP);
+		  p = frag_var (rs_machine_dependent, 8, 0,
+				RELAX_ENCODE (4, 8, 0, 4, 0,
+					      (mips_opts.warn_about_macros
+					       || (used_at
+						   && mips_opts.noat))),
+				offset_expr.X_add_symbol, (offsetT) 0,
+				(char *) NULL);
+		  used_at = 0;
+		}
+	      macro_build_lui (p, &icnt, &offset_expr, tempreg);
+	      if (p != NULL)
+		p += 4;
+	      macro_build (p, &icnt, &offset_expr, s, fmt, treg,
+			   (int) BFD_RELOC_LO16, tempreg);
+	    }
+	  else
+	    {
+	      if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
+		  || nopic_need_relax (offset_expr.X_add_symbol, 1))
+		p = NULL;
+	      else
+		{
+		  frag_grow (28);
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       ((bfd_arch_bits_per_address (stdoutput) == 32
+				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+				? "addu" : "daddu"),
+			       "d,v,t", tempreg, breg, GP);
+		  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+			       treg, (int) BFD_RELOC_MIPS_GPREL, tempreg);
+		  p = frag_var (rs_machine_dependent, 12, 0,
+				RELAX_ENCODE (8, 12, 0, 8, 0, 0),
+				offset_expr.X_add_symbol, (offsetT) 0,
+				(char *) NULL);
+		}
+	      macro_build_lui (p, &icnt, &offset_expr, tempreg);
+	      if (p != NULL)
+		p += 4;
+	      macro_build (p, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", tempreg, tempreg, breg);
+	      if (p != NULL)
+		p += 4;
+	      macro_build (p, &icnt, &offset_expr, s, fmt, treg,
+			   (int) BFD_RELOC_LO16, tempreg);
+	    }
+	}
+      else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
+	{
+		int gpreg = GOT_REG;
+	
+	  /* If this is a reference to an external symbol, we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       <op>	$treg,0($tempreg)
+	     Otherwise we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
+	       <op>	$treg,0($tempreg)
+	     If there is a base register, we add it to $tempreg before
+	     the <op>.  If there is a constant, we stick it in the
+	     <op> instruction.  We don't handle constants larger than
+	     16 bits, because we have no way to load the upper 16 bits
+	     (actually, we could handle them for the subset of cases
+	     in which we are not using $at).  */
+	  assert (offset_expr.X_op == O_symbol);
+	  expr1.X_add_number = offset_expr.X_add_number;
+	  offset_expr.X_add_number = 0;
+	  if (expr1.X_add_number < -0x8000
+	      || expr1.X_add_number >= 0x8000)
+	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
+	  frag_grow (20);
+	  if (mips_pic == QNX_PIC) {
+		/* External function relocations should be against s7 but other should be against gp */
+		if (!S_IS_DEFINED(offset_expr.X_add_symbol)) {
+			gpreg = GP;
+		}
+		else if (S_IS_EXTERN(offset_expr.X_add_symbol)) {
+			gpreg = GP;
+		}
+		else if (S_IS_DEFINED(offset_expr.X_add_symbol) && S_IS_LOCAL(offset_expr.X_add_symbol)) {
+			gpreg = GP;
+		}
+		else if (!S_IS_FUNCTION(offset_expr.X_add_symbol)) {
+			gpreg = GP;
+		}
+	  }
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16,
+			  gpreg);
+	  if (NOP_NEEDED) 
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+	  p = frag_var (rs_machine_dependent, 4, 0, 
+			RELAX_ENCODE (0, 4, NOP_NEEDED ? -8 : -4, 
+			0, 0, 0),
+			offset_expr.X_add_symbol, (offsetT) 0,
+			(char *) NULL);
+	  macro_build (p, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+	  if (breg != 0)
+	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			 ((bfd_arch_bits_per_address (stdoutput) == 32
+			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			  ? "addu" : "daddu"),
+			 "d,v,t", tempreg, tempreg, breg);
+	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
+		       (int) BFD_RELOC_LO16, tempreg);
+	}
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  int gpdel;
+
+	  /* If this is a reference to an external symbol, we want
+	       lui	$tempreg,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
+	       addu	$tempreg,$tempreg,$gp
+	       lw	$tempreg,<sym>($tempreg) (BFD_RELOC_MIPS_GOT_LO16)
+	       <op>	$treg,0($tempreg)
+	     Otherwise we want
+	       lw	$tempreg,<sym>($gp)	(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       addiu	$tempreg,$tempreg,<sym>	(BFD_RELOC_LO16)
+	       <op>	$treg,0($tempreg)
+	     If there is a base register, we add it to $tempreg before
+	     the <op>.  If there is a constant, we stick it in the
+	     <op> instruction.  We don't handle constants larger than
+	     16 bits, because we have no way to load the upper 16 bits
+	     (actually, we could handle them for the subset of cases
+	     in which we are not using $at).  */
+	  assert (offset_expr.X_op == O_symbol);
+	  expr1.X_add_number = offset_expr.X_add_number;
+	  offset_expr.X_add_number = 0;
+	  if (expr1.X_add_number < -0x8000
+	      || expr1.X_add_number >= 0x8000)
+	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
+	  if (reg_needs_delay (GOT_REG))
+	    gpdel = 4;
+	  else
+	    gpdel = 0;
+	  frag_grow (36);
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
+		       tempreg, (int) BFD_RELOC_MIPS_GOT_HI16);
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addu" : "daddu"),
+		       "d,v,t", tempreg, tempreg, GOT_REG);
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT_LO16,
+		       tempreg);
+	  p = frag_var (rs_machine_dependent, 12 + gpdel, 0,
+			RELAX_ENCODE (12, 12 + gpdel, gpdel, 8 + gpdel, 0, 0),
+			offset_expr.X_add_symbol, (offsetT) 0, (char *) NULL);
+	  if (gpdel > 0)
+	    {
+	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	      p += 4;
+	    }
+	  macro_build (p, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", tempreg, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  p += 4;
+	  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	  p += 4;
+	  macro_build (p, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", tempreg, tempreg, (int) BFD_RELOC_LO16);
+	  if (breg != 0)
+	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			 ((bfd_arch_bits_per_address (stdoutput) == 32
+			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			  ? "addu" : "daddu"),
+			 "d,v,t", tempreg, tempreg, breg);
+	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt, treg,
+		       (int) BFD_RELOC_LO16, tempreg);
+	}
+      else if (mips_pic == EMBEDDED_PIC)
+	{
+	  /* If there is no base register, we want
+	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
+	     If there is a base register, we want
+	       addu	$tempreg,$breg,$gp
+	       <op>	$treg,<sym>($tempreg)	(BFD_RELOC_MIPS_GPREL)
+	     */
+	  assert (offset_expr.X_op == O_symbol);
+	  if (breg == 0)
+	    {
+	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+			   treg, (int) BFD_RELOC_MIPS_GPREL, GP);
+	      used_at = 0;
+	    }
+	  else
+	    {
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", tempreg, breg, GP);
+	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+			   treg, (int) BFD_RELOC_MIPS_GPREL, tempreg);
+	    }
+	}
+      else
+	abort ();
+
+      if (! used_at)
+	return;
+
+      break;
+
+    case M_LI:
+    case M_LI_S:
+      load_register (&icnt, treg, &imm_expr, 0);
+      return;
+
+    case M_DLI:
+      load_register (&icnt, treg, &imm_expr, 1);
+      return;
+
+    case M_LI_SS:
+      if (imm_expr.X_op == O_constant)
+	{
+	  load_register (&icnt, AT, &imm_expr, 0);
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		       "mtc1", "t,G", AT, treg);
+	  break;
+	}
+      else
+	{
+	  assert (offset_expr.X_op == O_symbol
+		  && strcmp (segment_name (S_GET_SEGMENT
+					   (offset_expr.X_add_symbol)),
+			     ".lit4") == 0
+		  && offset_expr.X_add_number == 0);
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
+		       treg, (int) BFD_RELOC_MIPS_LITERAL, GP);
+	  return;
+	}
+
+    case M_LI_D:
+      /* If we have a constant in IMM_EXPR, then in mips3 mode it is
+         the entire value, and in mips1 mode it is the high order 32
+         bits of the value and the low order 32 bits are either zero
+         or in offset_expr.  */
+      if (imm_expr.X_op == O_constant || imm_expr.X_op == O_big)
+	{
+	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
+	    load_register (&icnt, treg, &imm_expr, 1);
+	  else
+	    {
+	      int hreg, lreg;
+
+	      if (target_big_endian)
+		{
+		  hreg = treg;
+		  lreg = treg + 1;
+		}
+	      else
+		{
+		  hreg = treg + 1;
+		  lreg = treg;
+		}
+
+	      if (hreg <= 31)
+		load_register (&icnt, hreg, &imm_expr, 0);
+	      if (lreg <= 31)
+		{
+		  if (offset_expr.X_op == O_absent)
+		    macro_build ((char *) NULL, &icnt, NULL, "move", "d,s",
+				 lreg, 0);
+		  else
+		    {
+		      assert (offset_expr.X_op == O_constant);
+		      load_register (&icnt, lreg, &offset_expr, 0);
+		    }
+		}
+	    }
+	  return;
+	}
+
+      /* We know that sym is in the .rdata section.  First we get the
+	 upper 16 bits of the address.  */
+      if (mips_pic == NO_PIC)
+	{
+	  /* FIXME: This won't work for a 64 bit address.  */
+	  macro_build_lui ((char *) NULL, &icnt, &offset_expr, AT);
+	}
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	}
+      else if (mips_pic == EMBEDDED_PIC)
+	{
+	  /* For embedded PIC we pick up the entire address off $gp in
+	     a single instruction.  */
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", AT, GP, (int) BFD_RELOC_MIPS_GPREL);
+	  offset_expr.X_op = O_constant;
+	  offset_expr.X_add_number = 0;
+	}
+      else
+	abort ();
+	
+      /* Now we load the register(s).  */
+      if (ISA_HAS_64BIT_REGS (mips_opts.isa))
+	macro_build ((char *) NULL, &icnt, &offset_expr, "ld", "t,o(b)",
+		     treg, (int) BFD_RELOC_LO16, AT);
+      else
+	{
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "lw", "t,o(b)",
+		       treg, (int) BFD_RELOC_LO16, AT);
+	  if (treg != 31)
+	    {
+	      /* FIXME: How in the world do we deal with the possible
+		 overflow here?  */
+	      offset_expr.X_add_number += 4;
+	      macro_build ((char *) NULL, &icnt, &offset_expr, "lw", "t,o(b)",
+			   treg + 1, (int) BFD_RELOC_LO16, AT);
+	    }
+	}
+
+      /* To avoid confusion in tc_gen_reloc, we must ensure that this
+	 does not become a variant frag.  */
+      frag_wane (frag_now);
+      frag_new (0);
+
+      break;
+
+    case M_LI_DD:
+      /* If we have a constant in IMM_EXPR, then in mips3 mode it is
+         the entire value, and in mips1 mode it is the high order 32
+         bits of the value and the low order 32 bits are either zero
+         or in offset_expr.  */
+      if (imm_expr.X_op == O_constant || imm_expr.X_op == O_big)
+	{
+	  load_register (&icnt, AT, &imm_expr, ISA_HAS_64BIT_REGS (mips_opts.isa));
+	  if (ISA_HAS_64BIT_REGS (mips_opts.isa))
+	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			 "dmtc1", "t,S", AT, treg);
+	  else
+	    {
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   "mtc1", "t,G", AT, treg + 1);
+	      if (offset_expr.X_op == O_absent)
+		macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			     "mtc1", "t,G", 0, treg);
+	      else
+		{
+		  assert (offset_expr.X_op == O_constant);
+		  load_register (&icnt, AT, &offset_expr, 0);
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       "mtc1", "t,G", AT, treg);
+		}
+	    }
+	  break;
+	}
+
+      assert (offset_expr.X_op == O_symbol
+	      && offset_expr.X_add_number == 0);
+      s = segment_name (S_GET_SEGMENT (offset_expr.X_add_symbol));
+      if (strcmp (s, ".lit8") == 0)
+	{
+	  if (mips_opts.isa != 1)
+	    {
+	      macro_build ((char *) NULL, &icnt, &offset_expr, "ldc1",
+			   "T,o(b)", treg, (int) BFD_RELOC_MIPS_LITERAL, GP);
+	      return;
+	    }
+	  breg = GP;
+	  r = BFD_RELOC_MIPS_LITERAL;
+	  goto dob;
+	}
+      else
+	{
+	  assert (strcmp (s, RDATA_SECTION_NAME) == 0);
+	  if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	    macro_build ((char *) NULL, &icnt, &offset_expr,
+			 ((bfd_arch_bits_per_address (stdoutput) == 32
+			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			  ? "lw" : "ld"),
+			 "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  else
+	    {
+	      /* FIXME: This won't work for a 64 bit address.  */
+	      macro_build_lui ((char *) NULL, &icnt, &offset_expr, AT);
+	    }
+	      
+	  if (mips_opts.isa != 1)
+	    {
+	      macro_build ((char *) NULL, &icnt, &offset_expr, "ldc1",
+			   "T,o(b)", treg, (int) BFD_RELOC_LO16, AT);
+
+	      /* To avoid confusion in tc_gen_reloc, we must ensure
+		 that this does not become a variant frag.  */
+	      frag_wane (frag_now);
+	      frag_new (0);
+
+	      break;
+	    }
+	  breg = AT;
+	  r = BFD_RELOC_LO16;
+	  goto dob;
+	}
+
+    case M_L_DOB:
+      if (mips_cpu == 4650)
+	{
+	  as_bad (_("opcode not supported on this processor"));
+	  return;
+	}
+      /* Even on a big endian machine $fn comes before $fn+1.  We have
+	 to adjust when loading from memory.  */
+      r = BFD_RELOC_LO16;
+    dob:
+      assert (mips_opts.isa == 1);
+      macro_build ((char *) NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
+		   target_big_endian ? treg + 1 : treg,
+		   (int) r, breg);
+      /* FIXME: A possible overflow which I don't know how to deal
+	 with.  */
+      offset_expr.X_add_number += 4;
+      macro_build ((char *) NULL, &icnt, &offset_expr, "lwc1", "T,o(b)",
+		   target_big_endian ? treg : treg + 1,
+		   (int) r, breg);
+
+      /* To avoid confusion in tc_gen_reloc, we must ensure that this
+	 does not become a variant frag.  */
+      frag_wane (frag_now);
+      frag_new (0);
+
+      if (breg != AT)
+	return;
+      break;
+
+    case M_L_DAB:
+      /*
+       * The MIPS assembler seems to check for X_add_number not
+       * being double aligned and generating:
+       *	lui	at,%hi(foo+1)
+       *	addu	at,at,v1
+       *	addiu	at,at,%lo(foo+1)
+       *	lwc1	f2,0(at)
+       *	lwc1	f3,4(at)
+       * But, the resulting address is the same after relocation so why
+       * generate the extra instruction?
+       */
+      if (mips_cpu == 4650)
+	{
+	  as_bad (_("opcode not supported on this processor"));
+	  return;
+	}
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      if (mips_opts.isa != 1)
+	{
+	  s = "ldc1";
+	  goto ld;
+	}
+
+      s = "lwc1";
+      fmt = "T,o(b)";
+      goto ldd_std;
+
+    case M_S_DAB:
+      if (mips_cpu == 4650)
+	{
+	  as_bad (_("opcode not supported on this processor"));
+	  return;
+	}
+
+      if (mips_opts.isa != 1)
+	{
+	  s = "sdc1";
+	  goto st;
+	}
+
+      s = "swc1";
+      fmt = "T,o(b)";
+      /* Itbl support may require additional care here. */
+      coproc = 1;
+      goto ldd_std;
+
+    case M_LD_AB:
+      if (ISA_HAS_64BIT_REGS (mips_opts.isa))
+	{
+	  s = "ld";
+	  goto ld;
+	}
+
+      s = "lw";
+      fmt = "t,o(b)";
+      goto ldd_std;
+
+    case M_SD_AB:
+      if (ISA_HAS_64BIT_REGS (mips_opts.isa))
+	{
+	  s = "sd";
+	  goto st;
+	}
+
+      s = "sw";
+      fmt = "t,o(b)";
+
+    ldd_std:
+      if (offset_expr.X_op != O_symbol
+	  && offset_expr.X_op != O_constant)
+	{
+	  as_bad (_("expression too complex"));
+	  offset_expr.X_op = O_constant;
+	}
+
+      /* Even on a big endian machine $fn comes before $fn+1.  We have
+	 to adjust when loading from memory.  We set coproc if we must
+	 load $fn+1 first.  */
+      /* Itbl support may require additional care here. */
+      if (! target_big_endian)
+	coproc = 0;
+
+      if (mips_pic == NO_PIC
+	  || offset_expr.X_op == O_constant)
+	{
+	  /* If this is a reference to a GP relative symbol, we want
+	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
+	       <op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_MIPS_GPREL)
+	     If we have a base register, we use this
+	       addu	$at,$breg,$gp
+	       <op>	$treg,<sym>($at)	(BFD_RELOC_MIPS_GPREL)
+	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_MIPS_GPREL)
+	     If this is not a GP relative symbol, we want
+	       lui	$at,<sym>		(BFD_RELOC_HI16_S)
+	       <op>	$treg,<sym>($at)	(BFD_RELOC_LO16)
+	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16)
+	     If there is a base register, we add it to $at after the
+	     lui instruction.  If there is a constant, we always use
+	     the last case.  */
+	  if ((valueT) offset_expr.X_add_number >= MAX_GPREL_OFFSET
+	      || nopic_need_relax (offset_expr.X_add_symbol, 1))
+	    {
+	      p = NULL;
+	      used_at = 1;
+	    }
+	  else
+	    {
+	      int off;
+
+	      if (breg == 0)
+		{
+		  frag_grow (28);
+		  tempreg = GP;
+		  off = 0;
+		  used_at = 0;
+		}
+	      else
+		{
+		  frag_grow (36);
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			       ((bfd_arch_bits_per_address (stdoutput) == 32
+				 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+				? "addu" : "daddu"),
+			       "d,v,t", AT, breg, GP);
+		  tempreg = AT;
+		  off = 4;
+		  used_at = 1;
+		}
+
+              /* Itbl support may require additional care here. */
+	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+			   coproc ? treg + 1 : treg,
+			   (int) BFD_RELOC_MIPS_GPREL, tempreg);
+	      offset_expr.X_add_number += 4;
+
+	      /* Set mips_optimize to 2 to avoid inserting an
+                 undesired nop.  */
+	      hold_mips_optimize = mips_optimize;
+	      mips_optimize = 2;
+              /* Itbl support may require additional care here. */
+	      macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+			   coproc ? treg : treg + 1,
+			   (int) BFD_RELOC_MIPS_GPREL, tempreg);
+	      mips_optimize = hold_mips_optimize;
+
+	      p = frag_var (rs_machine_dependent, 12 + off, 0,
+			    RELAX_ENCODE (8 + off, 12 + off, 0, 4 + off, 1,
+					  used_at && mips_opts.noat),
+			    offset_expr.X_add_symbol, (offsetT) 0,
+			    (char *) NULL);
+
+	      /* We just generated two relocs.  When tc_gen_reloc
+		 handles this case, it will skip the first reloc and
+		 handle the second.  The second reloc already has an
+		 extra addend of 4, which we added above.  We must
+		 subtract it out, and then subtract another 4 to make
+		 the first reloc come out right.  The second reloc
+		 will come out right because we are going to add 4 to
+		 offset_expr when we build its instruction below.
+
+		 If we have a symbol, then we don't want to include
+		 the offset, because it will wind up being included
+		 when we generate the reloc.  */
+
+	      if (offset_expr.X_op == O_constant)
+		offset_expr.X_add_number -= 8;
+	      else
+		{
+		  offset_expr.X_add_number = -4;
+		  offset_expr.X_op = O_constant;
+		}
+	    }
+	  macro_build_lui (p, &icnt, &offset_expr, AT);
+	  if (p != NULL)
+	    p += 4;
+	  if (breg != 0)
+	    {
+	      macro_build (p, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", AT, breg, AT);
+	      if (p != NULL)
+		p += 4;
+	    }
+          /* Itbl support may require additional care here. */
+	  macro_build (p, &icnt, &offset_expr, s, fmt,
+		       coproc ? treg + 1 : treg,
+		       (int) BFD_RELOC_LO16, AT);
+	  if (p != NULL)
+	    p += 4;
+	  /* FIXME: How do we handle overflow here?  */
+	  offset_expr.X_add_number += 4;
+          /* Itbl support may require additional care here. */
+	  macro_build (p, &icnt, &offset_expr, s, fmt,
+		       coproc ? treg : treg + 1,
+		       (int) BFD_RELOC_LO16, AT);
+	}	  
+      else if ((mips_pic == SVR4_PIC || mips_pic == QNX_PIC) && ! mips_big_got)
+	{
+	  int off;
+
+	  /* If this is a reference to an external symbol, we want
+	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       <op>	$treg,0($at)
+	       <op>	$treg+1,4($at)
+	     Otherwise we want
+	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       <op>	$treg,<sym>($at)	(BFD_RELOC_LO16)
+	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16)
+	     If there is a base register we add it to $at before the
+	     lwc1 instructions.  If there is a constant we include it
+	     in the lwc1 instructions.  */
+	  used_at = 1;
+	  expr1.X_add_number = offset_expr.X_add_number;
+	  offset_expr.X_add_number = 0;
+	  if (expr1.X_add_number < -0x8000
+	      || expr1.X_add_number >= 0x8000 - 4)
+	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
+	  if (breg == 0)
+	    off = 0;
+	  else
+	    off = 4;
+	  frag_grow (24 + off);
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  if(NOP_NEEDED) 
+		  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+	  if (breg != 0)
+	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			 ((bfd_arch_bits_per_address (stdoutput) == 32
+			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			  ? "addu" : "daddu"),
+			 "d,v,t", AT, breg, AT);
+          /* Itbl support may require additional care here. */
+	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
+		       coproc ? treg + 1 : treg,
+		       (int) BFD_RELOC_LO16, AT);
+	  expr1.X_add_number += 4;
+
+	  /* Set mips_optimize to 2 to avoid inserting an undesired
+             nop.  */
+	  hold_mips_optimize = mips_optimize;
+	  mips_optimize = 2;
+          /* Itbl support may require additional care here. */
+	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
+		       coproc ? treg : treg + 1,
+		       (int) BFD_RELOC_LO16, AT);
+	  mips_optimize = hold_mips_optimize;
+
+	  (void) frag_var (rs_machine_dependent, 0, 0,
+			   RELAX_ENCODE (0, 0, NOP_NEEDED ? (-16 - off) : (-12 - off), 
+			   -8, 1, 0),
+			   offset_expr.X_add_symbol, (offsetT) 0,
+			   (char *) NULL);
+	}
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  int gpdel, off;
+
+	  /* If this is a reference to an external symbol, we want
+	       lui	$at,<sym>		(BFD_RELOC_MIPS_GOT_HI16)
+	       addu	$at,$at,$gp
+	       lw	$at,<sym>($at)		(BFD_RELOC_MIPS_GOT_LO16)
+	       nop
+	       <op>	$treg,0($at)
+	       <op>	$treg+1,4($at)
+	     Otherwise we want
+	       lw	$at,<sym>($gp)		(BFD_RELOC_MIPS_GOT16)
+	       nop
+	       <op>	$treg,<sym>($at)	(BFD_RELOC_LO16)
+	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_LO16)
+	     If there is a base register we add it to $at before the
+	     lwc1 instructions.  If there is a constant we include it
+	     in the lwc1 instructions.  */
+	  used_at = 1;
+	  expr1.X_add_number = offset_expr.X_add_number;
+	  offset_expr.X_add_number = 0;
+	  if (expr1.X_add_number < -0x8000
+	      || expr1.X_add_number >= 0x8000 - 4)
+	    as_bad (_("PIC code offset overflow (max 16 signed bits)"));
+	  if (reg_needs_delay (GOT_REG))
+	    gpdel = 4;
+	  else
+	    gpdel = 0;
+	  if (breg == 0)
+	    off = 0;
+	  else
+	    off = 4;
+	  frag_grow (56);
+	  macro_build ((char *) NULL, &icnt, &offset_expr, "lui", "t,u",
+		       AT, (int) BFD_RELOC_MIPS_GOT_HI16);
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addu" : "daddu"),
+		       "d,v,t", AT, AT, GOT_REG);
+	  macro_build ((char *) NULL, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT_LO16, AT);
+	  macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+	  if (breg != 0)
+	    macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			 ((bfd_arch_bits_per_address (stdoutput) == 32
+			   || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			  ? "addu" : "daddu"),
+			 "d,v,t", AT, breg, AT);
+          /* Itbl support may require additional care here. */
+	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
+		       coproc ? treg + 1 : treg,
+		       (int) BFD_RELOC_LO16, AT);
+	  expr1.X_add_number += 4;
+
+	  /* Set mips_optimize to 2 to avoid inserting an undesired
+             nop.  */
+	  hold_mips_optimize = mips_optimize;
+	  mips_optimize = 2;
+          /* Itbl support may require additional care here. */
+	  macro_build ((char *) NULL, &icnt, &expr1, s, fmt,
+		       coproc ? treg : treg + 1,
+		       (int) BFD_RELOC_LO16, AT);
+	  mips_optimize = hold_mips_optimize;
+	  expr1.X_add_number -= 4;
+
+	  p = frag_var (rs_machine_dependent, 16 + gpdel + off, 0,
+			RELAX_ENCODE (24 + off, 16 + gpdel + off, gpdel,
+				      8 + gpdel + off, 1, 0),
+			offset_expr.X_add_symbol, (offsetT) 0,
+			(char *) NULL);
+	  if (gpdel > 0)
+	    {
+	      macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	      p += 4;
+	    }
+	  macro_build (p, &icnt, &offset_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "lw" : "ld"),
+		       "t,o(b)", AT, (int) BFD_RELOC_MIPS_GOT16, GOT_REG);
+	  p += 4;
+	  macro_build (p, &icnt, (expressionS *) NULL, "nop", "");
+	  p += 4;
+	  if (breg != 0)
+	    {
+	      macro_build (p, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", AT, breg, AT);
+	      p += 4;
+	    }
+          /* Itbl support may require additional care here. */
+	  macro_build (p, &icnt, &expr1, s, fmt,
+		       coproc ? treg + 1 : treg,
+		       (int) BFD_RELOC_LO16, AT);
+	  p += 4;
+	  expr1.X_add_number += 4;
+
+	  /* Set mips_optimize to 2 to avoid inserting an undesired
+             nop.  */
+	  hold_mips_optimize = mips_optimize;
+	  mips_optimize = 2;
+          /* Itbl support may require additional care here. */
+	  macro_build (p, &icnt, &expr1, s, fmt,
+		       coproc ? treg : treg + 1,
+		       (int) BFD_RELOC_LO16, AT);
+	  mips_optimize = hold_mips_optimize;
+	}
+      else if (mips_pic == EMBEDDED_PIC)
+	{
+	  /* If there is no base register, we use
+	       <op>	$treg,<sym>($gp)	(BFD_RELOC_MIPS_GPREL)
+	       <op>	$treg+1,<sym>+4($gp)	(BFD_RELOC_MIPS_GPREL)
+	     If we have a base register, we use
+	       addu	$at,$breg,$gp
+	       <op>	$treg,<sym>($at)	(BFD_RELOC_MIPS_GPREL)
+	       <op>	$treg+1,<sym>+4($at)	(BFD_RELOC_MIPS_GPREL)
+	     */
+	  if (breg == 0)
+	    {
+	      tempreg = GP;
+	      used_at = 0;
+	    }
+	  else
+	    {
+	      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+			   ((bfd_arch_bits_per_address (stdoutput) == 32
+			     || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+			    ? "addu" : "daddu"),
+			   "d,v,t", AT, breg, GP);
+	      tempreg = AT;
+	      used_at = 1;
+	    }
+
+          /* Itbl support may require additional care here. */
+	  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+		       coproc ? treg + 1 : treg,
+		       (int) BFD_RELOC_MIPS_GPREL, tempreg);
+	  offset_expr.X_add_number += 4;
+          /* Itbl support may require additional care here. */
+	  macro_build ((char *) NULL, &icnt, &offset_expr, s, fmt,
+		       coproc ? treg : treg + 1,
+		       (int) BFD_RELOC_MIPS_GPREL, tempreg);
+	}
+      else
+	abort ();
+
+      if (! used_at)
+	return;
+
+      break;
+
+    case M_LD_OB:
+      s = "lw";
+      goto sd_ob;
+    case M_SD_OB:
+      s = "sw";
+    sd_ob:
+      assert (bfd_arch_bits_per_address (stdoutput) == 32 
+	      || ! ISA_HAS_64BIT_REGS (mips_opts.isa));
+      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      offset_expr.X_add_number += 4;
+      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg + 1,
+		   (int) BFD_RELOC_LO16, breg);
+      return;
+
+   /* New code added to support COPZ instructions.
+      This code builds table entries out of the macros in mip_opcodes.
+      R4000 uses interlocks to handle coproc delays.
+      Other chips (like the R3000) require nops to be inserted for delays.
+
+      FIXME: Currently, we require that the user handle delays.
+      In order to fill delay slots for non-interlocked chips,
+      we must have a way to specify delays based on the coprocessor.
+      Eg. 4 cycles if load coproc reg from memory, 1 if in cache, etc.
+      What are the side-effects of the cop instruction?
+      What cache support might we have and what are its effects?
+      Both coprocessor & memory require delays. how long???
+      What registers are read/set/modified? 
+
+      If an itbl is provided to interpret cop instructions,
+      this knowledge can be encoded in the itbl spec. */
+
+    case M_COP0:
+      s = "c0";
+      goto copz;
+    case M_COP1:
+      s = "c1";
+      goto copz;
+    case M_COP2:
+      s = "c2";
+      goto copz;
+    case M_COP3:
+      s = "c3";
+    copz:
+      /* For now we just do C (same as Cz).  The parameter will be
+         stored in insn_opcode by mips_ip.  */
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "C",
+		   ip->insn_opcode);
+      return;
+
+#ifdef LOSING_COMPILER
+    default:
+      /* Try and see if this is a new itbl instruction.
+         This code builds table entries out of the macros in mip_opcodes.
+         FIXME: For now we just assemble the expression and pass it's
+         value along as a 32-bit immediate.
+         We may want to have the assembler assemble this value, 
+         so that we gain the assembler's knowledge of delay slots,
+         symbols, etc.
+         Would it be more efficient to use mask (id) here? */
+      if (itbl_have_entries 
+	  && (immed_expr = itbl_assemble (ip->insn_mo->name, "")))
+        {
+	  s = ip->insn_mo->name;
+	  s2 = "cop3";
+	  coproc = ITBL_DECODE_PNUM (immed_expr);;
+	  macro_build ((char *) NULL, &icnt, &immed_expr, s, "C");
+	  return;
+        }
+      macro2 (ip);
+      return;
+    }
+  if (mips_opts.noat)
+    as_warn (_("Macro used $at after \".set noat\""));
+}
+          
+static void
+macro2 (ip)
+     struct mips_cl_insn *ip;
+{
+  register int treg, sreg, dreg, breg;
+  int tempreg;
+  int mask;
+  int icnt = 0;
+  int used_at;
+  expressionS expr1;
+  const char *s;
+  const char *s2;
+  const char *fmt;
+  int likely = 0;
+  int dbl = 0;
+  int coproc = 0;
+  int lr = 0;
+  int imm = 0;
+  int off;
+  offsetT maxnum;
+  bfd_reloc_code_real_type r;
+  char *p;
+          
+  treg = (ip->insn_opcode >> 16) & 0x1f;
+  dreg = (ip->insn_opcode >> 11) & 0x1f;
+  sreg = breg = (ip->insn_opcode >> 21) & 0x1f;
+  mask = ip->insn_mo->mask;
+          
+  expr1.X_op = O_constant;
+  expr1.X_op_symbol = NULL;
+  expr1.X_add_symbol = NULL;
+  expr1.X_add_number = 1;
+          
+  switch (mask)
+    {
+#endif /* LOSING_COMPILER */
+
+    case M_DMUL:
+      dbl = 1;
+    case M_MUL:
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dmultu" : "multu",
+		   "s,t", sreg, treg);
+      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
+      return;
+
+    case M_DMUL_I:
+      dbl = 1;
+    case M_MUL_I:
+      /* The MIPS assembler some times generates shifts and adds.  I'm
+	 not trying to be that fancy. GCC should do this for us
+	 anyway.  */
+      load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dmult" : "mult",
+		   "s,t", sreg, AT);
+      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
+      break;
+
+    case M_DMULO_I:
+      dbl = 1;
+    case M_MULO_I:
+      imm = 1;
+      goto do_mulo;
+
+    case M_DMULO:
+      dbl = 1;
+    case M_MULO:
+    do_mulo:
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      if (imm)
+	load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dmult" : "mult",
+		   "s,t", sreg, imm ? AT : treg);
+      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dsra32" : "sra",
+		   "d,w,<", dreg, dreg, 31);
+      macro_build ((char *) NULL, &icnt, NULL, "mfhi", "d", AT);
+      if (mips_trap)
+	macro_build ((char *) NULL, &icnt, NULL, "tne", "s,t", dreg, AT);
+      else
+	{
+	  expr1.X_add_number = 8;
+	  macro_build ((char *) NULL, &icnt, &expr1, "beq", "s,t,p", dreg, AT);
+	  macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
+	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
+	}
+      --mips_opts.noreorder;
+      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
+      break;
+
+    case M_DMULOU_I:
+      dbl = 1;
+    case M_MULOU_I:
+      imm = 1;
+      goto do_mulou;
+
+    case M_DMULOU:
+      dbl = 1;
+    case M_MULOU:
+    do_mulou:
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      if (imm)
+	load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dmultu" : "multu",
+		   "s,t", sreg, imm ? AT : treg);
+      macro_build ((char *) NULL, &icnt, NULL, "mfhi", "d", AT);
+      macro_build ((char *) NULL, &icnt, NULL, "mflo", "d", dreg);
+      if (mips_trap)
+	macro_build ((char *) NULL, &icnt, NULL, "tne", "s,t", AT, 0);
+      else
+	{
+	  expr1.X_add_number = 8;
+	  macro_build ((char *) NULL, &icnt, &expr1, "beq", "s,t,p", AT, 0);
+	  macro_build ((char *) NULL, &icnt, NULL, "nop", "", 0);
+	    macro_build ((char *) NULL, &icnt, NULL, "break", "c", 6);
+	}
+      --mips_opts.noreorder;
+      break;
+
+    case M_ROL:
+      macro_build ((char *) NULL, &icnt, NULL, "subu", "d,v,t", AT, 0, treg);
+      macro_build ((char *) NULL, &icnt, NULL, "srlv", "d,t,s", AT, sreg, AT);
+      macro_build ((char *) NULL, &icnt, NULL, "sllv", "d,t,s", dreg, sreg,
+		   treg);
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
+      break;
+
+    case M_ROL_I:
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("rotate count too large"));
+      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", AT, sreg,
+		   (int) (imm_expr.X_add_number & 0x1f));
+      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", dreg, sreg,
+		   (int) ((0 - imm_expr.X_add_number) & 0x1f));
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
+      break;
+
+    case M_ROR:
+      macro_build ((char *) NULL, &icnt, NULL, "subu", "d,v,t", AT, 0, treg);
+      macro_build ((char *) NULL, &icnt, NULL, "sllv", "d,t,s", AT, sreg, AT);
+      macro_build ((char *) NULL, &icnt, NULL, "srlv", "d,t,s", dreg, sreg,
+		   treg);
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
+      break;
+
+    case M_ROR_I:
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("rotate count too large"));
+      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", AT, sreg,
+		   (int) (imm_expr.X_add_number & 0x1f));
+      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", dreg, sreg,
+		   (int) ((0 - imm_expr.X_add_number) & 0x1f));
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", dreg, dreg, AT);
+      break;
+
+    case M_S_DOB:
+      if (mips_cpu == 4650)
+	{
+	  as_bad (_("opcode not supported on this processor"));
+	  return;
+	}
+      assert (mips_opts.isa == 1);
+      /* Even on a big endian machine $fn comes before $fn+1.  We have
+	 to adjust when storing to memory.  */
+      macro_build ((char *) NULL, &icnt, &offset_expr, "swc1", "T,o(b)",
+		   target_big_endian ? treg + 1 : treg,
+		   (int) BFD_RELOC_LO16, breg);
+      offset_expr.X_add_number += 4;
+      macro_build ((char *) NULL, &icnt, &offset_expr, "swc1", "T,o(b)",
+		   target_big_endian ? treg : treg + 1,
+		   (int) BFD_RELOC_LO16, breg);
+      return;
+
+    case M_SEQ:
+      if (sreg == 0)
+	macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
+		     treg, (int) BFD_RELOC_LO16);
+      else if (treg == 0)
+	macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
+		     sreg, (int) BFD_RELOC_LO16);
+      else
+	{
+	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
+		       sreg, treg);
+	  macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
+		       dreg, (int) BFD_RELOC_LO16);
+	}
+      return;
+
+    case M_SEQ_I:
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg,
+		       sreg, (int) BFD_RELOC_LO16);
+	  return;
+	}
+      if (sreg == 0)
+	{
+	  as_warn (_("Instruction %s: result is always false"),
+		   ip->insn_mo->name);
+	  macro_build ((char *) NULL, &icnt, NULL, "move", "d,s", dreg, 0);
+	  return;
+	}
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= 0
+	  && imm_expr.X_add_number < 0x10000)
+	{
+	  macro_build ((char *) NULL, &icnt, &imm_expr, "xori", "t,r,i", dreg,
+		       sreg, (int) BFD_RELOC_LO16);
+	  used_at = 0;
+	}
+      else if (imm_expr.X_op == O_constant
+	       && imm_expr.X_add_number > -0x8000
+	       && imm_expr.X_add_number < 0)
+	{
+	  imm_expr.X_add_number = -imm_expr.X_add_number;
+	  macro_build ((char *) NULL, &icnt, &imm_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", dreg, sreg,
+		       (int) BFD_RELOC_LO16);
+	  used_at = 0;
+	}
+      else
+	{
+	  load_register (&icnt, AT, &imm_expr, 0);
+	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
+		       sreg, AT);
+	  used_at = 1;
+	}
+      macro_build ((char *) NULL, &icnt, &expr1, "sltiu", "t,r,j", dreg, dreg,
+		   (int) BFD_RELOC_LO16);
+      if (used_at)
+	break;
+      return;
+
+    case M_SGE:		/* sreg >= treg <==> not (sreg < treg) */
+      s = "slt";
+      goto sge;
+    case M_SGEU:
+      s = "sltu";
+    sge:
+      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, sreg, treg);
+      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
+		   (int) BFD_RELOC_LO16);
+      return;
+
+    case M_SGE_I:		/* sreg >= I <==> not (sreg < I) */
+    case M_SGEU_I:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= -0x8000
+	  && imm_expr.X_add_number < 0x8000)
+	{
+	  macro_build ((char *) NULL, &icnt, &imm_expr,
+		       mask == M_SGE_I ? "slti" : "sltiu",
+		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
+	  used_at = 0;
+	}
+      else
+	{
+	  load_register (&icnt, AT, &imm_expr, 0);
+	  macro_build ((char *) NULL, &icnt, NULL,
+		       mask == M_SGE_I ? "slt" : "sltu",
+		       "d,v,t", dreg, sreg, AT);
+	  used_at = 1;
+	}
+      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
+		   (int) BFD_RELOC_LO16);
+      if (used_at)
+	break;
+      return;
+
+    case M_SGT:		/* sreg > treg  <==>  treg < sreg */
+      s = "slt";
+      goto sgt;
+    case M_SGTU:
+      s = "sltu";
+    sgt:
+      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, treg, sreg);
+      return;
+
+    case M_SGT_I:		/* sreg > I  <==>  I < sreg */
+      s = "slt";
+      goto sgti;
+    case M_SGTU_I:
+      s = "sltu";
+    sgti:
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, AT, sreg);
+      break;
+
+    case M_SLE:		/* sreg <= treg  <==>  treg >= sreg  <==>  not (treg < sreg) */
+      s = "slt";
+      goto sle;
+    case M_SLEU:
+      s = "sltu";
+    sle:
+      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, treg, sreg);
+      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
+		   (int) BFD_RELOC_LO16);
+      return;
+
+    case M_SLE_I:		/* sreg <= I <==> I >= sreg <==> not (I < sreg) */
+      s = "slt";
+      goto slei;
+    case M_SLEU_I:
+      s = "sltu";
+    slei:
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, NULL, s, "d,v,t", dreg, AT, sreg);
+      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", dreg, dreg,
+		   (int) BFD_RELOC_LO16);
+      break;
+
+    case M_SLT_I:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= -0x8000
+	  && imm_expr.X_add_number < 0x8000)
+	{
+	  macro_build ((char *) NULL, &icnt, &imm_expr, "slti", "t,r,j",
+		       dreg, sreg, (int) BFD_RELOC_LO16);
+	  return;
+	}
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, NULL, "slt", "d,v,t", dreg, sreg, AT);
+      break;
+
+    case M_SLTU_I:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= -0x8000
+	  && imm_expr.X_add_number < 0x8000)
+	{
+	  macro_build ((char *) NULL, &icnt, &imm_expr, "sltiu", "t,r,j",
+		       dreg, sreg, (int) BFD_RELOC_LO16);
+	  return;
+	}
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, sreg,
+		   AT);
+      break;
+
+    case M_SNE:
+      if (sreg == 0)
+	macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
+		     treg);
+      else if (treg == 0)
+	macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
+		     sreg);
+      else
+	{
+	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
+		       sreg, treg);
+	  macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
+		       dreg);
+	}
+      return;
+
+    case M_SNE_I:
+      if (imm_expr.X_op == O_constant && imm_expr.X_add_number == 0)
+	{
+	  macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0,
+		       sreg);
+	  return;
+	}
+      if (sreg == 0)
+	{
+	  as_warn (_("Instruction %s: result is always true"),
+		   ip->insn_mo->name);
+	  macro_build ((char *) NULL, &icnt, &expr1,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", dreg, 0, (int) BFD_RELOC_LO16);
+	  return;
+	}
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number >= 0
+	  && imm_expr.X_add_number < 0x10000)
+	{
+	  macro_build ((char *) NULL, &icnt, &imm_expr, "xori", "t,r,i",
+		       dreg, sreg, (int) BFD_RELOC_LO16);
+	  used_at = 0;
+	}
+      else if (imm_expr.X_op == O_constant
+	       && imm_expr.X_add_number > -0x8000
+	       && imm_expr.X_add_number < 0)
+	{
+	  imm_expr.X_add_number = -imm_expr.X_add_number;
+	  macro_build ((char *) NULL, &icnt, &imm_expr,
+		       ((bfd_arch_bits_per_address (stdoutput) == 32
+			 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		        ? "addiu" : "daddiu"),
+		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
+	  used_at = 0;
+	}
+      else
+	{
+	  load_register (&icnt, AT, &imm_expr, 0);
+	  macro_build ((char *) NULL, &icnt, NULL, "xor", "d,v,t", dreg,
+		       sreg, AT);
+	  used_at = 1;
+	}
+      macro_build ((char *) NULL, &icnt, NULL, "sltu", "d,v,t", dreg, 0, dreg);
+      if (used_at)
+	break;
+      return;
+
+    case M_DSUB_I:
+      dbl = 1;
+    case M_SUB_I:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number > -0x8000
+	  && imm_expr.X_add_number <= 0x8000)
+	{
+	  imm_expr.X_add_number = -imm_expr.X_add_number;
+	  macro_build ((char *) NULL, &icnt, &imm_expr,
+		       dbl ? "daddi" : "addi",
+		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
+	  return;
+	}
+      load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dsub" : "sub",
+		   "d,v,t", dreg, sreg, AT);
+      break;
+
+    case M_DSUBU_I:
+      dbl = 1;
+    case M_SUBU_I:
+      if (imm_expr.X_op == O_constant
+	  && imm_expr.X_add_number > -0x8000
+	  && imm_expr.X_add_number <= 0x8000)
+	{
+	  imm_expr.X_add_number = -imm_expr.X_add_number;
+	  macro_build ((char *) NULL, &icnt, &imm_expr,
+		       dbl ? "daddiu" : "addiu",
+		       "t,r,j", dreg, sreg, (int) BFD_RELOC_LO16);
+	  return;
+	}
+      load_register (&icnt, AT, &imm_expr, dbl);
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dsubu" : "subu",
+		   "d,v,t", dreg, sreg, AT);
+      break;
+
+    case M_TEQ_I:
+      s = "teq";
+      goto trap;
+    case M_TGE_I:
+      s = "tge";
+      goto trap;
+    case M_TGEU_I:
+      s = "tgeu";
+      goto trap;
+    case M_TLT_I:
+      s = "tlt";
+      goto trap;
+    case M_TLTU_I:
+      s = "tltu";
+      goto trap;
+    case M_TNE_I:
+      s = "tne";
+    trap:
+      load_register (&icnt, AT, &imm_expr, 0);
+      macro_build ((char *) NULL, &icnt, NULL, s, "s,t", sreg, AT);
+      break;
+
+    case M_TRUNCWD:
+    case M_TRUNCWS:
+      assert (mips_opts.isa == 1);
+      sreg = (ip->insn_opcode >> 11) & 0x1f;	/* floating reg */
+      dreg = (ip->insn_opcode >> 06) & 0x1f;	/* floating reg */
+
+      /*
+       * Is the double cfc1 instruction a bug in the mips assembler;
+       * or is there a reason for it?
+       */
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      macro_build ((char *) NULL, &icnt, NULL, "cfc1", "t,G", treg, 31);
+      macro_build ((char *) NULL, &icnt, NULL, "cfc1", "t,G", treg, 31);
+      macro_build ((char *) NULL, &icnt, NULL, "nop", "");
+      expr1.X_add_number = 3;
+      macro_build ((char *) NULL, &icnt, &expr1, "ori", "t,r,i", AT, treg,
+		   (int) BFD_RELOC_LO16);
+      expr1.X_add_number = 2;
+      macro_build ((char *) NULL, &icnt, &expr1, "xori", "t,r,i", AT, AT,
+		     (int) BFD_RELOC_LO16);
+      macro_build ((char *) NULL, &icnt, NULL, "ctc1", "t,G", AT, 31);
+      macro_build ((char *) NULL, &icnt, NULL, "nop", "");
+      macro_build ((char *) NULL, &icnt, NULL,
+	      mask == M_TRUNCWD ? "cvt.w.d" : "cvt.w.s", "D,S", dreg, sreg);
+      macro_build ((char *) NULL, &icnt, NULL, "ctc1", "t,G", treg, 31);
+      macro_build ((char *) NULL, &icnt, NULL, "nop", "");
+      --mips_opts.noreorder;
+      break;
+
+    case M_ULH:
+      s = "lb";
+      goto ulh;
+    case M_ULHU:
+      s = "lbu";
+    ulh:
+      if (offset_expr.X_add_number >= 0x7fff)
+	as_bad (_("operand overflow"));
+      /* avoid load delay */
+      if (! target_big_endian)
+	offset_expr.X_add_number += 1;
+      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      if (! target_big_endian)
+	offset_expr.X_add_number -= 1;
+      else
+	offset_expr.X_add_number += 1;
+      macro_build ((char *) NULL, &icnt, &offset_expr, "lbu", "t,o(b)", AT,
+		   (int) BFD_RELOC_LO16, breg);
+      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", treg, treg, 8);
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", treg, treg, AT);
+      break;
+
+    case M_ULD:
+      s = "ldl";
+      s2 = "ldr";
+      off = 7;
+      goto ulw;
+    case M_ULW:
+      s = "lwl";
+      s2 = "lwr";
+      off = 3;
+    ulw:
+      if (offset_expr.X_add_number >= 0x8000 - off)
+	as_bad (_("operand overflow"));
+      if (! target_big_endian)
+	offset_expr.X_add_number += off;
+      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      if (! target_big_endian)
+	offset_expr.X_add_number -= off;
+      else
+	offset_expr.X_add_number += off;
+      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      return;
+
+    case M_ULD_A:
+      s = "ldl";
+      s2 = "ldr";
+      off = 7;
+      goto ulwa;
+    case M_ULW_A:
+      s = "lwl";
+      s2 = "lwr";
+      off = 3;
+    ulwa:
+      load_address (&icnt, AT, &offset_expr);
+      if (breg != 0)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		     ((bfd_arch_bits_per_address (stdoutput) == 32
+		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		      ? "addu" : "daddu"),
+		     "d,v,t", AT, AT, breg);
+      if (! target_big_endian)
+	expr1.X_add_number = off;
+      else
+	expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1, s, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      if (! target_big_endian)
+	expr1.X_add_number = 0;
+      else
+	expr1.X_add_number = off;
+      macro_build ((char *) NULL, &icnt, &expr1, s2, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      break;
+
+    case M_ULH_A:
+    case M_ULHU_A:
+      load_address (&icnt, AT, &offset_expr);
+      if (breg != 0)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		     ((bfd_arch_bits_per_address (stdoutput) == 32
+		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		      ? "addu" : "daddu"),
+		     "d,v,t", AT, AT, breg);
+      if (target_big_endian)
+	expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1,
+		   mask == M_ULH_A ? "lb" : "lbu", "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      if (target_big_endian)
+	expr1.X_add_number = 1;
+      else
+	expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1, "lbu", "t,o(b)", AT,
+		   (int) BFD_RELOC_LO16, AT);
+      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", treg,
+		   treg, 8);
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", treg,
+		   treg, AT);
+      break;
+
+    case M_USH:
+      if (offset_expr.X_add_number >= 0x7fff)
+	as_bad (_("operand overflow"));
+      if (target_big_endian)
+	offset_expr.X_add_number += 1;
+      macro_build ((char *) NULL, &icnt, &offset_expr, "sb", "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", AT, treg, 8);
+      if (target_big_endian)
+	offset_expr.X_add_number -= 1;
+      else
+	offset_expr.X_add_number += 1;
+      macro_build ((char *) NULL, &icnt, &offset_expr, "sb", "t,o(b)", AT,
+		   (int) BFD_RELOC_LO16, breg);
+      break;
+
+    case M_USD:
+      s = "sdl";
+      s2 = "sdr";
+      off = 7;
+      goto usw;
+    case M_USW:
+      s = "swl";
+      s2 = "swr";
+      off = 3;
+    usw:
+      if (offset_expr.X_add_number >= 0x8000 - off)
+	as_bad (_("operand overflow"));
+      if (! target_big_endian)
+	offset_expr.X_add_number += off;
+      macro_build ((char *) NULL, &icnt, &offset_expr, s, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      if (! target_big_endian)
+	offset_expr.X_add_number -= off;
+      else
+	offset_expr.X_add_number += off;
+      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, breg);
+      return;
+
+    case M_USD_A:
+      s = "sdl";
+      s2 = "sdr";
+      off = 7;
+      goto uswa;
+    case M_USW_A:
+      s = "swl";
+      s2 = "swr";
+      off = 3;
+    uswa:
+      load_address (&icnt, AT, &offset_expr);
+      if (breg != 0)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		     ((bfd_arch_bits_per_address (stdoutput) == 32
+		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		      ? "addu" : "daddu"),
+		     "d,v,t", AT, AT, breg);
+      if (! target_big_endian)
+	expr1.X_add_number = off;
+      else
+	expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1, s, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      if (! target_big_endian)
+	expr1.X_add_number = 0;
+      else
+	expr1.X_add_number = off;
+      macro_build ((char *) NULL, &icnt, &expr1, s2, "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      break;
+
+    case M_USH_A:
+      load_address (&icnt, AT, &offset_expr);
+      if (breg != 0)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		     ((bfd_arch_bits_per_address (stdoutput) == 32
+		       || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		      ? "addu" : "daddu"),
+		     "d,v,t", AT, AT, breg);
+      if (! target_big_endian)
+	expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1, "sb", "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      macro_build ((char *) NULL, &icnt, NULL, "srl", "d,w,<", treg,
+		   treg, 8);
+      if (! target_big_endian)
+	expr1.X_add_number = 1;
+      else
+	expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1, "sb", "t,o(b)", treg,
+		   (int) BFD_RELOC_LO16, AT);
+      if (! target_big_endian)
+	expr1.X_add_number = 0;
+      else
+	expr1.X_add_number = 1;
+      macro_build ((char *) NULL, &icnt, &expr1, "lbu", "t,o(b)", AT,
+		   (int) BFD_RELOC_LO16, AT);
+      macro_build ((char *) NULL, &icnt, NULL, "sll", "d,w,<", treg,
+		   treg, 8);
+      macro_build ((char *) NULL, &icnt, NULL, "or", "d,v,t", treg,
+		   treg, AT);
+      break;
+
+    default:
+      /* FIXME: Check if this is one of the itbl macros, since they
+	 are added dynamically. */
+      as_bad (_("Macro %s not implemented yet"), ip->insn_mo->name);
+      break;
+    }
+  if (mips_opts.noat)
+    as_warn (_("Macro used $at after \".set noat\""));
+}
+
+/* Implement macros in mips16 mode.  */
+
+static void
+mips16_macro (ip)
+     struct mips_cl_insn *ip;
+{
+  int mask;
+  int xreg, yreg, zreg, tmp;
+  int icnt;
+  expressionS expr1;
+  int dbl;
+  const char *s, *s2, *s3;
+
+  mask = ip->insn_mo->mask;
+
+  xreg = (ip->insn_opcode >> MIPS16OP_SH_RX) & MIPS16OP_MASK_RX;
+  yreg = (ip->insn_opcode >> MIPS16OP_SH_RY) & MIPS16OP_MASK_RY;
+  zreg = (ip->insn_opcode >> MIPS16OP_SH_RZ) & MIPS16OP_MASK_RZ;
+
+  icnt = 0;
+
+  expr1.X_op = O_constant;
+  expr1.X_op_symbol = NULL;
+  expr1.X_add_symbol = NULL;
+  expr1.X_add_number = 1;
+
+  dbl = 0;
+
+  switch (mask)
+    {
+    default:
+      internalError ();
+
+    case M_DDIV_3:
+      dbl = 1;
+    case M_DIV_3:
+      s = "mflo";
+      goto do_div3;
+    case M_DREM_3:
+      dbl = 1;
+    case M_REM_3:
+      s = "mfhi";
+    do_div3:
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "ddiv" : "div",
+		   "0,x,y", xreg, yreg);
+      expr1.X_add_number = 2;
+      macro_build ((char *) NULL, &icnt, &expr1, "bnez", "x,p", yreg);
+	macro_build ((char *) NULL, &icnt, NULL, "break", "6", 7);
+      
+      /* FIXME: The normal code checks for of -1 / -0x80000000 here,
+         since that causes an overflow.  We should do that as well,
+         but I don't see how to do the comparisons without a temporary
+         register.  */
+      --mips_opts.noreorder;
+      macro_build ((char *) NULL, &icnt, NULL, s, "x", zreg);
+      break;
+
+    case M_DIVU_3:
+      s = "divu";
+      s2 = "mflo";
+      goto do_divu3;
+    case M_REMU_3:
+      s = "divu";
+      s2 = "mfhi";
+      goto do_divu3;
+    case M_DDIVU_3:
+      s = "ddivu";
+      s2 = "mflo";
+      goto do_divu3;
+    case M_DREMU_3:
+      s = "ddivu";
+      s2 = "mfhi";
+    do_divu3:
+      mips_emit_delays (true);
+      ++mips_opts.noreorder;
+      mips_any_noreorder = 1;
+      macro_build ((char *) NULL, &icnt, NULL, s, "0,x,y", xreg, yreg);
+      expr1.X_add_number = 2;
+      macro_build ((char *) NULL, &icnt, &expr1, "bnez", "x,p", yreg);
+	macro_build ((char *) NULL, &icnt, NULL, "break", "6", 7);
+      --mips_opts.noreorder;
+      macro_build ((char *) NULL, &icnt, NULL, s2, "x", zreg);
+      break;
+
+    case M_DMUL:
+      dbl = 1;
+    case M_MUL:
+      macro_build ((char *) NULL, &icnt, NULL,
+		   dbl ? "dmultu" : "multu",
+		   "x,y", xreg, yreg);
+      macro_build ((char *) NULL, &icnt, NULL, "mflo", "x", zreg);
+      return;
+
+    case M_DSUBU_I:
+      dbl = 1;
+      goto do_subu;
+    case M_SUBU_I:
+    do_subu:
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number = -imm_expr.X_add_number;
+      macro_build ((char *) NULL, &icnt, &imm_expr,
+		   dbl ? "daddiu" : "addiu",
+		   "y,x,4", yreg, xreg);
+      break;
+
+    case M_SUBU_I_2:
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number = -imm_expr.X_add_number;
+      macro_build ((char *) NULL, &icnt, &imm_expr, "addiu",
+		   "x,k", xreg);
+      break;
+
+    case M_DSUBU_I_2:
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      imm_expr.X_add_number = -imm_expr.X_add_number;
+      macro_build ((char *) NULL, &icnt, &imm_expr, "daddiu",
+		   "y,j", yreg);
+      break;
+
+    case M_BEQ:
+      s = "cmp";
+      s2 = "bteqz";
+      goto do_branch;
+    case M_BNE:
+      s = "cmp";
+      s2 = "btnez";
+      goto do_branch;
+    case M_BLT:
+      s = "slt";
+      s2 = "btnez";
+      goto do_branch;
+    case M_BLTU:
+      s = "sltu";
+      s2 = "btnez";
+      goto do_branch;
+    case M_BLE:
+      s = "slt";
+      s2 = "bteqz";
+      goto do_reverse_branch;
+    case M_BLEU:
+      s = "sltu";
+      s2 = "bteqz";
+      goto do_reverse_branch;
+    case M_BGE:
+      s = "slt";
+      s2 = "bteqz";
+      goto do_branch;
+    case M_BGEU:
+      s = "sltu";
+      s2 = "bteqz";
+      goto do_branch;
+    case M_BGT:
+      s = "slt";
+      s2 = "btnez";
+      goto do_reverse_branch;
+    case M_BGTU:
+      s = "sltu";
+      s2 = "btnez";
+
+    do_reverse_branch:
+      tmp = xreg;
+      xreg = yreg;
+      yreg = tmp;
+
+    do_branch:
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL, s, "x,y",
+		   xreg, yreg);
+      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "p");
+      break;
+
+    case M_BEQ_I:
+      s = "cmpi";
+      s2 = "bteqz";
+      s3 = "x,U";
+      goto do_branch_i;
+    case M_BNE_I:
+      s = "cmpi";
+      s2 = "btnez";
+      s3 = "x,U";
+      goto do_branch_i;
+    case M_BLT_I:
+      s = "slti";
+      s2 = "btnez";
+      s3 = "x,8";
+      goto do_branch_i;
+    case M_BLTU_I:
+      s = "sltiu";
+      s2 = "btnez";
+      s3 = "x,8";
+      goto do_branch_i;
+    case M_BLE_I:
+      s = "slti";
+      s2 = "btnez";
+      s3 = "x,8";
+      goto do_addone_branch_i;
+    case M_BLEU_I:
+      s = "sltiu";
+      s2 = "btnez";
+      s3 = "x,8";
+      goto do_addone_branch_i;
+    case M_BGE_I:
+      s = "slti";
+      s2 = "bteqz";
+      s3 = "x,8";
+      goto do_branch_i;
+    case M_BGEU_I:
+      s = "sltiu";
+      s2 = "bteqz";
+      s3 = "x,8";
+      goto do_branch_i;
+    case M_BGT_I:
+      s = "slti";
+      s2 = "bteqz";
+      s3 = "x,8";
+      goto do_addone_branch_i;
+    case M_BGTU_I:
+      s = "sltiu";
+      s2 = "bteqz";
+      s3 = "x,8";
+
+    do_addone_branch_i:
+      if (imm_expr.X_op != O_constant)
+	as_bad (_("Unsupported large constant"));
+      ++imm_expr.X_add_number;
+
+    do_branch_i:
+      macro_build ((char *) NULL, &icnt, &imm_expr, s, s3, xreg);
+      macro_build ((char *) NULL, &icnt, &offset_expr, s2, "p");
+      break;
+
+    case M_ABS:
+      expr1.X_add_number = 0;
+      macro_build ((char *) NULL, &icnt, &expr1, "slti", "x,8",  yreg);
+      if (xreg != yreg)
+	macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		     "move", "y,X", xreg, yreg);
+      expr1.X_add_number = 2;
+      macro_build ((char *) NULL, &icnt, &expr1, "bteqz", "p");
+      macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+		   "neg", "x,w", xreg, xreg);
+    }
+}
+
+/* For consistency checking, verify that all bits are specified either
+   by the match/mask part of the instruction definition, or by the
+   operand list.  */
+static int
+validate_mips_insn (opc)
+     const struct mips_opcode *opc;
+{
+  const char *p = opc->args;
+  char c;
+  unsigned long used_bits = opc->mask;
+
+  if ((used_bits & opc->match) != opc->match)
+    {
+      as_bad (_("internal: bad mips opcode (mask error): %s %s"),
+	      opc->name, opc->args);
+      return 0;
+    }
+#define USE_BITS(mask,shift)	(used_bits |= ((mask) << (shift)))
+  while (*p)
+    switch (c = *p++)
+      {
+      case ',': break;
+      case '(': break;
+      case ')': break;
+      case '<': USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
+      case '>':	USE_BITS (OP_MASK_SHAMT,	OP_SH_SHAMT);	break;
+      case 'A': break;
+      case 'B':	USE_BITS (OP_MASK_SYSCALL,	OP_SH_SYSCALL);	break;
+      case 'C':	USE_BITS (OP_MASK_COPZ,		OP_SH_COPZ);	break;
+      case 'D':	USE_BITS (OP_MASK_FD,		OP_SH_FD);	break;
+      case 'E':	USE_BITS (OP_MASK_RT,		OP_SH_RT);	break;
+      case 'F': break;
+      case 'G':	USE_BITS (OP_MASK_RD,		OP_SH_RD);	break;
+      case 'I': break;
+      case 'L': break;
+      case 'M':	USE_BITS (OP_MASK_CCC,		OP_SH_CCC);	break;
+      case 'N':	USE_BITS (OP_MASK_BCC,		OP_SH_BCC);	break;
+      case 'R':	USE_BITS (OP_MASK_FR,		OP_SH_FR);	break;
+      case 'S':	USE_BITS (OP_MASK_FS,		OP_SH_FS);	break;
+      case 'T':	USE_BITS (OP_MASK_FT,		OP_SH_FT);	break;
+      case 'V':	USE_BITS (OP_MASK_FS,		OP_SH_FS);	break;
+      case 'W':	USE_BITS (OP_MASK_FT,		OP_SH_FT);	break;
+      case 'a':	USE_BITS (OP_MASK_TARGET,	OP_SH_TARGET);	break;
+      case 'b':	USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
+      case 'c':	USE_BITS (OP_MASK_CODE,		OP_SH_CODE);	break;
+      case 'd':	USE_BITS (OP_MASK_RD,		OP_SH_RD);	break;
+      case 'f': break;
+      case 'h':	USE_BITS (OP_MASK_PREFX,	OP_SH_PREFX);	break;
+      case 'i':	USE_BITS (OP_MASK_IMMEDIATE,	OP_SH_IMMEDIATE); break;
+      case 'j':	USE_BITS (OP_MASK_DELTA,	OP_SH_DELTA);	break;
+      case 'k':	USE_BITS (OP_MASK_CACHE,	OP_SH_CACHE);	break;
+      case 'l': break;
+      case 'o': USE_BITS (OP_MASK_DELTA,	OP_SH_DELTA);	break;
+      case 'p':	USE_BITS (OP_MASK_DELTA,	OP_SH_DELTA);	break;
+      case 'q':	USE_BITS (OP_MASK_CODE2,	OP_SH_CODE2);	break;
+      case 'r': USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
+      case 's':	USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
+      case 't':	USE_BITS (OP_MASK_RT,		OP_SH_RT);	break;
+      case 'u':	USE_BITS (OP_MASK_IMMEDIATE,	OP_SH_IMMEDIATE); break;
+      case 'v':	USE_BITS (OP_MASK_RS,		OP_SH_RS);	break;
+      case 'w':	USE_BITS (OP_MASK_RT,		OP_SH_RT);	break;
+      case 'x': break;
+      case 'z': break;
+      case 'P': USE_BITS (OP_MASK_PERFREG,	OP_SH_PERFREG);	break;
+      default:
+	as_bad (_("internal: bad mips opcode (unknown operand type `%c'): %s %s"),
+		c, opc->name, opc->args);
+	return 0;
+      }
+#undef USE_BITS
+  if (used_bits != 0xffffffff)
+    {
+      as_bad (_("internal: bad mips opcode (bits 0x%lx undefined): %s %s"),
+	      ~used_bits & 0xffffffff, opc->name, opc->args);
+      return 0;
+    }
+  return 1;
+}
+
+/* This routine assembles an instruction into its binary format.  As a
+   side effect, it sets one of the global variables imm_reloc or
+   offset_reloc to the type of relocation to do if one of the operands
+   is an address expression.  */
+
+static void
+mips_ip (str, ip)
+     char *str;
+     struct mips_cl_insn *ip;
+{
+  char *s;
+  const char *args;
+  char c;
+  struct mips_opcode *insn;
+  char *argsStart;
+  unsigned int regno;
+  unsigned int lastregno = 0;
+  char *s_reset;
+  char save_c = 0;
+  int full_opcode_match = 1;
+
+  insn_error = NULL;
+
+  /* If the instruction contains a '.', we first try to match an instruction
+     including the '.'.  Then we try again without the '.'.  */
+  insn = NULL;
+  for (s = str; *s != '\0' && !isspace ((unsigned char) *s); ++s)
+    continue;
+
+  /* If we stopped on whitespace, then replace the whitespace with null for
+     the call to hash_find.  Save the character we replaced just in case we
+     have to re-parse the instruction.  */
+  if (isspace ((unsigned char) *s))
+    {
+      save_c = *s;
+      *s++ = '\0';
+    }
+	
+  insn = (struct mips_opcode *) hash_find (op_hash, str);
+
+  /* If we didn't find the instruction in the opcode table, try again, but
+     this time with just the instruction up to, but not including the
+     first '.'.  */
+  if (insn == NULL)
+    {
+      /* Restore the character we overwrite above (if any).  */ 
+      if (save_c)
+	*(--s) = save_c;
+
+      /* Scan up to the first '.' or whitespace.  */
+      for (s = str; *s != '\0' && *s != '.' && !isspace ((unsigned char) *s); ++s)
+	continue;
+
+      /* If we did not find a '.', then we can quit now.  */
+      if (*s != '.')
+	{
+	  insn_error = "unrecognized opcode";
+	  return;
+	}
+
+      /* Lookup the instruction in the hash table.  */
+      *s++ = '\0';
+      if ((insn = (struct mips_opcode *) hash_find (op_hash, str)) == NULL)
+	{
+	  insn_error = "unrecognized opcode";
+	  return;
+	}
+
+      full_opcode_match = 0;
+    }
+
+  argsStart = s;
+  for (;;)
+    {
+      boolean ok;
+
+      assert (strcmp (insn->name, str) == 0);
+
+      if (OPCODE_IS_MEMBER (insn, mips_opts.isa, mips_cpu, mips_gp32))
+	ok = true;
+      else 
+	ok = false;
+      
+      if (insn->pinfo != INSN_MACRO)
+	{
+	  if (mips_cpu == 4650 && (insn->pinfo & FP_D) != 0)
+	    ok = false;
+	}
+
+      if (! ok)
+	{
+	  if (insn + 1 < &mips_opcodes[NUMOPCODES]
+	      && strcmp (insn->name, insn[1].name) == 0)
+	    {
+	      ++insn;
+	      continue;
+	    }
+	  else
+	    {
+	      static char buf[100];
+	      sprintf (buf, 
+		       _("opcode not supported on this processor: %d (MIPS%d)"),
+		       mips_cpu, mips_opts.isa);
+		       
+	      insn_error = buf;
+	      return;
+	    }
+	}
+
+      ip->insn_mo = insn;
+      ip->insn_opcode = insn->match;
+      for (args = insn->args;; ++args)
+	{
+	  if (*s == ' ')
+	    ++s;
+	  switch (*args)
+	    {
+	    case '\0':		/* end of args */
+	      if (*s == '\0')
+		return;
+	      break;
+
+	    case ',':
+	      if (*s++ == *args)
+		continue;
+	      s--;
+	      switch (*++args)
+		{
+		case 'r':
+		case 'v':
+		  ip->insn_opcode |= lastregno << 21;
+		  continue;
+
+		case 'w':
+		case 'W':
+		  ip->insn_opcode |= lastregno << 16;
+		  continue;
+
+		case 'V':
+		  ip->insn_opcode |= lastregno << 11;
+		  continue;
+		}
+	      break;
+
+	    case '(':
+	      /* Handle optional base register.
+		 Either the base register is omitted or
+		 we must have a left paren. */
+	      /* This is dependent on the next operand specifier
+		 is a base register specification.  */
+	      assert (args[1] == 'b' || args[1] == '5'
+		      || args[1] == '-' || args[1] == '4');
+	      if (*s == '\0')
+		return;
+
+	    case ')':		/* these must match exactly */
+	      if (*s++ == *args)
+		continue;
+	      break;
+
+	    case '<':		/* must be at least one digit */
+	      /*
+	       * According to the manual, if the shift amount is greater
+	       * than 31 or less than 0 the the shift amount should be
+	       * mod 32. In reality the mips assembler issues an error.
+	       * We issue a warning and mask out all but the low 5 bits.
+	       */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned long) imm_expr.X_add_number > 31)
+		{
+		  as_warn (_("Improper shift amount (%ld)"),
+			   (long) imm_expr.X_add_number);
+		  imm_expr.X_add_number = imm_expr.X_add_number & 0x1f;
+		}
+	      ip->insn_opcode |= imm_expr.X_add_number << 6;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+	    case '>':		/* shift amount minus 32 */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned long) imm_expr.X_add_number < 32
+		  || (unsigned long) imm_expr.X_add_number > 63)
+		break;
+	      ip->insn_opcode |= (imm_expr.X_add_number - 32) << 6;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+
+	    case 'k':		/* cache code */
+	    case 'h':		/* prefx code */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned long) imm_expr.X_add_number > 31)
+		{
+		  as_warn (_("Invalid value for `%s' (%lu)"),
+			   ip->insn_mo->name,
+			   (unsigned long) imm_expr.X_add_number);
+		  imm_expr.X_add_number &= 0x1f;
+		}
+	      if (*args == 'k')
+		ip->insn_opcode |= imm_expr.X_add_number << OP_SH_CACHE;
+	      else
+		ip->insn_opcode |= imm_expr.X_add_number << OP_SH_PREFX;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+	    case 'c':		/* break code */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned) imm_expr.X_add_number > 1023)
+		{
+		  as_warn (_("Illegal break code (%ld)"),
+			   (long) imm_expr.X_add_number);
+		  imm_expr.X_add_number &= 0x3ff;
+		}
+	      ip->insn_opcode |= imm_expr.X_add_number << 16;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+	    case 'q':		/* lower break code */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned) imm_expr.X_add_number > 1023)
+		{
+		  as_warn (_("Illegal lower break code (%ld)"),
+			   (long) imm_expr.X_add_number);
+		  imm_expr.X_add_number &= 0x3ff;
+		}
+	      ip->insn_opcode |= imm_expr.X_add_number << 6;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+	    case 'B':		/* syscall code */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned) imm_expr.X_add_number > 0xfffff)
+		as_warn (_("Illegal syscall code (%ld)"),
+			 (long) imm_expr.X_add_number);
+	      ip->insn_opcode |= imm_expr.X_add_number << 6;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+            case 'C':           /* Coprocessor code */
+              my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+              if ((unsigned long) imm_expr.X_add_number >= (1<<25))
+		{
+                  as_warn (_("Coproccesor code > 25 bits (%ld)"),
+			   (long) imm_expr.X_add_number);
+                  imm_expr.X_add_number &= ((1<<25) - 1);
+		}
+              ip->insn_opcode |= imm_expr.X_add_number;
+              imm_expr.X_op = O_absent;
+              s = expr_end;
+              continue;
+
+	    case 'P':		/* Performance register */
+              my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+              if (imm_expr.X_add_number != 0 && imm_expr.X_add_number != 1)
+		{
+                  as_warn (_("Invalidate performance regster (%ld)"),
+			   (long) imm_expr.X_add_number);
+                  imm_expr.X_add_number &= 1;
+		}
+              ip->insn_opcode |= (imm_expr.X_add_number << 1);
+              imm_expr.X_op = O_absent;
+              s = expr_end;
+              continue;
+
+	    case 'b':		/* base register */
+	    case 'd':		/* destination register */
+	    case 's':		/* source register */
+	    case 't':		/* target register */
+	    case 'r':		/* both target and source */
+	    case 'v':		/* both dest and source */
+	    case 'w':		/* both dest and target */
+	    case 'E':		/* coprocessor target register */
+	    case 'G':		/* coprocessor destination register */
+	    case 'x':		/* ignore register name */
+	    case 'z':		/* must be zero register */
+	      s_reset = s;
+	      if (s[0] == '$')
+		{
+
+		  if (isdigit ((unsigned char) s[1]))
+		    {
+		      ++s;
+		      regno = 0;
+		      do
+			{
+			  regno *= 10;
+			  regno += *s - '0';
+			  ++s;
+			}
+		      while (isdigit ((unsigned char) *s));
+		      if (regno > 31)
+			as_bad (_("Invalid register number (%d)"), regno);
+		    }
+		  else if (*args == 'E' || *args == 'G')
+		    goto notreg;
+		  else
+		    {
+		      if (s[1] == 'f' && s[2] == 'p')
+			{
+			  s += 3;
+			  regno = FP;
+			}
+		      else if (s[1] == 's' && s[2] == 'p')
+			{
+			  s += 3;
+			  regno = SP;
+			}
+		      else if (s[1] == 'g' && s[2] == 'p')
+			{
+			  s += 3;
+			  regno = GP;
+			}
+		      else if (s[1] == 'a' && s[2] == 't')
+			{
+			  s += 3;
+			  regno = AT;
+			}
+		      else if (s[1] == 'k' && s[2] == 't' && s[3] == '0')
+			{
+			  s += 4;
+			  regno = KT0;
+			}
+		      else if (s[1] == 'k' && s[2] == 't' && s[3] == '1')
+			{
+			  s += 4;
+			  regno = KT1;
+			}
+		      else if (itbl_have_entries)
+			{
+			  char *p, *n;
+			  unsigned long r;
+
+			  p = s + 1; 	/* advance past '$' */
+			  n = itbl_get_field (&p);  /* n is name */
+
+			  /* See if this is a register defined in an
+			     itbl entry.  */
+			  if (itbl_get_reg_val (n, &r))
+			    {
+			      /* Get_field advances to the start of
+				 the next field, so we need to back
+				 rack to the end of the last field.  */
+			      if (p) 
+				s = p - 1;
+			      else 
+				s = strchr (s, '\0');
+			      regno = r;
+			    }
+			  else
+			    goto notreg;
+			  }
+		      else
+			goto notreg;
+		    }
+		  if (regno == AT
+		      && ! mips_opts.noat
+		      && *args != 'E'
+		      && *args != 'G')
+		    as_warn (_("Used $at without \".set noat\""));
+		  c = *args;
+		  if (*s == ' ')
+		    s++;
+		  if (args[1] != *s)
+		    {
+		      if (c == 'r' || c == 'v' || c == 'w')
+			{
+			  regno = lastregno;
+			  s = s_reset;
+			  args++;
+			}
+		    }
+		  /* 'z' only matches $0.  */
+		  if (c == 'z' && regno != 0)
+		    break;
+
+	/* Now that we have assembled one operand, we use the args string 
+	 * to figure out where it goes in the instruction. */
+		  switch (c)
+		    {
+		    case 'r':
+		    case 's':
+		    case 'v':
+		    case 'b':
+		      ip->insn_opcode |= regno << 21;
+		      break;
+		    case 'd':
+		    case 'G':
+		      ip->insn_opcode |= regno << 11;
+		      break;
+		    case 'w':
+		    case 't':
+		    case 'E':
+		      ip->insn_opcode |= regno << 16;
+		      break;
+		    case 'x':
+		      /* This case exists because on the r3000 trunc
+			 expands into a macro which requires a gp
+			 register.  On the r6000 or r4000 it is
+			 assembled into a single instruction which
+			 ignores the register.  Thus the insn version
+			 is MIPS_ISA2 and uses 'x', and the macro
+			 version is MIPS_ISA1 and uses 't'.  */
+		      break;
+		    case 'z':
+		      /* This case is for the div instruction, which
+			 acts differently if the destination argument
+			 is $0.  This only matches $0, and is checked
+			 outside the switch.  */
+		      break;
+		    case 'D':
+		      /* Itbl operand; not yet implemented. FIXME ?? */
+		      break;
+		      /* What about all other operands like 'i', which
+			 can be specified in the opcode table? */
+		    }
+		  lastregno = regno;
+		  continue;
+		}
+	    notreg:
+	      switch (*args++)
+		{
+		case 'r':
+		case 'v':
+		  ip->insn_opcode |= lastregno << 21;
+		  continue;
+		case 'w':
+		  ip->insn_opcode |= lastregno << 16;
+		  continue;
+		}
+	      break;
+
+	    case 'D':		/* floating point destination register */
+	    case 'S':		/* floating point source register */
+	    case 'T':		/* floating point target register */
+	    case 'R':		/* floating point source register */
+	    case 'V':
+	    case 'W':
+	      s_reset = s;
+	      if (s[0] == '$' && s[1] == 'f' && isdigit ((unsigned char) s[2]))
+		{
+		  s += 2;
+		  regno = 0;
+		  do
+		    {
+		      regno *= 10;
+		      regno += *s - '0';
+		      ++s;
+		    }
+		  while (isdigit ((unsigned char) *s));
+
+		  if (regno > 31)
+		    as_bad (_("Invalid float register number (%d)"), regno);
+
+		  if ((regno & 1) != 0
+		      && ! ISA_HAS_64BIT_REGS (mips_opts.isa)
+		      && ! (strcmp (str, "mtc1") == 0
+			    || strcmp (str, "mfc1") == 0
+			    || strcmp (str, "lwc1") == 0
+			    || strcmp (str, "swc1") == 0
+			    || strcmp (str, "l.s") == 0
+			    || strcmp (str, "s.s") == 0))
+		    as_warn (_("Float register should be even, was %d"),
+			     regno);
+
+		  c = *args;
+		  if (*s == ' ')
+		    s++;
+		  if (args[1] != *s)
+		    {
+		      if (c == 'V' || c == 'W')
+			{
+			  regno = lastregno;
+			  s = s_reset;
+			  args++;
+			}
+		    }
+		  switch (c)
+		    {
+		    case 'D':
+		      ip->insn_opcode |= regno << 6;
+		      break;
+		    case 'V':
+		    case 'S':
+		      ip->insn_opcode |= regno << 11;
+		      break;
+		    case 'W':
+		    case 'T':
+		      ip->insn_opcode |= regno << 16;
+		      break;
+		    case 'R':
+		      ip->insn_opcode |= regno << 21;
+		      break;
+		    }
+		  lastregno = regno;
+		  continue;
+		}
+
+
+	      switch (*args++)
+		{
+		case 'V':
+		  ip->insn_opcode |= lastregno << 11;
+		  continue;
+		case 'W':
+		  ip->insn_opcode |= lastregno << 16;
+		  continue;
+		}
+	      break;
+
+	    case 'I':
+	      my_getExpression (&imm_expr, s);
+	      if (imm_expr.X_op != O_big
+		  && imm_expr.X_op != O_constant)
+		insn_error = _("absolute expression required");
+	      s = expr_end;
+	      continue;
+
+	    case 'A':
+	      my_getExpression (&offset_expr, s);
+	      imm_reloc = BFD_RELOC_32;
+	      s = expr_end;
+	      continue;
+
+	    case 'F':
+	    case 'L':
+	    case 'f':
+	    case 'l':
+	      {
+		int f64;
+		char *save_in;
+		char *err;
+		unsigned char temp[8];
+		int len;
+		unsigned int length;
+		segT seg;
+		subsegT subseg;
+		char *p;
+
+		/* These only appear as the last operand in an
+		   instruction, and every instruction that accepts
+		   them in any variant accepts them in all variants.
+		   This means we don't have to worry about backing out
+		   any changes if the instruction does not match.
+
+		   The difference between them is the size of the
+		   floating point constant and where it goes.  For 'F'
+		   and 'L' the constant is 64 bits; for 'f' and 'l' it
+		   is 32 bits.  Where the constant is placed is based
+		   on how the MIPS assembler does things:
+		    F -- .rdata
+		    L -- .lit8
+		    f -- immediate value
+		    l -- .lit4
+
+		    The .lit4 and .lit8 sections are only used if
+		    permitted by the -G argument.
+
+		    When generating embedded PIC code, we use the
+		    .lit8 section but not the .lit4 section (we can do
+		    .lit4 inline easily; we need to put .lit8
+		    somewhere in the data segment, and using .lit8
+		    permits the linker to eventually combine identical
+		    .lit8 entries).  */
+
+		f64 = *args == 'F' || *args == 'L';
+
+		save_in = input_line_pointer;
+		input_line_pointer = s;
+		err = md_atof (f64 ? 'd' : 'f', (char *) temp, &len);
+		length = len;
+		s = input_line_pointer;
+		input_line_pointer = save_in;
+		if (err != NULL && *err != '\0')
+		  {
+		    as_bad (_("Bad floating point constant: %s"), err);
+		    memset (temp, '\0', sizeof temp);
+		    length = f64 ? 8 : 4;
+		  }
+
+		assert (length == (f64 ? 8 : 4));
+
+		if (*args == 'f'
+		    || (*args == 'l'
+			&& (! USE_GLOBAL_POINTER_OPT
+			    || mips_pic == EMBEDDED_PIC
+			    || g_switch_value < 4
+			    || (temp[0] == 0 && temp[1] == 0)
+			    || (temp[2] == 0 && temp[3] == 0))))
+		  {
+		    imm_expr.X_op = O_constant;
+		    if (! target_big_endian)
+		      imm_expr.X_add_number = bfd_getl32 (temp);
+		    else
+		      imm_expr.X_add_number = bfd_getb32 (temp);
+		  }
+		else if (length > 4
+			 && ((temp[0] == 0 && temp[1] == 0)
+			     || (temp[2] == 0 && temp[3] == 0))
+			 && ((temp[4] == 0 && temp[5] == 0)
+			     || (temp[6] == 0 && temp[7] == 0)))
+		  {
+		    /* The value is simple enough to load with a
+                       couple of instructions.  In mips1 mode, set
+                       imm_expr to the high order 32 bits and
+                       offset_expr to the low order 32 bits.
+                       Otherwise, set imm_expr to the entire 64 bit
+                       constant.  */
+		    if (! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		      {
+			imm_expr.X_op = O_constant;
+			offset_expr.X_op = O_constant;
+			if (! target_big_endian)
+			  {
+			    imm_expr.X_add_number = bfd_getl32 (temp + 4);
+			    offset_expr.X_add_number = bfd_getl32 (temp);
+			  }
+			else
+			  {
+			    imm_expr.X_add_number = bfd_getb32 (temp);
+			    offset_expr.X_add_number = bfd_getb32 (temp + 4);
+			  }
+			if (offset_expr.X_add_number == 0)
+			  offset_expr.X_op = O_absent;
+		      }
+		    else if (sizeof (imm_expr.X_add_number) > 4)
+		      {
+			imm_expr.X_op = O_constant;
+			if (! target_big_endian)
+			  imm_expr.X_add_number = bfd_getl64 (temp);
+			else
+			  imm_expr.X_add_number = bfd_getb64 (temp);
+		      }
+		    else
+		      {
+			imm_expr.X_op = O_big;
+			imm_expr.X_add_number = 4;
+			if (! target_big_endian)
+			  {
+			    generic_bignum[0] = bfd_getl16 (temp);
+			    generic_bignum[1] = bfd_getl16 (temp + 2);
+			    generic_bignum[2] = bfd_getl16 (temp + 4);
+			    generic_bignum[3] = bfd_getl16 (temp + 6);
+			  }
+			else
+			  {
+			    generic_bignum[0] = bfd_getb16 (temp + 6);
+			    generic_bignum[1] = bfd_getb16 (temp + 4);
+			    generic_bignum[2] = bfd_getb16 (temp + 2);
+			    generic_bignum[3] = bfd_getb16 (temp);
+			  }
+		      }
+		  }
+		else
+		  {
+		    const char *newname;
+		    segT new_seg;
+
+		    /* Switch to the right section.  */
+		    seg = now_seg;
+		    subseg = now_subseg;
+		    switch (*args)
+		      {
+		      default: /* unused default case avoids warnings.  */
+		      case 'L':
+			newname = RDATA_SECTION_NAME;
+			if ((USE_GLOBAL_POINTER_OPT && g_switch_value >= 8)
+			    || mips_pic == EMBEDDED_PIC)
+			  newname = ".lit8";
+			break;
+		      case 'F':
+			if (mips_pic == EMBEDDED_PIC)
+			  newname = ".lit8";
+			else
+			  newname = RDATA_SECTION_NAME;
+			break;
+		      case 'l':
+			assert (!USE_GLOBAL_POINTER_OPT
+				|| g_switch_value >= 4);
+			newname = ".lit4";
+			break;
+		      }
+		    new_seg = subseg_new (newname, (subsegT) 0);
+		    if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+		      bfd_set_section_flags (stdoutput, new_seg,
+					     (SEC_ALLOC
+					      | SEC_LOAD
+					      | SEC_READONLY
+					      | SEC_DATA));
+		    frag_align (*args == 'l' ? 2 : 3, 0, 0);
+		    if (OUTPUT_FLAVOR == bfd_target_elf_flavour
+			&& strcmp (TARGET_OS, "elf") != 0)
+		      record_alignment (new_seg, 4);
+		    else
+		      record_alignment (new_seg, *args == 'l' ? 2 : 3);
+		    if (seg == now_seg)
+		      as_bad (_("Can't use floating point insn in this section"));
+
+		    /* Set the argument to the current address in the
+		       section.  */
+		    offset_expr.X_op = O_symbol;
+		    offset_expr.X_add_symbol =
+		      symbol_new ("L0\001", now_seg,
+				  (valueT) frag_now_fix (), frag_now);
+		    offset_expr.X_add_number = 0;
+
+		    /* Put the floating point number into the section.  */
+		    p = frag_more ((int) length);
+		    memcpy (p, temp, length);
+
+		    /* Switch back to the original section.  */
+		    subseg_set (seg, subseg);
+		  }
+	      }
+	      continue;
+
+	    case 'i':		/* 16 bit unsigned immediate */
+	    case 'j':		/* 16 bit signed immediate */
+	      imm_reloc = BFD_RELOC_LO16;
+	      c = my_getSmallExpression (&imm_expr, s);
+	      if (c != '\0')
+		{
+		  if (c != 'l')
+		    {
+		      if (imm_expr.X_op == O_constant)
+			imm_expr.X_add_number =
+			  (imm_expr.X_add_number >> 16) & 0xffff;
+		      else if (c == 'h')
+			{
+			  imm_reloc = BFD_RELOC_HI16_S;
+			  imm_unmatched_hi = true;
+			}
+		      else
+			imm_reloc = BFD_RELOC_HI16;
+		    }
+		  else if (imm_expr.X_op == O_constant)
+		    imm_expr.X_add_number &= 0xffff;
+		}
+	      if (*args == 'i')
+		{
+		  if ((c == '\0' && imm_expr.X_op != O_constant)
+		      || ((imm_expr.X_add_number < 0
+                           || imm_expr.X_add_number >= 0x10000)
+                          && imm_expr.X_op == O_constant))
+		    {
+		      if (insn + 1 < &mips_opcodes[NUMOPCODES] &&
+			  !strcmp (insn->name, insn[1].name))
+			break;
+		      if (imm_expr.X_op != O_constant
+			  && imm_expr.X_op != O_big)
+			insn_error = _("absolute expression required");
+		      else
+			as_bad (_("16 bit expression not in range 0..65535"));
+		    }
+		}
+	      else
+		{
+		  int more;
+		  offsetT max;
+
+		  /* The upper bound should be 0x8000, but
+		     unfortunately the MIPS assembler accepts numbers
+		     from 0x8000 to 0xffff and sign extends them, and
+		     we want to be compatible.  We only permit this
+		     extended range for an instruction which does not
+		     provide any further alternates, since those
+		     alternates may handle other cases.  People should
+		     use the numbers they mean, rather than relying on
+		     a mysterious sign extension.  */
+		  more = (insn + 1 < &mips_opcodes[NUMOPCODES] &&
+			  strcmp (insn->name, insn[1].name) == 0);
+		  if (more)
+		    max = 0x8000;
+		  else
+		    max = 0x10000;
+		  if ((c == '\0' && imm_expr.X_op != O_constant)
+		      || ((imm_expr.X_add_number < -0x8000
+                           || imm_expr.X_add_number >= max)
+                          && imm_expr.X_op == O_constant)
+		      || (more
+			  && imm_expr.X_add_number < 0
+			  && ISA_HAS_64BIT_REGS (mips_opts.isa)
+			  && imm_expr.X_unsigned
+			  && sizeof (imm_expr.X_add_number) <= 4))
+		    {
+		      if (more)
+			break;
+		      if (imm_expr.X_op != O_constant
+			  && imm_expr.X_op != O_big)
+			insn_error = _("absolute expression required");
+		      else
+			as_bad (_("16 bit expression not in range -32768..32767"));
+		    }
+		}
+	      s = expr_end;
+	      continue;
+
+	    case 'o':		/* 16 bit offset */
+	      c = my_getSmallExpression (&offset_expr, s);
+
+	      /* If this value won't fit into a 16 bit offset, then go
+		 find a macro that will generate the 32 bit offset
+		 code pattern.  As a special hack, we accept the
+		 difference of two local symbols as a constant.  This
+		 is required to suppose embedded PIC switches, which
+		 use an instruction which looks like
+		     lw $4,$L12-$LS12($4)
+		 The problem with handling this in a more general
+		 fashion is that the macro function doesn't expect to
+		 see anything which can be handled in a single
+		 constant instruction.  */
+	      if (c == 0
+		  && (offset_expr.X_op != O_constant
+		      || offset_expr.X_add_number >= 0x8000
+		      || offset_expr.X_add_number < -0x8000)
+		  && (mips_pic != EMBEDDED_PIC
+		      || offset_expr.X_op != O_subtract
+		      || (S_GET_SEGMENT (offset_expr.X_op_symbol)
+			  != now_seg)))
+		break;
+
+	      if (c == 'h' || c == 'H')
+		{
+		  if (offset_expr.X_op != O_constant)
+		    break;
+		  offset_expr.X_add_number =
+		    (offset_expr.X_add_number >> 16) & 0xffff;
+		}
+	      offset_reloc = BFD_RELOC_LO16;
+	      s = expr_end;
+	      continue;
+
+	    case 'p':		/* pc relative offset */
+	      offset_reloc = BFD_RELOC_16_PCREL_S2;
+	      my_getExpression (&offset_expr, s);
+	      s = expr_end;
+	      continue;
+
+	    case 'u':		/* upper 16 bits */
+	      c = my_getSmallExpression (&imm_expr, s);
+	      imm_reloc = BFD_RELOC_LO16;
+	      if (c)
+		{
+		  if (c != 'l')
+		    {
+		      if (imm_expr.X_op == O_constant)
+			imm_expr.X_add_number =
+			  (imm_expr.X_add_number >> 16) & 0xffff;
+		      else if (c == 'h')
+			{
+			  imm_reloc = BFD_RELOC_HI16_S;
+			  imm_unmatched_hi = true;
+			}
+		      else
+			imm_reloc = BFD_RELOC_HI16;
+		    }
+		  else if (imm_expr.X_op == O_constant)
+		    imm_expr.X_add_number &= 0xffff;
+		}
+	      if (imm_expr.X_op == O_constant
+		  && (imm_expr.X_add_number < 0
+		      || imm_expr.X_add_number >= 0x10000))
+		as_bad (_("lui expression not in range 0..65535"));
+	      s = expr_end;
+	      continue;
+
+	    case 'a':		/* 26 bit address */
+	      my_getExpression (&offset_expr, s);
+	      s = expr_end;
+	      offset_reloc = BFD_RELOC_MIPS_JMP;
+	      continue;
+
+	    case 'N':		/* 3 bit branch condition code */
+	    case 'M':		/* 3 bit compare condition code */
+	      if (strncmp (s, "$fcc", 4) != 0)
+		break;
+	      s += 4;
+	      regno = 0;
+	      do
+		{
+		  regno *= 10;
+		  regno += *s - '0';
+		  ++s;
+		}
+	      while (isdigit ((unsigned char) *s));
+	      if (regno > 7)
+		as_bad (_("invalid condition code register $fcc%d"), regno);
+	      if (*args == 'N')
+		ip->insn_opcode |= regno << OP_SH_BCC;
+	      else
+		ip->insn_opcode |= regno << OP_SH_CCC;
+              continue;
+
+	    default:
+	      as_bad (_("bad char = '%c'\n"), *args);
+	      internalError ();
+	    }
+	  break;
+	}
+      /* Args don't match.  */
+      if (insn + 1 < &mips_opcodes[NUMOPCODES] &&
+	  !strcmp (insn->name, insn[1].name))
+	{
+	  ++insn;
+	  s = argsStart;
+	  continue;
+	}
+      insn_error = _("illegal operands");
+      return;
+    }
+}
+
+/* This routine assembles an instruction into its binary format when
+   assembling for the mips16.  As a side effect, it sets one of the
+   global variables imm_reloc or offset_reloc to the type of
+   relocation to do if one of the operands is an address expression.
+   It also sets mips16_small and mips16_ext if the user explicitly
+   requested a small or extended instruction.  */
+
+static void
+mips16_ip (str, ip)
+     char *str;
+     struct mips_cl_insn *ip;
+{
+  char *s;
+  const char *args;
+  struct mips_opcode *insn;
+  char *argsstart;
+  unsigned int regno;
+  unsigned int lastregno = 0;
+  char *s_reset;
+
+  insn_error = NULL;
+
+  mips16_small = false;
+  mips16_ext = false;
+
+  for (s = str; islower ((unsigned char) *s); ++s)
+    ;
+  switch (*s)
+    {
+    case '\0':
+      break;
+
+    case ' ':
+      *s++ = '\0';
+      break;
+
+    case '.':
+      if (s[1] == 't' && s[2] == ' ')
+	{
+	  *s = '\0';
+	  mips16_small = true;
+	  s += 3;
+	  break;
+	}
+      else if (s[1] == 'e' && s[2] == ' ')
+	{
+	  *s = '\0';
+	  mips16_ext = true;
+	  s += 3;
+	  break;
+	}
+      /* Fall through.  */
+    default:
+      insn_error = _("unknown opcode");
+      return;
+    }
+
+  if (mips_opts.noautoextend && ! mips16_ext)
+    mips16_small = true;
+
+  if ((insn = (struct mips_opcode *) hash_find (mips16_op_hash, str)) == NULL)
+    {
+      insn_error = _("unrecognized opcode");
+      return;
+    }
+
+  argsstart = s;
+  for (;;)
+    {
+      assert (strcmp (insn->name, str) == 0);
+
+      ip->insn_mo = insn;
+      ip->insn_opcode = insn->match;
+      ip->use_extend = false;
+      imm_expr.X_op = O_absent;
+      imm_reloc = BFD_RELOC_UNUSED;
+      offset_expr.X_op = O_absent;
+      offset_reloc = BFD_RELOC_UNUSED;
+      for (args = insn->args; 1; ++args)
+	{
+	  int c;
+
+	  if (*s == ' ')
+	    ++s;
+
+	  /* In this switch statement we call break if we did not find
+             a match, continue if we did find a match, or return if we
+             are done.  */
+
+	  c = *args;
+	  switch (c)
+	    {
+	    case '\0':
+	      if (*s == '\0')
+		{
+		  /* Stuff the immediate value in now, if we can.  */
+		  if (imm_expr.X_op == O_constant
+		      && imm_reloc > BFD_RELOC_UNUSED
+		      && insn->pinfo != INSN_MACRO)
+		    {
+		      mips16_immed ((char *) NULL, 0,
+				    imm_reloc - BFD_RELOC_UNUSED,
+				    imm_expr.X_add_number, true, mips16_small,
+				    mips16_ext, &ip->insn_opcode,
+				    &ip->use_extend, &ip->extend);
+		      imm_expr.X_op = O_absent;
+		      imm_reloc = BFD_RELOC_UNUSED;
+		    }
+
+		  return;
+		}
+	      break;
+
+	    case ',':
+	      if (*s++ == c)
+		continue;
+	      s--;
+	      switch (*++args)
+		{
+		case 'v':
+		  ip->insn_opcode |= lastregno << MIPS16OP_SH_RX;
+		  continue;
+		case 'w':
+		  ip->insn_opcode |= lastregno << MIPS16OP_SH_RY;
+		  continue;
+		}
+	      break;
+
+	    case '(':
+	    case ')':
+	      if (*s++ == c)
+		continue;
+	      break;
+
+	    case 'v':
+	    case 'w':
+	      if (s[0] != '$')
+		{
+		  if (c == 'v')
+		    ip->insn_opcode |= lastregno << MIPS16OP_SH_RX;
+		  else
+		    ip->insn_opcode |= lastregno << MIPS16OP_SH_RY;
+		  ++args;
+		  continue;
+		}
+	      /* Fall through.  */
+	    case 'x':
+	    case 'y':
+	    case 'z':
+	    case 'Z':
+	    case '0':
+	    case 'S':
+	    case 'R':
+	    case 'X':
+	    case 'Y':
+	      if (s[0] != '$')
+		break;
+	      s_reset = s;
+	      if (isdigit ((unsigned char) s[1]))
+		{
+		  ++s;
+		  regno = 0;
+		  do
+		    {
+		      regno *= 10;
+		      regno += *s - '0';
+		      ++s;
+		    }
+		  while (isdigit ((unsigned char) *s));
+		  if (regno > 31)
+		    {
+		      as_bad (_("invalid register number (%d)"), regno);
+		      regno = 2;
+		    }
+		}
+	      else
+		{
+		  if (s[1] == 'f' && s[2] == 'p')
+		    {
+		      s += 3;
+		      regno = FP;
+		    }
+		  else if (s[1] == 's' && s[2] == 'p')
+		    {
+		      s += 3;
+		      regno = SP;
+		    }
+		  else if (s[1] == 'g' && s[2] == 'p')
+		    {
+		      s += 3;
+		      regno = GP;
+		    }
+		  else if (s[1] == 'a' && s[2] == 't')
+		    {
+		      s += 3;
+		      regno = AT;
+		    }
+		  else if (s[1] == 'k' && s[2] == 't' && s[3] == '0')
+		    {
+		      s += 4;
+		      regno = KT0;
+		    }
+		  else if (s[1] == 'k' && s[2] == 't' && s[3] == '1')
+		    {
+		      s += 4;
+		      regno = KT1;
+		    }
+		  else
+		    break;
+		}
+
+	      if (*s == ' ')
+		++s;
+	      if (args[1] != *s)
+		{
+		  if (c == 'v' || c == 'w')
+		    {
+		      regno = mips16_to_32_reg_map[lastregno];
+		      s = s_reset;
+		      args++;
+		    }
+		}
+
+	      switch (c)
+		{
+		case 'x':
+		case 'y':
+		case 'z':
+		case 'v':
+		case 'w':
+		case 'Z':
+		  regno = mips32_to_16_reg_map[regno];
+		  break;
+
+		case '0':
+		  if (regno != 0)
+		    regno = ILLEGAL_REG;
+		  break;
+
+		case 'S':
+		  if (regno != SP)
+		    regno = ILLEGAL_REG;
+		  break;
+
+		case 'R':
+		  if (regno != RA)
+		    regno = ILLEGAL_REG;
+		  break;
+
+		case 'X':
+		case 'Y':
+		  if (regno == AT && ! mips_opts.noat)
+		    as_warn (_("used $at without \".set noat\""));
+		  break;
+
+		default:
+		  internalError ();
+		}
+
+	      if (regno == ILLEGAL_REG)
+		break;
+
+	      switch (c)
+		{
+		case 'x':
+		case 'v':
+		  ip->insn_opcode |= regno << MIPS16OP_SH_RX;
+		  break;
+		case 'y':
+		case 'w':
+		  ip->insn_opcode |= regno << MIPS16OP_SH_RY;
+		  break;
+		case 'z':
+		  ip->insn_opcode |= regno << MIPS16OP_SH_RZ;
+		  break;
+		case 'Z':
+		  ip->insn_opcode |= regno << MIPS16OP_SH_MOVE32Z;
+		case '0':
+		case 'S':
+		case 'R':
+		  break;
+		case 'X':
+		  ip->insn_opcode |= regno << MIPS16OP_SH_REGR32;
+		  break;
+		case 'Y':
+		  regno = ((regno & 7) << 2) | ((regno & 0x18) >> 3);
+		  ip->insn_opcode |= regno << MIPS16OP_SH_REG32R;
+		  break;
+		default:
+		  internalError ();
+		}
+
+	      lastregno = regno;
+	      continue;
+
+	    case 'P':
+	      if (strncmp (s, "$pc", 3) == 0)
+		{
+		  s += 3;
+		  continue;
+		}
+	      break;
+
+	    case '<':
+	    case '>':
+	    case '[':
+	    case ']':
+	    case '4':
+	    case '5':
+	    case 'H':
+	    case 'W':
+	    case 'D':
+	    case 'j':
+	    case '8':
+	    case 'V':
+	    case 'C':
+	    case 'U':
+	    case 'k':
+	    case 'K':
+	      if (s[0] == '%'
+		  && strncmp (s + 1, "gprel(", sizeof "gprel(" - 1) == 0)
+		{
+		  /* This is %gprel(SYMBOL).  We need to read SYMBOL,
+                     and generate the appropriate reloc.  If the text
+                     inside %gprel is not a symbol name with an
+                     optional offset, then we generate a normal reloc
+                     and will probably fail later.  */
+		  my_getExpression (&imm_expr, s + sizeof "%gprel" - 1);
+		  if (imm_expr.X_op == O_symbol)
+		    {
+		      mips16_ext = true;
+		      imm_reloc = BFD_RELOC_MIPS16_GPREL;
+		      s = expr_end;
+		      ip->use_extend = true;
+		      ip->extend = 0;
+		      continue;
+		    }
+		}
+	      else
+		{
+		  /* Just pick up a normal expression.  */
+		  my_getExpression (&imm_expr, s);
+		}
+
+	      if (imm_expr.X_op == O_register)
+		{
+		  /* What we thought was an expression turned out to
+                     be a register.  */
+
+		  if (s[0] == '(' && args[1] == '(')
+		    {
+		      /* It looks like the expression was omitted
+			 before a register indirection, which means
+			 that the expression is implicitly zero.  We
+			 still set up imm_expr, so that we handle
+			 explicit extensions correctly.  */
+		      imm_expr.X_op = O_constant;
+		      imm_expr.X_add_number = 0;
+		      imm_reloc = (int) BFD_RELOC_UNUSED + c;
+		      continue;
+		    }
+
+		  break;
+		}
+
+	      /* We need to relax this instruction.  */
+	      imm_reloc = (int) BFD_RELOC_UNUSED + c;
+	      s = expr_end;
+	      continue;
+
+	    case 'p':
+	    case 'q':
+	    case 'A':
+	    case 'B':
+	    case 'E':
+	      /* We use offset_reloc rather than imm_reloc for the PC
+                 relative operands.  This lets macros with both
+                 immediate and address operands work correctly.  */
+	      my_getExpression (&offset_expr, s);
+
+	      if (offset_expr.X_op == O_register)
+		break;
+
+	      /* We need to relax this instruction.  */
+	      offset_reloc = (int) BFD_RELOC_UNUSED + c;
+	      s = expr_end;
+	      continue;
+
+	    case '6':		/* break code */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned long) imm_expr.X_add_number > 63)
+		{
+		  as_warn (_("Invalid value for `%s' (%lu)"),
+			   ip->insn_mo->name,
+			   (unsigned long) imm_expr.X_add_number);
+		  imm_expr.X_add_number &= 0x3f;
+		}
+	      ip->insn_opcode |= imm_expr.X_add_number << MIPS16OP_SH_IMM6;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+	    case 'a':		/* 26 bit address */
+	      my_getExpression (&offset_expr, s);
+	      s = expr_end;
+	      offset_reloc = BFD_RELOC_MIPS16_JMP;
+	      ip->insn_opcode <<= 16;
+	      continue;
+
+	    case 'l':		/* register list for entry macro */
+	    case 'L':		/* register list for exit macro */
+	      {
+		int mask;
+
+		if (c == 'l')
+		  mask = 0;
+		else
+		  mask = 7 << 3;
+		while (*s != '\0')
+		  {
+		    int freg, reg1, reg2;
+
+		    while (*s == ' ' || *s == ',')
+		      ++s;
+		    if (*s != '$')
+		      {
+			as_bad (_("can't parse register list"));
+			break;
+		      }
+		    ++s;
+		    if (*s != 'f')
+		      freg = 0;
+		    else
+		      {
+			freg = 1;
+			++s;
+		      }
+		    reg1 = 0;
+		    while (isdigit ((unsigned char) *s))
+		      {
+			reg1 *= 10;
+			reg1 += *s - '0';
+			++s;
+		      }
+		    if (*s == ' ')
+		      ++s;
+		    if (*s != '-')
+		      reg2 = reg1;
+		    else
+		      {
+			++s;
+			if (*s != '$')
+			  break;
+			++s;
+			if (freg)
+			  {
+			    if (*s == 'f')
+			      ++s;
+			    else
+			      {
+				as_bad (_("invalid register list"));
+				break;
+			      }
+			  }
+			reg2 = 0;
+			while (isdigit ((unsigned char) *s))
+			  {
+			    reg2 *= 10;
+			    reg2 += *s - '0';
+			    ++s;
+			  }
+		      }
+		    if (freg && reg1 == 0 && reg2 == 0 && c == 'L')
+		      {
+			mask &= ~ (7 << 3);
+			mask |= 5 << 3;
+		      }
+		    else if (freg && reg1 == 0 && reg2 == 1 && c == 'L')
+		      {
+			mask &= ~ (7 << 3);
+			mask |= 6 << 3;
+		      }
+		    else if (reg1 == 4 && reg2 >= 4 && reg2 <= 7 && c != 'L')
+		      mask |= (reg2 - 3) << 3;
+		    else if (reg1 == 16 && reg2 >= 16 && reg2 <= 17)
+		      mask |= (reg2 - 15) << 1;
+		    else if (reg1 == 31 && reg2 == 31)
+		      mask |= 1;
+		    else
+		      {
+			as_bad (_("invalid register list"));
+			break;
+		      }
+		  }
+		/* The mask is filled in in the opcode table for the
+                   benefit of the disassembler.  We remove it before
+                   applying the actual mask.  */
+		ip->insn_opcode &= ~ ((7 << 3) << MIPS16OP_SH_IMM6);
+		ip->insn_opcode |= mask << MIPS16OP_SH_IMM6;
+	      }
+	    continue;
+
+	    case 'e':		/* extend code */
+	      my_getExpression (&imm_expr, s);
+	      check_absolute_expr (ip, &imm_expr);
+	      if ((unsigned long) imm_expr.X_add_number > 0x7ff)
+		{
+		  as_warn (_("Invalid value for `%s' (%lu)"),
+			   ip->insn_mo->name,
+			   (unsigned long) imm_expr.X_add_number);
+		  imm_expr.X_add_number &= 0x7ff;
+		}
+	      ip->insn_opcode |= imm_expr.X_add_number;
+	      imm_expr.X_op = O_absent;
+	      s = expr_end;
+	      continue;
+
+	    default:
+	      internalError ();
+	    }
+	  break;
+	}
+
+      /* Args don't match.  */
+      if (insn + 1 < &mips16_opcodes[bfd_mips16_num_opcodes] &&
+	  strcmp (insn->name, insn[1].name) == 0)
+	{
+	  ++insn;
+	  s = argsstart;
+	  continue;
+	}
+
+      insn_error = _("illegal operands");
+
+      return;
+    }
+}
+
+/* This structure holds information we know about a mips16 immediate
+   argument type.  */
+
+struct mips16_immed_operand
+{
+  /* The type code used in the argument string in the opcode table.  */
+  int type;
+  /* The number of bits in the short form of the opcode.  */
+  int nbits;
+  /* The number of bits in the extended form of the opcode.  */
+  int extbits;
+  /* The amount by which the short form is shifted when it is used;
+     for example, the sw instruction has a shift count of 2.  */
+  int shift;
+  /* The amount by which the short form is shifted when it is stored
+     into the instruction code.  */
+  int op_shift;
+  /* Non-zero if the short form is unsigned.  */
+  int unsp;
+  /* Non-zero if the extended form is unsigned.  */
+  int extu;
+  /* Non-zero if the value is PC relative.  */
+  int pcrel;
+};
+
+/* The mips16 immediate operand types.  */
+
+static const struct mips16_immed_operand mips16_immed_operands[] =
+{
+  { '<',  3,  5, 0, MIPS16OP_SH_RZ,   1, 1, 0 },
+  { '>',  3,  5, 0, MIPS16OP_SH_RX,   1, 1, 0 },
+  { '[',  3,  6, 0, MIPS16OP_SH_RZ,   1, 1, 0 },
+  { ']',  3,  6, 0, MIPS16OP_SH_RX,   1, 1, 0 },
+  { '4',  4, 15, 0, MIPS16OP_SH_IMM4, 0, 0, 0 },
+  { '5',  5, 16, 0, MIPS16OP_SH_IMM5, 1, 0, 0 },
+  { 'H',  5, 16, 1, MIPS16OP_SH_IMM5, 1, 0, 0 },
+  { 'W',  5, 16, 2, MIPS16OP_SH_IMM5, 1, 0, 0 },
+  { 'D',  5, 16, 3, MIPS16OP_SH_IMM5, 1, 0, 0 },
+  { 'j',  5, 16, 0, MIPS16OP_SH_IMM5, 0, 0, 0 },
+  { '8',  8, 16, 0, MIPS16OP_SH_IMM8, 1, 0, 0 },
+  { 'V',  8, 16, 2, MIPS16OP_SH_IMM8, 1, 0, 0 },
+  { 'C',  8, 16, 3, MIPS16OP_SH_IMM8, 1, 0, 0 },
+  { 'U',  8, 16, 0, MIPS16OP_SH_IMM8, 1, 1, 0 },
+  { 'k',  8, 16, 0, MIPS16OP_SH_IMM8, 0, 0, 0 },
+  { 'K',  8, 16, 3, MIPS16OP_SH_IMM8, 0, 0, 0 },
+  { 'p',  8, 16, 0, MIPS16OP_SH_IMM8, 0, 0, 1 },
+  { 'q', 11, 16, 0, MIPS16OP_SH_IMM8, 0, 0, 1 },
+  { 'A',  8, 16, 2, MIPS16OP_SH_IMM8, 1, 0, 1 },
+  { 'B',  5, 16, 3, MIPS16OP_SH_IMM5, 1, 0, 1 },
+  { 'E',  5, 16, 2, MIPS16OP_SH_IMM5, 1, 0, 1 }
+};
+
+#define MIPS16_NUM_IMMED \
+  (sizeof mips16_immed_operands / sizeof mips16_immed_operands[0])
+
+/* Handle a mips16 instruction with an immediate value.  This or's the
+   small immediate value into *INSN.  It sets *USE_EXTEND to indicate
+   whether an extended value is needed; if one is needed, it sets
+   *EXTEND to the value.  The argument type is TYPE.  The value is VAL.
+   If SMALL is true, an unextended opcode was explicitly requested.
+   If EXT is true, an extended opcode was explicitly requested.  If
+   WARN is true, warn if EXT does not match reality.  */
+
+static void
+mips16_immed (file, line, type, val, warn, small, ext, insn, use_extend,
+	      extend)
+     char *file;
+     unsigned int line;
+     int type;
+     offsetT val;
+     boolean warn;
+     boolean small;
+     boolean ext;
+     unsigned long *insn;
+     boolean *use_extend;
+     unsigned short *extend;
+{
+  register const struct mips16_immed_operand *op;
+  int mintiny, maxtiny;
+  boolean needext;
+
+  op = mips16_immed_operands;
+  while (op->type != type)
+    {
+      ++op;
+      assert (op < mips16_immed_operands + MIPS16_NUM_IMMED);
+    }
+
+  if (op->unsp)
+    {
+      if (type == '<' || type == '>' || type == '[' || type == ']')
+	{
+	  mintiny = 1;
+	  maxtiny = 1 << op->nbits;
+	}
+      else
+	{
+	  mintiny = 0;
+	  maxtiny = (1 << op->nbits) - 1;
+	}
+    }
+  else
+    {
+      mintiny = - (1 << (op->nbits - 1));
+      maxtiny = (1 << (op->nbits - 1)) - 1;
+    }
+
+  /* Branch offsets have an implicit 0 in the lowest bit.  */
+  if (type == 'p' || type == 'q')
+    val /= 2;
+
+  if ((val & ((1 << op->shift) - 1)) != 0
+      || val < (mintiny << op->shift)
+      || val > (maxtiny << op->shift))
+    needext = true;
+  else
+    needext = false;
+
+  if (warn && ext && ! needext)
+    as_warn_where (file, line, _("extended operand requested but not required"));
+  if (small && needext)
+    as_bad_where (file, line, _("invalid unextended operand value"));
+
+  if (small || (! ext && ! needext))
+    {
+      int insnval;
+
+      *use_extend = false;
+      insnval = ((val >> op->shift) & ((1 << op->nbits) - 1));
+      insnval <<= op->op_shift;
+      *insn |= insnval;
+    }
+  else
+    {
+      long minext, maxext;
+      int extval;
+
+      if (op->extu)
+	{
+	  minext = 0;
+	  maxext = (1 << op->extbits) - 1;
+	}
+      else
+	{
+	  minext = - (1 << (op->extbits - 1));
+	  maxext = (1 << (op->extbits - 1)) - 1;
+	}
+      if (val < minext || val > maxext)
+	as_bad_where (file, line,
+		      _("operand value out of range for instruction"));
+
+      *use_extend = true;
+      if (op->extbits == 16)
+	{
+	  extval = ((val >> 11) & 0x1f) | (val & 0x7e0);
+	  val &= 0x1f;
+	}
+      else if (op->extbits == 15)
+	{
+	  extval = ((val >> 11) & 0xf) | (val & 0x7f0);
+	  val &= 0xf;
+	}
+      else
+	{
+	  extval = ((val & 0x1f) << 6) | (val & 0x20);
+	  val = 0;
+	}
+
+      *extend = (unsigned short) extval;
+      *insn |= val;
+    }
+}
+
+#define LP '('
+#define RP ')'
+
+static int
+my_getSmallExpression (ep, str)
+     expressionS *ep;
+     char *str;
+{
+  char *sp;
+  int c = 0;
+
+  if (*str == ' ')
+    str++;
+  if (*str == LP
+      || (*str == '%' &&
+	  ((str[1] == 'h' && str[2] == 'i')
+	   || (str[1] == 'H' && str[2] == 'I')
+	   || (str[1] == 'l' && str[2] == 'o'))
+	  && str[3] == LP))
+    {
+      if (*str == LP)
+	c = 0;
+      else
+	{
+	  c = str[1];
+	  str += 3;
+	}
+
+      /*
+       * A small expression may be followed by a base register.
+       * Scan to the end of this operand, and then back over a possible
+       * base register.  Then scan the small expression up to that
+       * point.  (Based on code in sparc.c...)
+       */
+      for (sp = str; *sp && *sp != ','; sp++)
+	;
+      if (sp - 4 >= str && sp[-1] == RP)
+	{
+	  if (isdigit ((unsigned char) sp[-2]))
+	    {
+	      for (sp -= 3; sp >= str && isdigit ((unsigned char) *sp); sp--)
+		;
+	      if (*sp == '$' && sp > str && sp[-1] == LP)
+		{
+		  sp--;
+		  goto do_it;
+		}
+	    }
+	  else if (sp - 5 >= str
+		   && sp[-5] == LP
+		   && sp[-4] == '$'
+		   && ((sp[-3] == 'f' && sp[-2] == 'p')
+		       || (sp[-3] == 's' && sp[-2] == 'p')
+		       || (sp[-3] == 'g' && sp[-2] == 'p')
+		       || (sp[-3] == 'a' && sp[-2] == 't')))
+	    {
+	      sp -= 5;
+	    do_it:
+	      if (sp == str)
+		{
+		  /* no expression means zero offset */
+		  if (c)
+		    {
+		      /* %xx(reg) is an error */
+		      ep->X_op = O_absent;
+		      expr_end = str - 3;
+		    }
+		  else
+		    {
+		      ep->X_op = O_constant;
+		      expr_end = sp;
+		    }
+		  ep->X_add_symbol = NULL;
+		  ep->X_op_symbol = NULL;
+		  ep->X_add_number = 0;
+		}
+	      else
+		{
+		  *sp = '\0';
+		  my_getExpression (ep, str);
+		  *sp = LP;
+		}
+	      return c;
+	    }
+	}
+    }
+  my_getExpression (ep, str);
+  return c;			/* => %hi or %lo encountered */
+}
+
+static void
+my_getExpression (ep, str)
+     expressionS *ep;
+     char *str;
+{
+  char *save_in;
+
+  save_in = input_line_pointer;
+  input_line_pointer = str;
+  expression (ep);
+  expr_end = input_line_pointer;
+  input_line_pointer = save_in;
+
+  /* If we are in mips16 mode, and this is an expression based on `.',
+     then we bump the value of the symbol by 1 since that is how other
+     text symbols are handled.  We don't bother to handle complex
+     expressions, just `.' plus or minus a constant.  */
+  if (mips_opts.mips16
+      && ep->X_op == O_symbol
+      && strcmp (S_GET_NAME (ep->X_add_symbol), FAKE_LABEL_NAME) == 0
+      && S_GET_SEGMENT (ep->X_add_symbol) == now_seg
+      && symbol_get_frag (ep->X_add_symbol) == frag_now
+      && symbol_constant_p (ep->X_add_symbol)
+      && S_GET_VALUE (ep->X_add_symbol) == frag_now_fix ())
+    S_SET_VALUE (ep->X_add_symbol, S_GET_VALUE (ep->X_add_symbol) + 1);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type type, and store the appropriate bytes in *litP.  The number
+   of LITTLENUMS emitted is stored in *sizeP .  An error message is
+   returned, or NULL on OK.  */
+
+char *
+md_atof (type, litP, sizeP)
+     int type;
+     char *litP;
+     int *sizeP;
+{
+  int prec;
+  LITTLENUM_TYPE words[4];
+  char *t;
+  int i;
+
+  switch (type)
+    {
+    case 'f':
+      prec = 2;
+      break;
+
+    case 'd':
+      prec = 4;
+      break;
+
+    default:
+      *sizeP = 0;
+      return _("bad call to md_atof");
+    }
+
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizeP = prec * 2;
+
+  if (! target_big_endian)
+    {
+      for (i = prec - 1; i >= 0; i--)
+	{
+	  md_number_to_chars (litP, (valueT) words[i], 2);
+	  litP += 2;
+	}
+    }
+  else
+    {
+      for (i = 0; i < prec; i++)
+	{
+	  md_number_to_chars (litP, (valueT) words[i], 2);
+	  litP += 2;
+	}
+    }
+     
+  return NULL;
+}
+
+void
+md_number_to_chars (buf, val, n)
+     char *buf;
+     valueT val;
+     int n;
+{
+  if (target_big_endian)
+    number_to_chars_bigendian (buf, val, n);
+  else
+    number_to_chars_littleendian (buf, val, n);
+}
+
+CONST char *md_shortopts = "O::g::G:";
+
+struct option md_longopts[] = {
+#define OPTION_MIPS1 (OPTION_MD_BASE + 1)
+  {"mips0", no_argument, NULL, OPTION_MIPS1},
+  {"mips1", no_argument, NULL, OPTION_MIPS1},
+#define OPTION_MIPS2 (OPTION_MD_BASE + 2)
+  {"mips2", no_argument, NULL, OPTION_MIPS2},
+#define OPTION_MIPS3 (OPTION_MD_BASE + 3)
+  {"mips3", no_argument, NULL, OPTION_MIPS3},
+#define OPTION_MIPS4 (OPTION_MD_BASE + 4)
+  {"mips4", no_argument, NULL, OPTION_MIPS4},
+#define OPTION_MCPU (OPTION_MD_BASE + 5)
+  {"mcpu", required_argument, NULL, OPTION_MCPU},
+#define OPTION_MEMBEDDED_PIC (OPTION_MD_BASE + 6)
+  {"membedded-pic", no_argument, NULL, OPTION_MEMBEDDED_PIC},
+#define OPTION_TRAP (OPTION_MD_BASE + 9)
+  {"trap", no_argument, NULL, OPTION_TRAP},
+  {"no-break", no_argument, NULL, OPTION_TRAP},
+#define OPTION_BREAK (OPTION_MD_BASE + 10)
+  {"break", no_argument, NULL, OPTION_BREAK},
+  {"no-trap", no_argument, NULL, OPTION_BREAK},
+#define OPTION_EB (OPTION_MD_BASE + 11)
+  {"EB", no_argument, NULL, OPTION_EB},
+#define OPTION_EL (OPTION_MD_BASE + 12)
+  {"EL", no_argument, NULL, OPTION_EL},
+#define OPTION_M4650 (OPTION_MD_BASE + 13)
+  {"m4650", no_argument, NULL, OPTION_M4650},
+#define OPTION_NO_M4650 (OPTION_MD_BASE + 14)
+  {"no-m4650", no_argument, NULL, OPTION_NO_M4650},
+#define OPTION_M4010 (OPTION_MD_BASE + 15)
+  {"m4010", no_argument, NULL, OPTION_M4010},
+#define OPTION_NO_M4010 (OPTION_MD_BASE + 16)
+  {"no-m4010", no_argument, NULL, OPTION_NO_M4010},
+#define OPTION_M4100 (OPTION_MD_BASE + 17)
+  {"m4100", no_argument, NULL, OPTION_M4100},
+#define OPTION_NO_M4100 (OPTION_MD_BASE + 18)
+  {"no-m4100", no_argument, NULL, OPTION_NO_M4100},
+#define OPTION_MIPS16 (OPTION_MD_BASE + 22)
+  {"mips16", no_argument, NULL, OPTION_MIPS16},
+#define OPTION_NO_MIPS16 (OPTION_MD_BASE + 23)
+  {"no-mips16", no_argument, NULL, OPTION_NO_MIPS16},
+#define OPTION_M3900 (OPTION_MD_BASE + 26)
+  {"m3900", no_argument, NULL, OPTION_M3900},
+#define OPTION_NO_M3900 (OPTION_MD_BASE + 27)
+  {"no-m3900", no_argument, NULL, OPTION_NO_M3900},
+
+
+#define OPTION_MABI (OPTION_MD_BASE + 38)
+  {"mabi", required_argument, NULL, OPTION_MABI},
+
+#define OPTION_M7000_HILO_FIX (OPTION_MD_BASE + 39)
+  {"mfix7000", no_argument, NULL, OPTION_M7000_HILO_FIX},
+#define OPTION_NO_M7000_HILO_FIX (OPTION_MD_BASE + 40)
+  {"no-fix-7000", no_argument, NULL, OPTION_NO_M7000_HILO_FIX},
+
+#define OPTION_CALL_SHARED (OPTION_MD_BASE + 7)
+#define OPTION_NON_SHARED (OPTION_MD_BASE + 8)
+#define OPTION_XGOT (OPTION_MD_BASE + 19)
+#define OPTION_32 (OPTION_MD_BASE + 20)
+#define OPTION_64 (OPTION_MD_BASE + 21)
+#define OPTION_QNX_PIC (OPTION_MD_BASE + 28)
+#ifdef OBJ_ELF
+  {"KPIC", no_argument, NULL, OPTION_CALL_SHARED},
+  {"xgot", no_argument, NULL, OPTION_XGOT},
+  {"call_shared", no_argument, NULL, OPTION_CALL_SHARED},
+  {"non_shared", no_argument, NULL, OPTION_NON_SHARED},
+  {"32", no_argument, NULL, OPTION_32},
+  {"64", no_argument, NULL, OPTION_64},
+  {"qnx_pic", no_argument, NULL, OPTION_QNX_PIC},
+#endif
+
+#define OPTION_GP32 (OPTION_MD_BASE + 41)
+#define OPTION_GP64 (OPTION_MD_BASE + 42)
+  {"mgp32", no_argument, NULL, OPTION_GP32},
+  {"mgp64", no_argument, NULL, OPTION_GP64},
+
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof(md_longopts);
+
+int
+md_parse_option (c, arg)
+     int c;
+     char *arg;
+{
+  switch (c)
+    {
+    case OPTION_TRAP:
+      mips_trap = 1;
+      break;
+
+    case OPTION_BREAK:
+      mips_trap = 0;
+      break;
+
+    case OPTION_EB:
+      target_big_endian = 1;
+      break;
+
+    case OPTION_EL:
+      target_big_endian = 0;
+      break;
+
+    case 'O':
+      if (arg && arg[1] == '0')
+	mips_optimize = 1;
+      else
+	mips_optimize = 2;
+      break;
+
+    case 'g':
+      if (arg == NULL)
+	mips_debug = 2;
+      else
+	mips_debug = atoi (arg);
+      /* When the MIPS assembler sees -g or -g2, it does not do
+         optimizations which limit full symbolic debugging.  We take
+         that to be equivalent to -O0.  */
+      if (mips_debug == 2)
+	mips_optimize = 1;
+      break;
+
+    case OPTION_MIPS1:
+      mips_opts.isa = 1;
+      break;
+
+    case OPTION_MIPS2:
+      mips_opts.isa = 2;
+      break;
+
+    case OPTION_MIPS3:
+      mips_opts.isa = 3;
+      break;
+
+    case OPTION_MIPS4:
+      mips_opts.isa = 4;
+      break;
+
+    case OPTION_MCPU:
+      {
+	char *p;
+
+	/* Identify the processor type */
+	p = arg;
+	if (strcmp (p, "default") == 0
+	    || strcmp (p, "DEFAULT") == 0)
+	  mips_cpu = -1;
+	else
+	  {
+	    int sv = 0;
+
+	    /* We need to cope with the various "vr" prefixes for the 4300
+	       processor.  */
+	    if (*p == 'v' || *p == 'V')
+	      {
+		sv = 1;
+		p++;
+	      }
+
+	    if (*p == 'r' || *p == 'R')
+	      p++;
+
+	    mips_cpu = -1;
+	    switch (*p)
+	      {
+	      case '1':
+		if (strcmp (p, "10000") == 0
+		    || strcmp (p, "10k") == 0
+		    || strcmp (p, "10K") == 0)
+		  mips_cpu = 10000;
+		break;
+
+	      case '2':
+		if (strcmp (p, "2000") == 0
+		    || strcmp (p, "2k") == 0
+		    || strcmp (p, "2K") == 0)
+		  mips_cpu = 2000;
+		break;
+
+	      case '3':
+		if (strcmp (p, "3000") == 0
+		    || strcmp (p, "3k") == 0
+		    || strcmp (p, "3K") == 0)
+		  mips_cpu = 3000;
+                else if (strcmp (p, "3900") == 0)
+                  mips_cpu = 3900;
+		break;
+
+	      case '4':
+		if (strcmp (p, "4000") == 0
+		    || strcmp (p, "4k") == 0
+		    || strcmp (p, "4K") == 0)
+		  mips_cpu = 4000;
+		else if (strcmp (p, "4100") == 0)
+                    mips_cpu = 4100;
+		else if (strcmp (p, "4111") == 0)
+                    mips_cpu = 4111;
+		else if (strcmp (p, "4300") == 0)
+		  mips_cpu = 4300;
+		else if (strcmp (p, "4400") == 0)
+		  mips_cpu = 4400;
+		else if (strcmp (p, "4600") == 0)
+		  mips_cpu = 4600;
+		else if (strcmp (p, "4650") == 0)
+		    mips_cpu = 4650;
+		else if (strcmp (p, "4010") == 0)
+                  mips_cpu = 4010;
+		break;
+
+	      case '5':
+		if (strcmp (p, "5000") == 0
+		    || strcmp (p, "5k") == 0
+		    || strcmp (p, "5K") == 0)
+		  mips_cpu = 5000;
+		break;
+
+	      case '6':
+		if (strcmp (p, "6000") == 0
+		    || strcmp (p, "6k") == 0
+		    || strcmp (p, "6K") == 0)
+		  mips_cpu = 6000;
+		break;
+
+	      case '8':
+		if (strcmp (p, "8000") == 0
+		    || strcmp (p, "8k") == 0
+		    || strcmp (p, "8K") == 0)
+		  mips_cpu = 8000;
+		break;
+
+	      case 'o':
+		if (strcmp (p, "orion") == 0)
+		  mips_cpu = 4600;
+		break;
+	      }
+
+	    if (sv
+		&& (mips_cpu != 4300
+		    && mips_cpu != 4100
+		    && mips_cpu != 4111
+		    && mips_cpu != 5000))
+	      {
+		as_bad (_("ignoring invalid leading 'v' in -mcpu=%s switch"), arg);
+		return 0;
+	      }
+
+	    if (mips_cpu == -1)
+	      {
+		as_bad (_("invalid architecture -mcpu=%s"), arg);
+		return 0;
+	      }
+	  }
+      }
+      break;
+
+    case OPTION_M4650:
+      mips_cpu = 4650;
+      break;
+
+    case OPTION_NO_M4650:
+      break;
+
+    case OPTION_M4010:
+      mips_cpu = 4010;
+      break;
+
+    case OPTION_NO_M4010:
+      break;
+
+    case OPTION_M4100:
+      mips_cpu = 4100;
+      break;
+
+    case OPTION_NO_M4100:
+      break;
+
+
+    case OPTION_M3900:
+      mips_cpu = 3900;
+      break;
+      
+    case OPTION_NO_M3900:
+      break;
+
+    case OPTION_MIPS16:
+      mips_opts.mips16 = 1;
+      mips_no_prev_insn (false);
+      break;
+
+    case OPTION_NO_MIPS16:
+      mips_opts.mips16 = 0;
+      mips_no_prev_insn (false);
+      break;
+
+    case OPTION_MEMBEDDED_PIC:
+      mips_pic = EMBEDDED_PIC;
+      if (USE_GLOBAL_POINTER_OPT && g_switch_seen)
+	{
+	  as_bad (_("-G may not be used with embedded PIC code"));
+	  return 0;
+	}
+      g_switch_value = 0x7fffffff;
+      break;
+
+      /* When generating ELF code, we permit -KPIC and -call_shared to
+	 select SVR4_PIC, and -non_shared to select no PIC.  This is
+	 intended to be compatible with Irix 5.  */
+    case OPTION_CALL_SHARED:
+      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
+	{
+	  as_bad (_("-call_shared is supported only for ELF format"));
+	  return 0;
+	}
+      mips_pic = SVR4_PIC;
+      if (g_switch_seen && g_switch_value != 0)
+	{
+	  as_bad (_("-G may not be used with SVR4 PIC code"));
+	  return 0;
+	}
+      g_switch_value = 0;
+      break;
+
+    case OPTION_QNX_PIC:
+      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
+	{
+	  as_bad ("-qnx_pic is supported only for ELF format");
+	  return 0;
+	}
+      mips_pic = QNX_PIC;
+      if (g_switch_seen && g_switch_value != 0)
+	{
+	  as_bad ("-G may not be used with QNX PIC code");
+	  return 0;
+	}
+      g_switch_value = 0;
+      break;
+
+    case OPTION_NON_SHARED:
+      if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
+	{
+	  as_bad (_("-non_shared is supported only for ELF format"));
+	  return 0;
+	}
+      mips_pic = NO_PIC;
+      break;
+
+      /* The -xgot option tells the assembler to use 32 offsets when
+         accessing the got in SVR4_PIC mode.  It is for Irix
+         compatibility.  */
+    case OPTION_XGOT:
+      mips_big_got = 1;
+      break;
+
+    case 'G':
+      if (! USE_GLOBAL_POINTER_OPT)
+	{
+	  as_bad (_("-G is not supported for this configuration"));
+	  return 0;
+	}
+      else if (mips_pic == SVR4_PIC || mips_pic == EMBEDDED_PIC || mips_pic == QNX_PIC)
+	{
+	  as_bad (_("-G may not be used with SVR4 or embedded PIC code"));
+	  return 0;
+	}
+      else
+	g_switch_value = atoi (arg);
+      g_switch_seen = 1;
+      break;
+
+      /* The -32 and -64 options tell the assembler to output the 32
+         bit or the 64 bit MIPS ELF format.  */
+    case OPTION_32:
+      mips_64 = 0;
+      break;
+
+    case OPTION_64:
+      {
+	const char **list, **l;
+
+	list = bfd_target_list ();
+	for (l = list; *l != NULL; l++)
+	  if (strcmp (*l, "elf64-bigmips") == 0
+	      || strcmp (*l, "elf64-littlemips") == 0)
+	    break;
+	if (*l == NULL)
+	  as_fatal (_("No compiled in support for 64 bit object file format"));
+	free (list);
+	mips_64 = 1;
+      }
+      break;
+
+    case OPTION_GP32:
+      mips_gp32 = 1;
+      mips_64 = 0;
+
+      /* We deliberately don't allow "-gp32" to set the MIPS_32BITMODE
+	 flag in object files because to do so would make it
+	 impossible to link with libraries compiled without "-gp32".
+	 This is unnecessarily restrictive.  
+
+	 We could solve this problem by adding "-gp32" multilibs to
+	 gcc, but to set this flag before gcc is built with such
+	 multilibs will break too many systems. */
+
+/*    mips_32bitmode = 1; */
+      break;
+
+    case OPTION_GP64:
+      mips_gp32 = 0;
+      mips_64 = 1;
+/*    mips_32bitmode = 0; */
+      break;
+
+    case OPTION_MABI:
+      if (strcmp (arg,"32") == 0
+	  || strcmp (arg,"n32") == 0
+	  || strcmp (arg,"64") == 0
+	  || strcmp (arg,"o64") == 0
+	  || strcmp (arg,"eabi") == 0)
+	mips_abi_string = arg;
+      break;
+
+    case OPTION_M7000_HILO_FIX:
+      mips_7000_hilo_fix = true;
+      break;
+
+    case OPTION_NO_M7000_HILO_FIX:
+      mips_7000_hilo_fix = false;
+      break;
+
+    default:
+      return 0;
+    }
+
+  return 1;
+}
+
+
+static void
+show (stream, string, col_p, first_p)
+     FILE *stream;
+     char *string;
+     int *col_p;
+     int *first_p;
+{
+  if (*first_p)
+    {
+      fprintf (stream, "%24s", "");
+      *col_p = 24;
+    }
+  else
+    {
+      fprintf (stream, ", ");
+      *col_p += 2;
+    }
+
+  if (*col_p + strlen (string) > 72)
+    {
+      fprintf (stream, "\n%24s", "");
+      *col_p = 24;
+    }
+
+  fprintf (stream, "%s", string);
+  *col_p += strlen (string);
+
+  *first_p = 0;
+}
+
+
+void
+md_show_usage (stream)
+     FILE *stream;
+{
+  int column, first;
+
+  fprintf(stream, _("\
+MIPS options:\n\
+-membedded-pic		generate embedded position independent code\n\
+-EB			generate big endian output\n\
+-EL			generate little endian output\n\
+-g, -g2			do not remove uneeded NOPs or swap branches\n\
+-G NUM			allow referencing objects up to NUM bytes\n\
+			implicitly with the gp register [default 8]\n"));
+  fprintf(stream, _("\
+-mips1			generate MIPS ISA I instructions\n\
+-mips2			generate MIPS ISA II instructions\n\
+-mips3			generate MIPS ISA III instructions\n\
+-mips4			generate MIPS ISA IV instructions\n\
+-mcpu=CPU		generate code for CPU, where CPU is one of:\n"));
+
+  first = 1;
+
+  show (stream, "2000", &column, &first);
+  show (stream, "3000", &column, &first);
+  show (stream, "3900", &column, &first);
+  show (stream, "4000", &column, &first);
+  show (stream, "4010", &column, &first);
+  show (stream, "4100", &column, &first);
+  show (stream, "4111", &column, &first);
+  show (stream, "4300", &column, &first);
+  show (stream, "4400", &column, &first);
+  show (stream, "4600", &column, &first);
+  show (stream, "4650", &column, &first);
+  show (stream, "5000", &column, &first);
+  show (stream, "6000", &column, &first);
+  show (stream, "8000", &column, &first);
+  show (stream, "10000", &column, &first);
+  fputc ('\n', stream);
+
+  fprintf (stream, _("\
+-mCPU			equivalent to -mcpu=CPU.\n\
+-no-mCPU		don't generate code specific to CPU.\n\
+			For -mCPU and -no-mCPU, CPU must be one of:\n"));
+
+  first = 1;
+
+  show (stream, "3900", &column, &first);
+  show (stream, "4010", &column, &first);
+  show (stream, "4100", &column, &first);
+  show (stream, "4650", &column, &first);
+  fputc ('\n', stream);
+
+  fprintf(stream, _("\
+-mips16			generate mips16 instructions\n\
+-no-mips16		do not generate mips16 instructions\n"));
+  fprintf(stream, _("\
+-O0			remove unneeded NOPs, do not swap branches\n\
+-O			remove unneeded NOPs and swap branches\n\
+--trap, --no-break	trap exception on div by 0 and mult overflow\n\
+--break, --no-trap	break exception on div by 0 and mult overflow\n"));
+#ifdef OBJ_ELF
+  fprintf(stream, _("\
+-KPIC, -call_shared	generate SVR4 position independent code\n\
+-non_shared		do not generate position independent code\n\
+-xgot			assume a 32 bit GOT\n\
+-32			create 32 bit object file (default)\n\
+-64			create 64 bit object file\n"));
+#endif
+}
+
+void
+mips_init_after_args ()
+{
+  /* initialize opcodes */
+  bfd_mips_num_opcodes = bfd_mips_num_builtin_opcodes;
+  mips_opcodes = (struct mips_opcode*) mips_builtin_opcodes;
+}
+
+long
+md_pcrel_from (fixP)
+     fixS *fixP;
+{
+  if (OUTPUT_FLAVOR != bfd_target_aout_flavour
+      && fixP->fx_addsy != (symbolS *) NULL
+      && ! S_IS_DEFINED (fixP->fx_addsy))
+    {
+      /* This makes a branch to an undefined symbol be a branch to the
+	 current location.  */
+      return 4;
+    }
+
+  /* return the address of the delay slot */
+  return fixP->fx_size + fixP->fx_where + fixP->fx_frag->fr_address;
+}
+
+/* This is called by emit_expr via TC_CONS_FIX_NEW when creating a
+   reloc for a cons.  We could use the definition there, except that
+   we want to handle 64 bit relocs specially.  */
+
+void
+cons_fix_new_mips (frag, where, nbytes, exp)
+     fragS *frag;
+     int where;
+     unsigned int nbytes;
+     expressionS *exp;
+{
+#ifndef OBJ_ELF
+  /* If we are assembling in 32 bit mode, turn an 8 byte reloc into a
+     4 byte reloc.  */
+  if (nbytes == 8 && ! mips_64)
+    {
+      if (target_big_endian)
+	where += 4;
+      nbytes = 4;
+    }
+#endif
+
+  if (nbytes != 2 && nbytes != 4 && nbytes != 8)
+    as_bad (_("Unsupported reloc size %d"), nbytes);
+
+  fix_new_exp (frag_now, where, (int) nbytes, exp, 0,
+	       (nbytes == 2
+		? BFD_RELOC_16
+		: (nbytes == 4 ? BFD_RELOC_32 : BFD_RELOC_64)));
+}
+
+/* This is called before the symbol table is processed.  In order to
+   work with gcc when using mips-tfile, we must keep all local labels.
+   However, in other cases, we want to discard them.  If we were
+   called with -g, but we didn't see any debugging information, it may
+   mean that gcc is smuggling debugging information through to
+   mips-tfile, in which case we must generate all local labels.  */
+
+void
+mips_frob_file_before_adjust ()
+{
+#ifndef NO_ECOFF_DEBUGGING
+  if (ECOFF_DEBUGGING
+      && mips_debug != 0
+      && ! ecoff_debugging_seen)
+    flag_keep_locals = 1;
+#endif
+}
+
+/* Sort any unmatched HI16_S relocs so that they immediately precede
+   the corresponding LO reloc.  This is called before md_apply_fix and
+   tc_gen_reloc.  Unmatched HI16_S relocs can only be generated by
+   explicit use of the %hi modifier.  */
+
+void
+mips_frob_file ()
+{
+  struct mips_hi_fixup *l;
+
+  for (l = mips_hi_fixup_list; l != NULL; l = l->next)
+    {
+      segment_info_type *seginfo;
+      int pass;
+
+      assert (l->fixp->fx_r_type == BFD_RELOC_HI16_S);
+
+      /* Check quickly whether the next fixup happens to be a matching
+         %lo.  */
+      if (l->fixp->fx_next != NULL
+	  && l->fixp->fx_next->fx_r_type == BFD_RELOC_LO16
+	  && l->fixp->fx_addsy == l->fixp->fx_next->fx_addsy
+	  && l->fixp->fx_offset == l->fixp->fx_next->fx_offset)
+	continue;
+
+      /* Look through the fixups for this segment for a matching %lo.
+         When we find one, move the %hi just in front of it.  We do
+         this in two passes.  In the first pass, we try to find a
+         unique %lo.  In the second pass, we permit multiple %hi
+         relocs for a single %lo (this is a GNU extension).  */
+      seginfo = seg_info (l->seg);
+      for (pass = 0; pass < 2; pass++)
+	{
+	  fixS *f, *prev;
+
+	  prev = NULL;
+	  for (f = seginfo->fix_root; f != NULL; f = f->fx_next)
+	    {
+	      /* Check whether this is a %lo fixup which matches l->fixp.  */
+	      if (f->fx_r_type == BFD_RELOC_LO16
+		  && f->fx_addsy == l->fixp->fx_addsy
+		  && f->fx_offset == l->fixp->fx_offset
+		  && (pass == 1
+		      || prev == NULL
+		      || prev->fx_r_type != BFD_RELOC_HI16_S
+		      || prev->fx_addsy != f->fx_addsy
+		      || prev->fx_offset !=  f->fx_offset))
+		{
+		  fixS **pf;
+
+		  /* Move l->fixp before f.  */
+		  for (pf = &seginfo->fix_root;
+		       *pf != l->fixp;
+		       pf = &(*pf)->fx_next)
+		    assert (*pf != NULL);
+
+		  *pf = l->fixp->fx_next;
+
+		  l->fixp->fx_next = f;
+		  if (prev == NULL)
+		    seginfo->fix_root = l->fixp;
+		  else
+		    prev->fx_next = l->fixp;
+
+		  break;
+		}
+
+	      prev = f;
+	    }
+
+	  if (f != NULL)
+	    break;
+
+#if 0 /* GCC code motion plus incomplete dead code elimination
+	 can leave a %hi without a %lo.  */
+	  if (pass == 1)
+	    as_warn_where (l->fixp->fx_file, l->fixp->fx_line,
+			   _("Unmatched %%hi reloc"));
+#endif
+	}
+    }
+}
+
+/* When generating embedded PIC code we need to use a special
+   relocation to represent the difference of two symbols in the .text
+   section (switch tables use a difference of this sort).  See
+   include/coff/mips.h for details.  This macro checks whether this
+   fixup requires the special reloc.  */
+#define SWITCH_TABLE(fixp) \
+  ((fixp)->fx_r_type == BFD_RELOC_32 \
+   && OUTPUT_FLAVOR != bfd_target_elf_flavour \
+   && (fixp)->fx_addsy != NULL \
+   && (fixp)->fx_subsy != NULL \
+   && S_GET_SEGMENT ((fixp)->fx_addsy) == text_section \
+   && S_GET_SEGMENT ((fixp)->fx_subsy) == text_section)
+
+/* When generating embedded PIC code we must keep all PC relative
+   relocations, in case the linker has to relax a call.  We also need
+   to keep relocations for switch table entries.  */
+
+/*ARGSUSED*/
+int
+mips_force_relocation (fixp)
+     fixS *fixp;
+{
+  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 1;
+
+  return (mips_pic == EMBEDDED_PIC
+	  && (fixp->fx_pcrel
+	      || SWITCH_TABLE (fixp)
+	      || fixp->fx_r_type == BFD_RELOC_PCREL_HI16_S
+	      || fixp->fx_r_type == BFD_RELOC_PCREL_LO16));
+}
+
+/* Apply a fixup to the object file.  */
+
+int
+md_apply_fix (fixP, valueP)
+     fixS *fixP;
+     valueT *valueP;
+{
+  unsigned char *buf;
+  long insn, value;
+
+  assert (fixP->fx_size == 4
+	  || fixP->fx_r_type == BFD_RELOC_16
+	  || fixP->fx_r_type == BFD_RELOC_64
+	  || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+	  || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY);
+
+  value = *valueP;
+
+  /* If we aren't adjusting this fixup to be against the section
+     symbol, we need to adjust the value.  */
+#ifdef OBJ_ELF
+  if (fixP->fx_addsy != NULL && OUTPUT_FLAVOR == bfd_target_elf_flavour)
+    {
+    if (S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16 
+
+/* @@@ CHECK ME - CB */
+    ||  ((S_GET_OTHER (fixP->fx_addsy) == STO_MIPS16)
+	|| (mips_pic == QNX_PIC && S_IS_EXTERN(fixP->fx_addsy)
+		&& fixP->fx_r_type == BFD_RELOC_32 && !S_IS_COMMON(fixP->fx_addsy)))
+
+        || S_IS_WEAK (fixP->fx_addsy)
+        || (symbol_used_in_reloc_p (fixP->fx_addsy)
+            && (((bfd_get_section_flags (stdoutput,
+                                         S_GET_SEGMENT (fixP->fx_addsy))
+                  & SEC_LINK_ONCE) != 0)
+                || !strncmp (segment_name (S_GET_SEGMENT (fixP->fx_addsy)),
+                             ".gnu.linkonce",
+                             sizeof (".gnu.linkonce") - 1))))
+
+      {
+        value -= S_GET_VALUE (fixP->fx_addsy);
+        if (value != 0 && ! fixP->fx_pcrel)
+          {
+            /* In this case, the bfd_install_relocation routine will
+               incorrectly add the symbol value back in.  We just want
+               the addend to appear in the object file.  
+	       FIXME: If this makes VALUE zero, we're toast.  */
+            value -= S_GET_VALUE (fixP->fx_addsy);
+          }
+      }
+
+      /* This code was generated using trial and error and so is
+	 fragile and not trustworthy.  If you change it, you should
+	 rerun the elf-rel, elf-rel2, and empic testcases and ensure
+	 they still pass.  */
+      if (fixP->fx_pcrel || fixP->fx_subsy != NULL)
+	{
+	  value += fixP->fx_frag->fr_address + fixP->fx_where;
+
+	  /* BFD's REL handling, for MIPS, is _very_ weird.
+	     This gives the right results, but it can't possibly
+	     be the way things are supposed to work.  */
+	  if (fixP->fx_r_type != BFD_RELOC_16_PCREL_S2
+	      || S_GET_SEGMENT (fixP->fx_addsy) != undefined_section)
+	    value += fixP->fx_frag->fr_address + fixP->fx_where;
+	}
+    }
+#endif
+
+  fixP->fx_addnumber = value;	/* Remember value for tc_gen_reloc */
+
+  if (fixP->fx_addsy == NULL && ! fixP->fx_pcrel)
+    fixP->fx_done = 1;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_MIPS_JMP:
+    case BFD_RELOC_HI16:
+    case BFD_RELOC_HI16_S:
+    case BFD_RELOC_MIPS_GPREL:
+    case BFD_RELOC_MIPS_LITERAL:
+    case BFD_RELOC_MIPS_CALL16:
+    case BFD_RELOC_MIPS_GOT16:
+    case BFD_RELOC_MIPS_GPREL32:
+    case BFD_RELOC_MIPS_GOT_HI16:
+    case BFD_RELOC_MIPS_GOT_LO16:
+    case BFD_RELOC_MIPS_CALL_HI16:
+    case BFD_RELOC_MIPS_CALL_LO16:
+    case BFD_RELOC_MIPS16_GPREL:
+      if (fixP->fx_pcrel)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("Invalid PC relative reloc"));
+      /* Nothing needed to do. The value comes from the reloc entry */
+      break;
+
+    case BFD_RELOC_MIPS16_JMP:
+      /* We currently always generate a reloc against a symbol, which
+         means that we don't want an addend even if the symbol is
+         defined.  */
+      fixP->fx_addnumber = 0;
+      break;
+
+    case BFD_RELOC_PCREL_HI16_S:
+      /* The addend for this is tricky if it is internal, so we just
+	 do everything here rather than in bfd_install_relocation.  */
+      if (OUTPUT_FLAVOR == bfd_target_elf_flavour 
+	  && !fixP->fx_done
+	  && value != 0)
+	break;
+      if (fixP->fx_addsy
+	  && (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_SECTION_SYM) == 0)
+	{
+	  /* For an external symbol adjust by the address to make it
+	     pcrel_offset.  We use the address of the RELLO reloc
+	     which follows this one.  */
+	  value += (fixP->fx_next->fx_frag->fr_address
+		    + fixP->fx_next->fx_where);
+	}
+      if (value & 0x8000)
+	value += 0x10000;
+      value >>= 16;
+      buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
+      if (target_big_endian)
+	buf += 2;
+      md_number_to_chars (buf, value, 2);
+      break;
+
+    case BFD_RELOC_PCREL_LO16:
+      /* The addend for this is tricky if it is internal, so we just
+	 do everything here rather than in bfd_install_relocation.  */
+      if (OUTPUT_FLAVOR == bfd_target_elf_flavour 
+	  && !fixP->fx_done
+	  && value != 0)
+	break;
+      if (fixP->fx_addsy
+	  && (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_SECTION_SYM) == 0)
+	value += fixP->fx_frag->fr_address + fixP->fx_where;
+      buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
+      if (target_big_endian)
+	buf += 2;
+      md_number_to_chars (buf, value, 2);
+      break;
+
+    case BFD_RELOC_64:
+      /* This is handled like BFD_RELOC_32, but we output a sign
+         extended value if we are only 32 bits.  */
+      if (fixP->fx_done
+	  || (mips_pic == EMBEDDED_PIC && SWITCH_TABLE (fixP)))
+	{
+	  if (8 <= sizeof (valueT))
+	    md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
+				value, 8);
+	  else
+	    {
+	      long w1, w2;
+	      long hiv;
+
+	      w1 = w2 = fixP->fx_where;
+	      if (target_big_endian)
+		w1 += 4;
+	      else
+		w2 += 4;
+	      md_number_to_chars (fixP->fx_frag->fr_literal + w1, value, 4);
+	      if ((value & 0x80000000) != 0)
+		hiv = 0xffffffff;
+	      else
+		hiv = 0;
+	      md_number_to_chars (fixP->fx_frag->fr_literal + w2, hiv, 4);
+	    }
+	}
+      break;
+
+    case BFD_RELOC_RVA:
+    case BFD_RELOC_32:
+      /* If we are deleting this reloc entry, we must fill in the
+	 value now.  This can happen if we have a .word which is not
+	 resolved when it appears but is later defined.  We also need
+	 to fill in the value if this is an embedded PIC switch table
+	 entry.  */
+      if (fixP->fx_done
+	  || (mips_pic == EMBEDDED_PIC && SWITCH_TABLE (fixP)))
+	md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
+			    value, 4);
+      break;
+
+    case BFD_RELOC_16:
+      /* If we are deleting this reloc entry, we must fill in the
+         value now.  */
+      assert (fixP->fx_size == 2);
+      if (fixP->fx_done)
+	md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
+			    value, 2);
+      break;
+
+    case BFD_RELOC_LO16:
+      /* When handling an embedded PIC switch statement, we can wind
+	 up deleting a LO16 reloc.  See the 'o' case in mips_ip.  */
+      if (fixP->fx_done)
+	{
+	  if (value < -0x8000 || value > 0x7fff)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("relocation overflow"));
+	  buf = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
+	  if (target_big_endian)
+	    buf += 2;
+	  md_number_to_chars (buf, value, 2);
+	}
+      break;
+
+    case BFD_RELOC_16_PCREL_S2:
+      /*
+       * We need to save the bits in the instruction since fixup_segment()
+       * might be deleting the relocation entry (i.e., a branch within
+       * the current segment).
+       */
+      if ((value & 0x3) != 0)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("Branch to odd address (%lx)"), value);
+
+      if (!fixP->fx_done && value != 0)
+	break;
+      /* If 'value' is zero, the remaining reloc code won't actually
+	 do the store, so it must be done here.  This is probably
+	 a bug somewhere.  */
+      if (!fixP->fx_done)
+	value -= fixP->fx_frag->fr_address + fixP->fx_where;
+      
+      value >>= 2;
+
+      /* update old instruction data */
+      buf = (unsigned char *) (fixP->fx_where + fixP->fx_frag->fr_literal);
+      if (target_big_endian)
+	insn = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+      else
+	insn = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+
+      if (value >= -0x8000 && value < 0x8000)
+	insn |= value & 0xffff;
+      else
+	{
+	  /* The branch offset is too large.  If this is an
+             unconditional branch, and we are not generating PIC code,
+             we can convert it to an absolute jump instruction.  */
+	  if (mips_pic == NO_PIC
+	      && fixP->fx_done
+	      && fixP->fx_frag->fr_address >= text_section->vma
+	      && (fixP->fx_frag->fr_address
+		  < text_section->vma + text_section->_raw_size)
+	      && ((insn & 0xffff0000) == 0x10000000	 /* beq $0,$0 */
+		  || (insn & 0xffff0000) == 0x04010000	 /* bgez $0 */
+		  || (insn & 0xffff0000) == 0x04110000)) /* bgezal $0 */
+	    {
+	      if ((insn & 0xffff0000) == 0x04110000)	 /* bgezal $0 */
+		insn = 0x0c000000;	/* jal */
+	      else
+		insn = 0x08000000;	/* j */
+	      fixP->fx_r_type = BFD_RELOC_MIPS_JMP;
+	      fixP->fx_done = 0;
+	      fixP->fx_addsy = section_symbol (text_section);
+	      fixP->fx_addnumber = (value << 2) + md_pcrel_from (fixP);
+	    }
+	  else
+	    {
+	      /* FIXME.  It would be possible in principle to handle
+                 conditional branches which overflow.  They could be
+                 transformed into a branch around a jump.  This would
+                 require setting up variant frags for each different
+                 branch type.  The native MIPS assembler attempts to
+                 handle these cases, but it appears to do it
+                 incorrectly.  */
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("Branch out of range"));
+	    }
+	}
+
+      md_number_to_chars ((char *) buf, (valueT) insn, 4);
+      break;
+
+    case BFD_RELOC_VTABLE_INHERIT:
+      fixP->fx_done = 0;
+      if (fixP->fx_addsy
+          && !S_IS_DEFINED (fixP->fx_addsy)
+          && !S_IS_WEAK (fixP->fx_addsy))
+        S_SET_WEAK (fixP->fx_addsy);
+      break;
+
+    case BFD_RELOC_VTABLE_ENTRY:
+      fixP->fx_done = 0;
+      break;
+
+    default:
+      internalError ();
+    }
+
+  return 1;
+}
+
+#if 0
+void
+printInsn (oc)
+     unsigned long oc;
+{
+  const struct mips_opcode *p;
+  int treg, sreg, dreg, shamt;
+  short imm;
+  const char *args;
+  int i;
+
+  for (i = 0; i < NUMOPCODES; ++i)
+    {
+      p = &mips_opcodes[i];
+      if (((oc & p->mask) == p->match) && (p->pinfo != INSN_MACRO))
+	{
+	  printf ("%08lx %s\t", oc, p->name);
+	  treg = (oc >> 16) & 0x1f;
+	  sreg = (oc >> 21) & 0x1f;
+	  dreg = (oc >> 11) & 0x1f;
+	  shamt = (oc >> 6) & 0x1f;
+	  imm = oc;
+	  for (args = p->args;; ++args)
+	    {
+	      switch (*args)
+		{
+		case '\0':
+		  printf ("\n");
+		  break;
+
+		case ',':
+		case '(':
+		case ')':
+		  printf ("%c", *args);
+		  continue;
+
+		case 'r':
+		  assert (treg == sreg);
+		  printf ("$%d,$%d", treg, sreg);
+		  continue;
+
+		case 'd':
+		case 'G':
+		  printf ("$%d", dreg);
+		  continue;
+
+		case 't':
+		case 'E':
+		  printf ("$%d", treg);
+		  continue;
+
+		case 'k':
+		  printf ("0x%x", treg);
+		  continue;
+
+		case 'b':
+		case 's':
+		  printf ("$%d", sreg);
+		  continue;
+
+		case 'a':
+		  printf ("0x%08lx", oc & 0x1ffffff);
+		  continue;
+
+		case 'i':
+		case 'j':
+		case 'o':
+		case 'u':
+		  printf ("%d", imm);
+		  continue;
+
+		case '<':
+		case '>':
+		  printf ("$%d", shamt);
+		  continue;
+
+		default:
+		  internalError ();
+		}
+	      break;
+	    }
+	  return;
+	}
+    }
+  printf (_("%08lx  UNDEFINED\n"), oc);
+}
+#endif
+
+static symbolS *
+get_symbol ()
+{
+  int c;
+  char *name;
+  symbolS *p;
+
+  name = input_line_pointer;
+  c = get_symbol_end ();
+  p = (symbolS *) symbol_find_or_make (name);
+  *input_line_pointer = c;
+  return p;
+}
+
+/* Align the current frag to a given power of two.  The MIPS assembler
+   also automatically adjusts any preceding label.  */
+
+static void
+mips_align (to, fill, label)
+     int to;
+     int fill;
+     symbolS *label;
+{
+  mips_emit_delays (false);
+  frag_align (to, fill, 0);
+  record_alignment (now_seg, to);
+  if (label != NULL)
+    {
+      assert (S_GET_SEGMENT (label) == now_seg);
+      symbol_set_frag (label, frag_now);
+      S_SET_VALUE (label, (valueT) frag_now_fix ());
+    }
+}
+
+/* Align to a given power of two.  .align 0 turns off the automatic
+   alignment used by the data creating pseudo-ops.  */
+
+static void
+s_align (x)
+     int x;
+{
+  register int temp;
+  register long temp_fill;
+  long max_alignment = 15;
+
+  /*
+
+    o  Note that the assembler pulls down any immediately preceeding label
+       to the aligned address.
+    o  It's not documented but auto alignment is reinstated by
+       a .align pseudo instruction.
+    o  Note also that after auto alignment is turned off the mips assembler
+       issues an error on attempt to assemble an improperly aligned data item.
+       We don't.
+
+    */
+
+  temp = get_absolute_expression ();
+  if (temp > max_alignment)
+    as_bad (_("Alignment too large: %d. assumed."), temp = max_alignment);
+  else if (temp < 0)
+    {
+      as_warn (_("Alignment negative: 0 assumed."));
+      temp = 0;
+    }
+  if (*input_line_pointer == ',')
+    {
+      input_line_pointer++;
+      temp_fill = get_absolute_expression ();
+    }
+  else
+    temp_fill = 0;
+  if (temp)
+    {
+      auto_align = 1;
+      mips_align (temp, (int) temp_fill,
+		  insn_labels != NULL ? insn_labels->label : NULL);
+    }
+  else
+    {
+      auto_align = 0;
+    }
+
+  demand_empty_rest_of_line ();
+}
+
+void
+mips_flush_pending_output ()
+{
+  mips_emit_delays (false);
+  mips_clear_insn_labels ();
+}
+
+static void
+s_change_sec (sec)
+     int sec;
+{
+  segT seg;
+
+  /* When generating embedded PIC code, we only use the .text, .lit8,
+     .sdata and .sbss sections.  We change the .data and .rdata
+     pseudo-ops to use .sdata.  */
+  if (mips_pic == EMBEDDED_PIC
+      && (sec == 'd' || sec == 'r'))
+    sec = 's';
+
+#ifdef OBJ_ELF
+  /* The ELF backend needs to know that we are changing sections, so
+     that .previous works correctly.  We could do something like check
+     for a obj_section_change_hook macro, but that might be confusing
+     as it would not be appropriate to use it in the section changing
+     functions in read.c, since obj-elf.c intercepts those.  FIXME:
+     This should be cleaner, somehow.  */
+  obj_elf_section_change_hook ();
+#endif
+
+  mips_emit_delays (false);
+  switch (sec)
+    {
+    case 't':
+      s_text (0);
+      break;
+    case 'd':
+      s_data (0);
+      break;
+    case 'b':
+      subseg_set (bss_section, (subsegT) get_absolute_expression ());
+      demand_empty_rest_of_line ();
+      break;
+
+    case 'r':
+      if (USE_GLOBAL_POINTER_OPT)
+	{
+	  seg = subseg_new (RDATA_SECTION_NAME,
+			    (subsegT) get_absolute_expression ());
+	  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+	    {
+	      bfd_set_section_flags (stdoutput, seg,
+				     (SEC_ALLOC
+				      | SEC_LOAD
+				      | SEC_READONLY
+				      | SEC_RELOC
+				      | SEC_DATA));
+	      if (strcmp (TARGET_OS, "elf") != 0)
+		bfd_set_section_alignment (stdoutput, seg, 4);
+	    }
+	  demand_empty_rest_of_line ();
+	}
+      else
+	{
+	  as_bad (_("No read only data section in this object file format"));
+	  demand_empty_rest_of_line ();
+	  return;
+	}
+      break;
+
+    case 's':
+      if (USE_GLOBAL_POINTER_OPT)
+	{
+	  seg = subseg_new (".sdata", (subsegT) get_absolute_expression ());
+	  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
+	    {
+	      bfd_set_section_flags (stdoutput, seg,
+				     SEC_ALLOC | SEC_LOAD | SEC_RELOC
+				     | SEC_DATA);
+	      if (strcmp (TARGET_OS, "elf") != 0)
+		bfd_set_section_alignment (stdoutput, seg, 4);
+	    }
+	  demand_empty_rest_of_line ();
+	  break;
+	}
+      else
+	{
+	  as_bad (_("Global pointers not supported; recompile -G 0"));
+	  demand_empty_rest_of_line ();
+	  return;
+	}
+    }
+
+  auto_align = 1;
+}
+
+void
+mips_enable_auto_align ()
+{
+  auto_align = 1;
+}
+
+static void
+s_cons (log_size)
+     int log_size;
+{
+  symbolS *label;
+
+  label = insn_labels != NULL ? insn_labels->label : NULL;
+  mips_emit_delays (false);
+  if (log_size > 0 && auto_align)
+    mips_align (log_size, 0, label);
+  mips_clear_insn_labels ();
+  cons (1 << log_size);
+}
+
+static void
+s_float_cons (type)
+     int type;
+{
+  symbolS *label;
+
+  label = insn_labels != NULL ? insn_labels->label : NULL;
+
+  mips_emit_delays (false);
+
+  if (auto_align)
+    {
+      if (type == 'd')
+	mips_align (3, 0, label);
+      else
+	mips_align (2, 0, label);
+    }
+
+  mips_clear_insn_labels ();
+
+  float_cons (type);
+}
+
+/* Handle .globl.  We need to override it because on Irix 5 you are
+   permitted to say
+       .globl foo .text
+   where foo is an undefined symbol, to mean that foo should be
+   considered to be the address of a function.  */
+
+static void
+s_mips_globl (x)
+     int x;
+{
+  char *name;
+  int c;
+  symbolS *symbolP;
+  flagword flag;
+
+  name = input_line_pointer;
+  c = get_symbol_end ();
+  symbolP = symbol_find_or_make (name);
+  *input_line_pointer = c;
+  SKIP_WHITESPACE ();
+
+  /* On Irix 5, every global symbol that is not explicitly labelled as
+     being a function is apparently labelled as being an object.  */
+  flag = BSF_OBJECT;
+
+  if (! is_end_of_line[(unsigned char) *input_line_pointer])
+    {
+      char *secname;
+      asection *sec;
+
+      secname = input_line_pointer;
+      c = get_symbol_end ();
+      sec = bfd_get_section_by_name (stdoutput, secname);
+      if (sec == NULL)
+	as_bad (_("%s: no such section"), secname);
+      *input_line_pointer = c;
+
+      if (sec != NULL && (sec->flags & SEC_CODE) != 0)
+	flag = BSF_FUNCTION;
+    }
+
+  symbol_get_bfdsym (symbolP)->flags |= flag;
+
+  S_SET_EXTERNAL (symbolP);
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_option (x)
+     int x;
+{
+  char *opt;
+  char c;
+
+  opt = input_line_pointer;
+  c = get_symbol_end ();
+
+  if (*opt == 'O')
+    {
+      /* FIXME: What does this mean?  */
+    }
+  else if (strncmp (opt, "pic", 3) == 0)
+    {
+      int i;
+
+      i = atoi (opt + 3);
+      if (i == 0)
+	mips_pic = NO_PIC;
+      else if (i == 2)
+	mips_pic = SVR4_PIC;
+      else
+	as_bad (_(".option pic%d not supported"), i);
+
+      if (USE_GLOBAL_POINTER_OPT && mips_pic == SVR4_PIC)
+	{
+	  if (g_switch_seen && g_switch_value != 0)
+	    as_warn (_("-G may not be used with SVR4 PIC code"));
+	  g_switch_value = 0;
+	  bfd_set_gp_size (stdoutput, 0);
+	}
+    }
+  else
+    as_warn (_("Unrecognized option \"%s\""), opt);
+
+  *input_line_pointer = c;
+  demand_empty_rest_of_line ();
+}
+
+/* This structure is used to hold a stack of .set values.  */
+
+struct mips_option_stack
+{
+  struct mips_option_stack *next;
+  struct mips_set_options options;
+};
+
+static struct mips_option_stack *mips_opts_stack;
+
+/* Handle the .set pseudo-op.  */
+
+static void
+s_mipsset (x)
+     int x;
+{
+  char *name = input_line_pointer, ch;
+
+  while (!is_end_of_line[(unsigned char) *input_line_pointer])
+    input_line_pointer++;
+  ch = *input_line_pointer;
+  *input_line_pointer = '\0';
+
+  if (strcmp (name, "reorder") == 0)
+    {
+      if (mips_opts.noreorder && prev_nop_frag != NULL)
+	{
+	  /* If we still have pending nops, we can discard them.  The
+	     usual nop handling will insert any that are still
+	     needed. */
+	  prev_nop_frag->fr_fix -= (prev_nop_frag_holds
+				    * (mips_opts.mips16 ? 2 : 4));
+	  prev_nop_frag = NULL;
+	}
+      mips_opts.noreorder = 0;
+    }
+  else if (strcmp (name, "noreorder") == 0)
+    {
+      mips_emit_delays (true);
+      mips_opts.noreorder = 1;
+      mips_any_noreorder = 1;
+    }
+  else if (strcmp (name, "at") == 0)
+    {
+      mips_opts.noat = 0;
+    }
+  else if (strcmp (name, "noat") == 0)
+    {
+      mips_opts.noat = 1;
+    }
+  else if (strcmp (name, "macro") == 0)
+    {
+      mips_opts.warn_about_macros = 0;
+    }
+  else if (strcmp (name, "nomacro") == 0)
+    {
+      if (mips_opts.noreorder == 0)
+	as_bad (_("`noreorder' must be set before `nomacro'"));
+      mips_opts.warn_about_macros = 1;
+    }
+  else if (strcmp (name, "move") == 0 || strcmp (name, "novolatile") == 0)
+    {
+      mips_opts.nomove = 0;
+    }
+  else if (strcmp (name, "nomove") == 0 || strcmp (name, "volatile") == 0)
+    {
+      mips_opts.nomove = 1;
+    }
+  else if (strcmp (name, "bopt") == 0)
+    {
+      mips_opts.nobopt = 0;
+    }
+  else if (strcmp (name, "nobopt") == 0)
+    {
+      mips_opts.nobopt = 1;
+    }
+  else if (strcmp (name, "mips16") == 0
+	   || strcmp (name, "MIPS-16") == 0)
+    mips_opts.mips16 = 1;
+  else if (strcmp (name, "nomips16") == 0
+	   || strcmp (name, "noMIPS-16") == 0)
+    mips_opts.mips16 = 0;
+  else if (strncmp (name, "mips", 4) == 0)
+    {
+      int isa;
+
+      /* Permit the user to change the ISA on the fly.  Needless to
+	 say, misuse can cause serious problems.  */
+      isa = atoi (name + 4);
+      if (isa == 0)
+	mips_opts.isa = file_mips_isa;
+      else if (isa < 1 || isa > 4)
+	as_bad (_("unknown ISA level"));
+      else
+	mips_opts.isa = isa;
+    }
+  else if (strcmp (name, "autoextend") == 0)
+    mips_opts.noautoextend = 0;
+  else if (strcmp (name, "noautoextend") == 0)
+    mips_opts.noautoextend = 1;
+  else if (strcmp (name, "push") == 0)
+    {
+      struct mips_option_stack *s;
+
+      s = (struct mips_option_stack *) xmalloc (sizeof *s);
+      s->next = mips_opts_stack;
+      s->options = mips_opts;
+      mips_opts_stack = s;
+    }
+  else if (strcmp (name, "pop") == 0)
+    {
+      struct mips_option_stack *s;
+
+      s = mips_opts_stack;
+      if (s == NULL)
+	as_bad (_(".set pop with no .set push"));
+      else
+	{
+	  /* If we're changing the reorder mode we need to handle
+             delay slots correctly.  */
+	  if (s->options.noreorder && ! mips_opts.noreorder)
+	    mips_emit_delays (true);
+	  else if (! s->options.noreorder && mips_opts.noreorder)
+	    {
+	      if (prev_nop_frag != NULL)
+		{
+		  prev_nop_frag->fr_fix -= (prev_nop_frag_holds
+					    * (mips_opts.mips16 ? 2 : 4));
+		  prev_nop_frag = NULL;
+		}
+	    }
+
+	  mips_opts = s->options;
+	  mips_opts_stack = s->next;
+	  free (s);
+	}
+    }
+  else
+    {
+      as_warn (_("Tried to set unrecognized symbol: %s\n"), name);
+    }
+  *input_line_pointer = ch;
+  demand_empty_rest_of_line ();
+}
+
+/* Handle the .abicalls pseudo-op.  I believe this is equivalent to
+   .option pic2.  It means to generate SVR4 PIC calls.  */
+
+static void
+s_abicalls (ignore)
+     int ignore;
+{
+  mips_pic = SVR4_PIC;
+  if (USE_GLOBAL_POINTER_OPT)
+    {
+      if (g_switch_seen && g_switch_value != 0)
+	as_warn (_("-G may not be used with SVR4 PIC code"));
+      g_switch_value = 0;
+    }
+  bfd_set_gp_size (stdoutput, 0);
+  demand_empty_rest_of_line ();
+}
+
+/* This handles the .qnxpiccalls pseudo-op.i */
+
+static void
+s_qnxpiccalls (ignore)
+     int ignore;
+{
+  mips_pic = QNX_PIC;
+  if (USE_GLOBAL_POINTER_OPT)
+    {
+      if (g_switch_seen && g_switch_value != 0)
+	as_warn ("-G may not be used with QNX PIC code");
+      g_switch_value = 0;
+    }
+  bfd_set_gp_size (stdoutput, 0);
+  demand_empty_rest_of_line ();
+}
+
+/* Allows us to turn off PIC code gen, in case that is needed */
+
+static void
+s_noqnxpiccalls (ignore)
+     int ignore;
+{
+  mips_pic = NO_PIC;
+  demand_empty_rest_of_line ();
+}
+
+/* Handle the .cpload pseudo-op.  This is used when generating SVR4
+   PIC code.  It sets the $gp register for the function based on the
+   function address, which is in the register named in the argument.
+   This uses a relocation against _gp_disp, which is handled specially
+   by the linker.  The result is:
+	lui	$gp,%hi(_gp_disp)
+	addiu	$gp,$gp,%lo(_gp_disp)
+	addu	$gp,$gp,.cpload argument
+   The .cpload argument is normally $25 == $t9.  
+   In the case of QNX pic code, we always compute the full address
+   of the GOT, therefore we do:
+	bltzal 0, 0f
+	nop
+    0:  lui	$23, %hi(_gp_disp)
+	addiu   $23, $23, %lo(_gp_disp)
+	addu	$23, $23, $31
+    One possible optimization would be to move the opcode
+    right before the bltzal into the nop slot.
+    */
+
+static void
+s_cpload (ignore)
+     int ignore;
+{
+  expressionS ex;
+  int icnt = 0;
+
+  /* If we are not generating SVR4 PIC code, .cpload is ignored.  */
+  if ((mips_pic != SVR4_PIC) && (mips_pic != QNX_PIC))
+    {
+      s_ignore (0);
+      return;
+    }
+
+  /* .cpload should be a in .set noreorder section.  */
+  if ((mips_opts.noreorder == 0) && (mips_pic != QNX_PIC))
+    as_warn (_(".cpload not in noreorder section"));
+
+  ex.X_op = O_symbol;
+  ex.X_add_symbol = symbol_find_or_make ("_gp_disp");
+  ex.X_op_symbol = NULL;
+  ex.X_add_number = 0;
+
+  /* In ELF, this symbol is implicitly an STT_OBJECT symbol.  */
+  symbol_get_bfdsym (ex.X_add_symbol)->flags |= BSF_OBJECT;
+
+  if(mips_pic == SVR4_PIC) {
+  	macro_build_lui ((char *) NULL, &icnt, &ex, GP);
+  	macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j", GP, GP,
+		       (int) BFD_RELOC_LO16);
+
+  	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "addu", "d,v,t",
+		       GP, GP, tc_get_register (0));
+  } else if (mips_pic == QNX_PIC) {
+	expressionS ep;
+	/* In our case, we do a bltzal first to get the current IP, and
+	 * then add the offset to the got... Thus, we always do "cpload $31"
+	 */
+	ep.X_op = O_constant;
+	ep.X_add_number = 4;
+	tc_get_register(0);  // Flush any arg to cpload...
+
+	/* See if we can swap the bltzal with the previous insn and save
+	 * the nop...
+	 * For simplicity, we only check that the insn is a move or sw, 
+	 * which are really the only two we should encounter. 
+	 * If it is anything else, we don't swap for now.
+	 */
+	if(0 && (mips_optimize > 1) 
+		&& prev_insn_valid
+		&& (mips_opts.isa > 1)
+		&& !(mips_opts.noreorder)
+		&& (((prev_insn.insn_opcode & 0xfc1f07ff) == 0x00000021)
+		  || ((prev_insn.insn_opcode & 0xfc000000) == 0xac000000))) 
+	  {
+		  char *prev_prev_f,*prev_f;
+		  char temp[4];
+
+		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
+		  memcpy (temp, prev_f, 4);
+		  *(unsigned long *)(prev_f) = 0x04100001;
+//		  prev_insn.insn_opcode = 0x04100001;
+ 		  macro_build ((char *) NULL, &icnt, &ep,
+		       "bltzal", "s,p", 0); 
+
+		  prev_f = prev_insn_frag->fr_literal + prev_insn_where;
+		  memcpy (prev_f, temp, 4);
+		  mips_opts.noreorder ++;
+	  }
+	else 
+	  {     /* We need a NOP... */
+		mips_opts.noreorder ++;
+ 		macro_build ((char *) NULL, &icnt, &ep,
+		       "bltzal", "s,p", 0);
+		macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "nop", "");
+	  }
+  	macro_build_lui ((char *) NULL, &icnt, &ex, 23);
+  	macro_build ((char *) NULL, &icnt, &ex, "addiu", "t,r,j", 23, 23,
+		       (int) BFD_RELOC_LO16);
+	mips_opts.noreorder --; 
+
+  	macro_build ((char *) NULL, &icnt, (expressionS *) NULL, "addu", "d,v,t",
+		       23, 23, RA);
+  }
+  demand_empty_rest_of_line ();
+}
+
+/* Handle the .cprestore pseudo-op.  This stores $gp into a given
+   offset from $sp.  The offset is remembered, and after making a PIC
+   call $gp is restored from that location.  */
+
+static void
+s_cprestore (ignore)
+     int ignore;
+{
+  expressionS ex;
+  int icnt = 0;
+
+  /* If we are not generating SVR4 PIC code, .cprestore is ignored.  */
+  if (mips_pic != SVR4_PIC)
+    {
+      s_ignore (0);
+      return;
+    }
+
+  mips_cprestore_offset = get_absolute_expression ();
+
+  ex.X_op = O_constant;
+  ex.X_add_symbol = NULL;
+  ex.X_op_symbol = NULL;
+  ex.X_add_number = mips_cprestore_offset;
+
+  macro_build ((char *) NULL, &icnt, &ex,
+	       ((bfd_arch_bits_per_address (stdoutput) == 32
+		 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		? "sw" : "sd"),
+	       "t,o(b)", GOT_REG, (int) BFD_RELOC_LO16, SP);
+
+  demand_empty_rest_of_line ();
+}
+
+/* Handle the .gpword pseudo-op.  This is used when generating PIC
+   code.  It generates a 32 bit GP relative reloc.  */
+
+static void
+s_gpword (ignore)
+     int ignore;
+{
+  symbolS *label;
+  expressionS ex;
+  char *p;
+
+  /* When not generating PIC code, this is treated as .word.  */
+  if ((mips_pic != SVR4_PIC) && (mips_pic != QNX_PIC))
+    {
+      s_cons (2);
+      return;
+    }
+
+  label = insn_labels != NULL ? insn_labels->label : NULL;
+  mips_emit_delays (true);
+  if (auto_align)
+    mips_align (2, 0, label);
+  mips_clear_insn_labels ();
+
+  expression (&ex);
+
+  if (ex.X_op != O_symbol || ex.X_add_number != 0)
+    {
+      as_bad (_("Unsupported use of .gpword"));
+      ignore_rest_of_line ();
+    }
+
+  p = frag_more (4);
+  md_number_to_chars (p, (valueT) 0, 4);
+  fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &ex, 0,
+	       BFD_RELOC_MIPS_GPREL32);
+
+  demand_empty_rest_of_line ();
+}
+
+/* Handle the .cpadd pseudo-op.  This is used when dealing with switch
+   tables in SVR4 PIC code.  */
+
+static void
+s_cpadd (ignore)
+     int ignore;
+{
+  int icnt = 0;
+  int reg;
+
+  /* This is ignored when not generating SVR4 PIC code.  */
+  if ((mips_pic != SVR4_PIC) && (mips_pic != QNX_PIC))
+    {
+      s_ignore (0);
+      return;
+    }
+
+  /* Add $gp to the register named as an argument.  */
+  reg = tc_get_register (0);
+  macro_build ((char *) NULL, &icnt, (expressionS *) NULL,
+	       ((bfd_arch_bits_per_address (stdoutput) == 32
+		 || ! ISA_HAS_64BIT_REGS (mips_opts.isa))
+		? "addu" : "daddu"),
+	       "d,v,t", reg, reg, GOT_REG);
+
+  demand_empty_rest_of_line ();  
+}
+
+/* Handle the .insn pseudo-op.  This marks instruction labels in
+   mips16 mode.  This permits the linker to handle them specially,
+   such as generating jalx instructions when needed.  We also make
+   them odd for the duration of the assembly, in order to generate the
+   right sort of code.  We will make them even in the adjust_symtab
+   routine, while leaving them marked.  This is convenient for the
+   debugger and the disassembler.  The linker knows to make them odd
+   again.  */
+
+static void
+s_insn (ignore)
+     int ignore;
+{
+  if (mips_opts.mips16)
+    mips16_mark_labels ();
+
+  demand_empty_rest_of_line ();
+}
+
+/* Handle a .stabn directive.  We need these in order to mark a label
+   as being a mips16 text label correctly.  Sometimes the compiler
+   will emit a label, followed by a .stabn, and then switch sections.
+   If the label and .stabn are in mips16 mode, then the label is
+   really a mips16 text label.  */
+
+static void
+s_mips_stab (type)
+     int type;
+{
+  if (type == 'n' && mips_opts.mips16)
+    mips16_mark_labels ();
+
+  s_stab (type);
+}
+
+/* Handle the .weakext pseudo-op as defined in Kane and Heinrich.
+ */
+
+static void
+s_mips_weakext (ignore)
+     int ignore;
+{
+  char *name;
+  int c;
+  symbolS *symbolP;
+  expressionS exp;
+
+  name = input_line_pointer;
+  c = get_symbol_end ();
+  symbolP = symbol_find_or_make (name);
+  S_SET_WEAK (symbolP);
+  *input_line_pointer = c;
+
+  SKIP_WHITESPACE ();
+
+  if (! is_end_of_line[(unsigned char) *input_line_pointer])
+    {
+      if (S_IS_DEFINED (symbolP))
+	{
+	  as_bad ("Ignoring attempt to redefine symbol `%s'.",
+		  S_GET_NAME (symbolP));
+	  ignore_rest_of_line ();
+	  return;
+	}
+      
+      if (*input_line_pointer == ',')
+	{
+	  ++input_line_pointer;
+	  SKIP_WHITESPACE ();
+	}
+      
+      expression (&exp);
+      if (exp.X_op != O_symbol)
+	{
+	  as_bad ("bad .weakext directive");
+	  ignore_rest_of_line();
+	  return;
+	}
+      symbol_set_value_expression (symbolP, &exp);
+    }
+
+  demand_empty_rest_of_line ();
+}
+
+/* Parse a register string into a number.  Called from the ECOFF code
+   to parse .frame.  The argument is non-zero if this is the frame
+   register, so that we can record it in mips_frame_reg.  */
+
+int
+tc_get_register (frame)
+     int frame;
+{
+  int reg;
+
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer++ != '$')
+    {
+      as_warn (_("expected `$'"));
+      reg = 0;
+    }
+  else if (isdigit ((unsigned char) *input_line_pointer))
+    {
+      reg = get_absolute_expression ();
+      if (reg < 0 || reg >= 32)
+	{
+	  as_warn (_("Bad register number"));
+	  reg = 0;
+	}
+    }
+  else
+    {
+      if (strncmp (input_line_pointer, "fp", 2) == 0)
+	reg = FP;
+      else if (strncmp (input_line_pointer, "sp", 2) == 0)
+	reg = SP;
+      else if (strncmp (input_line_pointer, "gp", 2) == 0)
+	reg = GP;
+      else if (strncmp (input_line_pointer, "at", 2) == 0)
+	reg = AT;
+      else
+	{
+	  as_warn (_("Unrecognized register name"));
+	  reg = 0;
+	}
+      input_line_pointer += 2;
+    }
+  if (frame)
+    mips_frame_reg = reg != 0 ? reg : SP;
+  return reg;
+}
+
+valueT
+md_section_align (seg, addr)
+     asection *seg;
+     valueT addr;
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+
+#ifdef OBJ_ELF
+  /* We don't need to align ELF sections to the full alignment.
+     However, Irix 5 may prefer that we align them at least to a 16
+     byte boundary.  We don't bother to align the sections if we are
+     targeted for an embedded system.  */
+  if (strcmp (TARGET_OS, "elf") == 0)
+    return addr;
+  if (align > 4)
+    align = 4;
+#endif
+
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+/* Utility routine, called from above as well.  If called while the
+   input file is still being read, it's only an approximation.  (For
+   example, a symbol may later become defined which appeared to be
+   undefined earlier.)  */
+
+static int
+nopic_need_relax (sym, before_relaxing)
+     symbolS *sym;
+     int before_relaxing;
+{
+  if (sym == 0)
+    return 0;
+
+  if (USE_GLOBAL_POINTER_OPT)
+    {
+      const char *symname;
+      int change;
+
+      /* Find out whether this symbol can be referenced off the GP
+	 register.  It can be if it is smaller than the -G size or if
+	 it is in the .sdata or .sbss section.  Certain symbols can
+	 not be referenced off the GP, although it appears as though
+	 they can.  */
+      symname = S_GET_NAME (sym);
+      if (symname != (const char *) NULL
+	  && (strcmp (symname, "eprol") == 0
+	      || strcmp (symname, "etext") == 0
+	      || strcmp (symname, "_gp") == 0
+	      || strcmp (symname, "edata") == 0
+	      || strcmp (symname, "_fbss") == 0
+	      || strcmp (symname, "_fdata") == 0
+	      || strcmp (symname, "_ftext") == 0
+	      || strcmp (symname, "end") == 0
+	      || strcmp (symname, "_gp_disp") == 0))
+	change = 1;
+      else if ((! S_IS_DEFINED (sym) || S_IS_COMMON (sym))
+	       && (0
+#ifndef NO_ECOFF_DEBUGGING
+		   || (symbol_get_obj (sym)->ecoff_extern_size != 0
+		       && (symbol_get_obj (sym)->ecoff_extern_size
+			   <= g_switch_value))
+#endif
+		   /* We must defer this decision until after the whole
+		      file has been read, since there might be a .extern
+		      after the first use of this symbol.  */
+		   || (before_relaxing
+#ifndef NO_ECOFF_DEBUGGING
+		       && symbol_get_obj (sym)->ecoff_extern_size == 0
+#endif
+		       && S_GET_VALUE (sym) == 0)
+		   || (S_GET_VALUE (sym) != 0
+		       && S_GET_VALUE (sym) <= g_switch_value)))
+	change = 0;
+      else
+	{
+	  const char *segname;
+
+	  segname = segment_name (S_GET_SEGMENT (sym));
+	  assert (strcmp (segname, ".lit8") != 0
+		  && strcmp (segname, ".lit4") != 0);
+	  change = (strcmp (segname, ".sdata") != 0
+		    && strcmp (segname, ".sbss") != 0
+		    && strncmp (segname, ".sdata.", 7) != 0
+		    && strncmp (segname, ".gnu.linkonce.s.", 16) != 0);
+	}
+      return change;
+    }
+  else
+    /* We are not optimizing for the GP register.  */
+    return 1;
+}
+
+/* Given a mips16 variant frag FRAGP, return non-zero if it needs an
+   extended opcode.  SEC is the section the frag is in.  */
+
+static int
+mips16_extended_frag (fragp, sec, stretch)
+     fragS *fragp;
+     asection *sec;
+     long stretch;
+{
+  int type;
+  register const struct mips16_immed_operand *op;
+  offsetT val;
+  int mintiny, maxtiny;
+  segT symsec;
+
+  if (RELAX_MIPS16_USER_SMALL (fragp->fr_subtype))
+    return 0;
+  if (RELAX_MIPS16_USER_EXT (fragp->fr_subtype))
+    return 1;
+
+  type = RELAX_MIPS16_TYPE (fragp->fr_subtype);
+  op = mips16_immed_operands;
+  while (op->type != type)
+    {
+      ++op;
+      assert (op < mips16_immed_operands + MIPS16_NUM_IMMED);
+    }
+
+  if (op->unsp)
+    {
+      if (type == '<' || type == '>' || type == '[' || type == ']')
+	{
+	  mintiny = 1;
+	  maxtiny = 1 << op->nbits;
+	}
+      else
+	{
+	  mintiny = 0;
+	  maxtiny = (1 << op->nbits) - 1;
+	}
+    }
+  else
+    {
+      mintiny = - (1 << (op->nbits - 1));
+      maxtiny = (1 << (op->nbits - 1)) - 1;
+    }
+
+  /* We can't always call S_GET_VALUE here, because we don't want to
+     lock in a particular frag address.  */
+  if (symbol_constant_p (fragp->fr_symbol))
+    {
+      val = (S_GET_VALUE (fragp->fr_symbol)
+	     + symbol_get_frag (fragp->fr_symbol)->fr_address);
+      symsec = S_GET_SEGMENT (fragp->fr_symbol);
+    }
+  else if (symbol_equated_p (fragp->fr_symbol)
+	   && (symbol_constant_p
+	       (symbol_get_value_expression (fragp->fr_symbol)->X_add_symbol)))
+    {
+      symbolS *eqsym;
+
+      eqsym = symbol_get_value_expression (fragp->fr_symbol)->X_add_symbol;
+      val = (S_GET_VALUE (eqsym)
+	     + symbol_get_frag (eqsym)->fr_address
+	     + symbol_get_value_expression (fragp->fr_symbol)->X_add_number
+	     + symbol_get_frag (fragp->fr_symbol)->fr_address);
+      symsec = S_GET_SEGMENT (eqsym);
+    }
+  else
+    return 1;
+
+  if (op->pcrel)
+    {
+      addressT addr;
+
+      /* We won't have the section when we are called from
+         mips_relax_frag.  However, we will always have been called
+         from md_estimate_size_before_relax first.  If this is a
+         branch to a different section, we mark it as such.  If SEC is
+         NULL, and the frag is not marked, then it must be a branch to
+         the same section.  */
+      if (sec == NULL)
+	{
+	  if (RELAX_MIPS16_LONG_BRANCH (fragp->fr_subtype))
+	    return 1;
+	}
+      else
+	{
+	  if (symsec != sec)
+	    {
+	      fragp->fr_subtype =
+		RELAX_MIPS16_MARK_LONG_BRANCH (fragp->fr_subtype);
+
+	      /* FIXME: We should support this, and let the linker
+                 catch branches and loads that are out of range.  */
+	      as_bad_where (fragp->fr_file, fragp->fr_line,
+			    _("unsupported PC relative reference to different section"));
+
+	      return 1;
+	    }
+	}
+
+      /* In this case, we know for sure that the symbol fragment is in
+	 the same section.  If the fr_address of the symbol fragment
+	 is greater then the address of this fragment we want to add
+	 in STRETCH in order to get a better estimate of the address.
+	 This particularly matters because of the shift bits.  */
+      if (stretch != 0
+	  && (symbol_get_frag (fragp->fr_symbol)->fr_address
+	      >= fragp->fr_address))
+	{
+	  fragS *f;
+
+	  /* Adjust stretch for any alignment frag.  Note that if have
+             been expanding the earlier code, the symbol may be
+             defined in what appears to be an earlier frag.  FIXME:
+             This doesn't handle the fr_subtype field, which specifies
+             a maximum number of bytes to skip when doing an
+             alignment.  */
+	  for (f = fragp;
+	       f != NULL && f != symbol_get_frag (fragp->fr_symbol);
+	       f = f->fr_next)
+	    {
+	      if (f->fr_type == rs_align || f->fr_type == rs_align_code)
+		{
+		  if (stretch < 0)
+		    stretch = - ((- stretch)
+				 & ~ ((1 << (int) f->fr_offset) - 1));
+		  else
+		    stretch &= ~ ((1 << (int) f->fr_offset) - 1);
+		  if (stretch == 0)
+		    break;
+		}
+	    }
+	  if (f != NULL)
+	    val += stretch;
+	}
+
+      addr = fragp->fr_address + fragp->fr_fix;
+
+      /* The base address rules are complicated.  The base address of
+         a branch is the following instruction.  The base address of a
+         PC relative load or add is the instruction itself, but if it
+         is in a delay slot (in which case it can not be extended) use
+         the address of the instruction whose delay slot it is in.  */
+      if (type == 'p' || type == 'q')
+	{
+	  addr += 2;
+
+	  /* If we are currently assuming that this frag should be
+	     extended, then, the current address is two bytes
+	     higher. */
+	  if (RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
+	    addr += 2;
+
+	  /* Ignore the low bit in the target, since it will be set
+             for a text label.  */
+	  if ((val & 1) != 0)
+	    --val;
+	}
+      else if (RELAX_MIPS16_JAL_DSLOT (fragp->fr_subtype))
+	addr -= 4;
+      else if (RELAX_MIPS16_DSLOT (fragp->fr_subtype))
+	addr -= 2;
+
+      val -= addr & ~ ((1 << op->shift) - 1);
+
+      /* Branch offsets have an implicit 0 in the lowest bit.  */
+      if (type == 'p' || type == 'q')
+	val /= 2;
+
+      /* If any of the shifted bits are set, we must use an extended
+         opcode.  If the address depends on the size of this
+         instruction, this can lead to a loop, so we arrange to always
+         use an extended opcode.  We only check this when we are in
+         the main relaxation loop, when SEC is NULL.  */
+      if ((val & ((1 << op->shift) - 1)) != 0 && sec == NULL)
+	{
+	  fragp->fr_subtype =
+	    RELAX_MIPS16_MARK_LONG_BRANCH (fragp->fr_subtype);
+	  return 1;
+	}
+
+      /* If we are about to mark a frag as extended because the value
+         is precisely maxtiny + 1, then there is a chance of an
+         infinite loop as in the following code:
+	     la	$4,foo
+	     .skip	1020
+	     .align	2
+	   foo:
+	 In this case when the la is extended, foo is 0x3fc bytes
+	 away, so the la can be shrunk, but then foo is 0x400 away, so
+	 the la must be extended.  To avoid this loop, we mark the
+	 frag as extended if it was small, and is about to become
+	 extended with a value of maxtiny + 1.  */
+      if (val == ((maxtiny + 1) << op->shift)
+	  && ! RELAX_MIPS16_EXTENDED (fragp->fr_subtype)
+	  && sec == NULL)
+	{
+	  fragp->fr_subtype =
+	    RELAX_MIPS16_MARK_LONG_BRANCH (fragp->fr_subtype);
+	  return 1;
+	}
+    }
+  else if (symsec != absolute_section && sec != NULL)
+    as_bad_where (fragp->fr_file, fragp->fr_line, _("unsupported relocation"));
+
+  if ((val & ((1 << op->shift) - 1)) != 0
+      || val < (mintiny << op->shift)
+      || val > (maxtiny << op->shift))
+    return 1;
+  else
+    return 0;
+}
+
+/* Estimate the size of a frag before relaxing.  Unless this is the
+   mips16, we are not really relaxing here, and the final size is
+   encoded in the subtype information.  For the mips16, we have to
+   decide whether we are using an extended opcode or not.  */
+
+/*ARGSUSED*/
+int
+md_estimate_size_before_relax (fragp, segtype)
+     fragS *fragp;
+     asection *segtype;
+{
+  int change;
+
+  if (RELAX_MIPS16_P (fragp->fr_subtype))
+    {
+      if (mips16_extended_frag (fragp, segtype, 0))
+	{
+	  fragp->fr_subtype = RELAX_MIPS16_MARK_EXTENDED (fragp->fr_subtype);
+	  return 4;
+	}
+      else
+	{
+	  fragp->fr_subtype = RELAX_MIPS16_CLEAR_EXTENDED (fragp->fr_subtype);
+	  return 2;
+	}
+    }
+
+  if (mips_pic == NO_PIC)
+    {
+      change = nopic_need_relax (fragp->fr_symbol, 0);
+    }
+  else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+    {
+      symbolS *sym;
+      asection *symsec;
+
+      sym = fragp->fr_symbol;
+
+      /* Handle the case of a symbol equated to another symbol.  */
+      while (symbol_equated_p (sym)
+	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
+	{
+	  symbolS *n;
+
+	  /* It's possible to get a loop here in a badly written
+             program.  */
+	  n = symbol_get_value_expression (sym)->X_add_symbol;
+	  if (n == sym)
+	    break;
+	  sym = n;
+	}
+
+      symsec = S_GET_SEGMENT (sym);
+
+      /* This must duplicate the test in adjust_reloc_syms.  */
+      change = (symsec != &bfd_und_section
+		&& symsec != &bfd_abs_section
+		&& ((mips_pic != QNX_PIC) || ((mips_pic == QNX_PIC) && !S_IS_EXTERN(sym)))
+		&& ! bfd_is_com_section (symsec));
+    }
+  else
+    abort ();
+
+  if (change)
+    {
+      /* Record the offset to the first reloc in the fr_opcode field.
+	 This lets md_convert_frag and tc_gen_reloc know that the code
+	 must be expanded.  */
+      fragp->fr_opcode = (fragp->fr_literal
+			  + fragp->fr_fix
+			  - RELAX_OLD (fragp->fr_subtype)
+			  + RELAX_RELOC1 (fragp->fr_subtype));
+      /* FIXME: This really needs as_warn_where.  */
+      if (RELAX_WARN (fragp->fr_subtype))
+	as_warn (_("AT used after \".set noat\" or macro used after \".set nomacro\""));
+    }
+
+  if (! change)
+    return 0;
+  else
+    return RELAX_NEW (fragp->fr_subtype) - RELAX_OLD (fragp->fr_subtype);
+}
+
+/* This is called to see whether a reloc against a defined symbol
+   should be converted into a reloc against a section.  Don't adjust
+   MIPS16 jump relocations, so we don't have to worry about the format
+   of the offset in the .o file.  Don't adjust relocations against
+   mips16 symbols, so that the linker can find them if it needs to set
+   up a stub.  */
+
+int
+mips_fix_adjustable (fixp)
+     fixS *fixp;
+{
+  if (fixp->fx_r_type == BFD_RELOC_MIPS16_JMP)
+    return 0;
+  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 0;
+  if (fixp->fx_addsy == NULL)
+    return 1;
+  if ((mips_pic == QNX_PIC) && 
+	(fixp->fx_r_type == BFD_RELOC_MIPS_GOT16 || fixp->fx_r_type == BFD_RELOC_32)) 
+    {
+      symbolS * sym = fixp->fx_addsy;
+      if (S_IS_EXTERN(sym) || S_IS_WEAK(sym)) return 0;
+    }
+#ifdef OBJ_ELF
+  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
+      && S_GET_OTHER (fixp->fx_addsy) == STO_MIPS16
+      && fixp->fx_subsy == NULL)
+    return 0;
+#endif
+  return 1;
+}
+
+/* Translate internal representation of relocation info to BFD target
+   format.  */
+
+arelent **
+tc_gen_reloc (section, fixp)
+     asection *section;
+     fixS *fixp;
+{
+  static arelent *retval[4];
+  arelent *reloc;
+  bfd_reloc_code_real_type code;
+
+  reloc = retval[0] = (arelent *) xmalloc (sizeof (arelent));
+  retval[1] = NULL;
+
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (mips_pic == EMBEDDED_PIC
+      && SWITCH_TABLE (fixp))
+    {
+      /* For a switch table entry we use a special reloc.  The addend
+	 is actually the difference between the reloc address and the
+	 subtrahend.  */
+      reloc->addend = reloc->address - S_GET_VALUE (fixp->fx_subsy);
+      if (OUTPUT_FLAVOR != bfd_target_ecoff_flavour)
+	as_fatal (_("Double check fx_r_type in tc-mips.c:tc_gen_reloc"));
+      fixp->fx_r_type = BFD_RELOC_GPREL32;
+    }
+  else if (fixp->fx_pcrel == 0 || OUTPUT_FLAVOR == bfd_target_elf_flavour)
+    reloc->addend = fixp->fx_addnumber;
+  else if (fixp->fx_r_type == BFD_RELOC_PCREL_LO16)
+    {
+      /* We use a special addend for an internal RELLO reloc.  */
+      if (symbol_section_p (fixp->fx_addsy))
+	reloc->addend = reloc->address - S_GET_VALUE (fixp->fx_subsy);
+      else
+	reloc->addend = fixp->fx_addnumber + reloc->address;
+    }
+  else if (fixp->fx_r_type == BFD_RELOC_PCREL_HI16_S)
+    {
+      assert (fixp->fx_next != NULL
+	      && fixp->fx_next->fx_r_type == BFD_RELOC_PCREL_LO16);
+      /* We use a special addend for an internal RELHI reloc.  The
+	 reloc is relative to the RELLO; adjust the addend
+	 accordingly.  */
+      if (symbol_section_p (fixp->fx_addsy))
+	reloc->addend = (fixp->fx_next->fx_frag->fr_address
+			 + fixp->fx_next->fx_where
+			 - S_GET_VALUE (fixp->fx_subsy));
+      else
+	reloc->addend = (fixp->fx_addnumber
+			 + fixp->fx_next->fx_frag->fr_address
+			 + fixp->fx_next->fx_where);
+    }
+  else
+    {
+      if (OUTPUT_FLAVOR != bfd_target_aout_flavour)
+	/* A gruesome hack which is a result of the gruesome gas reloc
+	   handling.  */
+	reloc->addend = reloc->address;
+      else
+	reloc->addend = -reloc->address;
+    }
+
+  /* If this is a variant frag, we may need to adjust the existing
+     reloc and generate a new one.  */
+  if (fixp->fx_frag->fr_opcode != NULL
+      && (fixp->fx_r_type == BFD_RELOC_MIPS_GPREL
+	  || fixp->fx_r_type == BFD_RELOC_MIPS_GOT16
+	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL16
+	  || fixp->fx_r_type == BFD_RELOC_MIPS_GOT_HI16
+	  || fixp->fx_r_type == BFD_RELOC_MIPS_GOT_LO16
+	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL_HI16
+	  || fixp->fx_r_type == BFD_RELOC_MIPS_CALL_LO16))
+    {
+      arelent *reloc2;
+
+      assert (! RELAX_MIPS16_P (fixp->fx_frag->fr_subtype));
+
+      /* If this is not the last reloc in this frag, then we have two
+	 GPREL relocs, or a GOT_HI16/GOT_LO16 pair, or a
+	 CALL_HI16/CALL_LO16, both of which are being replaced.  Let
+	 the second one handle all of them.  */
+      if (fixp->fx_next != NULL
+	  && fixp->fx_frag == fixp->fx_next->fx_frag)
+	{
+	  assert ((fixp->fx_r_type == BFD_RELOC_MIPS_GPREL
+		   && fixp->fx_next->fx_r_type == BFD_RELOC_MIPS_GPREL)
+		  || (fixp->fx_r_type == BFD_RELOC_MIPS_GOT_HI16
+		      && (fixp->fx_next->fx_r_type
+			  == BFD_RELOC_MIPS_GOT_LO16))
+		  || (fixp->fx_r_type == BFD_RELOC_MIPS_CALL_HI16
+		      && (fixp->fx_next->fx_r_type
+			  == BFD_RELOC_MIPS_CALL_LO16)));
+	  retval[0] = NULL;
+	  return retval;
+	}
+
+      fixp->fx_where = fixp->fx_frag->fr_opcode - fixp->fx_frag->fr_literal;
+      reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+      reloc2 = retval[1] = (arelent *) xmalloc (sizeof (arelent));
+      retval[2] = NULL;
+      reloc2->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+      *reloc2->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+      reloc2->address = (reloc->address
+			 + (RELAX_RELOC2 (fixp->fx_frag->fr_subtype)
+			    - RELAX_RELOC1 (fixp->fx_frag->fr_subtype)));
+      reloc2->addend = fixp->fx_addnumber;
+      reloc2->howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_LO16);
+      assert (reloc2->howto != NULL);
+
+      if (RELAX_RELOC3 (fixp->fx_frag->fr_subtype))
+	{
+	  arelent *reloc3;
+
+	  reloc3 = retval[2] = (arelent *) xmalloc (sizeof (arelent));
+	  retval[3] = NULL;
+	  *reloc3 = *reloc2;
+	  reloc3->address += 4;
+	}
+
+      if (mips_pic == NO_PIC)
+	{
+	  assert (fixp->fx_r_type == BFD_RELOC_MIPS_GPREL);
+	  fixp->fx_r_type = BFD_RELOC_HI16_S;
+	}
+      else if ((mips_pic == SVR4_PIC) || (mips_pic == QNX_PIC))
+	{
+	  switch (fixp->fx_r_type)
+	    {
+	    default:
+	      abort ();
+	    case BFD_RELOC_MIPS_GOT16:
+	      break;
+	    case BFD_RELOC_MIPS_CALL16:
+	    case BFD_RELOC_MIPS_GOT_LO16:
+	    case BFD_RELOC_MIPS_CALL_LO16:
+	      fixp->fx_r_type = BFD_RELOC_MIPS_GOT16;
+	      break;
+	    }
+	}
+      else
+	abort ();
+    }
+
+  /* Since MIPS ELF uses Rel instead of Rela, encode the vtable entry
+     to be used in the relocation's section offset.  */
+  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    {
+      reloc->address = reloc->addend;
+      reloc->addend = 0;
+    }
+
+  /* Since DIFF_EXPR_OK is defined in tc-mips.h, it is possible that
+     fixup_segment converted a non-PC relative reloc into a PC
+     relative reloc.  In such a case, we need to convert the reloc
+     code.  */
+  code = fixp->fx_r_type;
+  if (fixp->fx_pcrel)
+    {
+      switch (code)
+	{
+	case BFD_RELOC_8:
+	  code = BFD_RELOC_8_PCREL;
+	  break;
+	case BFD_RELOC_16:
+	  code = BFD_RELOC_16_PCREL;
+	  break;
+	case BFD_RELOC_32:
+	  code = BFD_RELOC_32_PCREL;
+	  break;
+	case BFD_RELOC_64:
+	  code = BFD_RELOC_64_PCREL;
+	  break;
+	case BFD_RELOC_8_PCREL:
+	case BFD_RELOC_16_PCREL:
+	case BFD_RELOC_32_PCREL:
+	case BFD_RELOC_64_PCREL:
+	case BFD_RELOC_16_PCREL_S2:
+	case BFD_RELOC_PCREL_HI16_S:
+	case BFD_RELOC_PCREL_LO16:
+	  break;
+	default:
+	  as_bad_where (fixp->fx_file, fixp->fx_line,
+			_("Cannot make %s relocation PC relative"),
+			bfd_get_reloc_code_name (code));
+	}
+    }
+
+  /* To support a PC relative reloc when generating embedded PIC code
+     for ECOFF, we use a Cygnus extension.  We check for that here to
+     make sure that we don't let such a reloc escape normally.  */
+  if ((OUTPUT_FLAVOR == bfd_target_ecoff_flavour
+       || OUTPUT_FLAVOR == bfd_target_elf_flavour)
+      && code == BFD_RELOC_16_PCREL_S2
+      && mips_pic != EMBEDDED_PIC)
+    reloc->howto = NULL;
+  else
+    reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("Can not represent %s relocation in this object file format"),
+		    bfd_get_reloc_code_name (code));
+      retval[0] = NULL;
+    }
+
+  return retval;
+}
+
+/* Relax a machine dependent frag.  This returns the amount by which
+   the current size of the frag should change.  */
+
+int
+mips_relax_frag (fragp, stretch)
+     fragS *fragp;
+     long stretch;
+{
+  if (! RELAX_MIPS16_P (fragp->fr_subtype))
+    return 0;
+
+  if (mips16_extended_frag (fragp, (asection *) NULL, stretch))
+    {
+      if (RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
+	return 0;
+      fragp->fr_subtype = RELAX_MIPS16_MARK_EXTENDED (fragp->fr_subtype);
+      return 2;
+    }
+  else
+    {
+      if (! RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
+	return 0;
+      fragp->fr_subtype = RELAX_MIPS16_CLEAR_EXTENDED (fragp->fr_subtype);
+      return -2;
+    }
+
+  return 0;
+}
+
+/* Convert a machine dependent frag.  */
+
+void
+md_convert_frag (abfd, asec, fragp)
+     bfd *abfd;
+     segT asec;
+     fragS *fragp;
+{
+  int old, new;
+  char *fixptr;
+
+  if (RELAX_MIPS16_P (fragp->fr_subtype))
+    {
+      int type;
+      register const struct mips16_immed_operand *op;
+      boolean small, ext;
+      offsetT val;
+      bfd_byte *buf;
+      unsigned long insn;
+      boolean use_extend;
+      unsigned short extend;
+
+      type = RELAX_MIPS16_TYPE (fragp->fr_subtype);
+      op = mips16_immed_operands;
+      while (op->type != type)
+	++op;
+
+      if (RELAX_MIPS16_EXTENDED (fragp->fr_subtype))
+	{
+	  small = false;
+	  ext = true;
+	}
+      else
+	{
+	  small = true;
+	  ext = false;
+	}
+
+      resolve_symbol_value (fragp->fr_symbol, 1);
+      val = S_GET_VALUE (fragp->fr_symbol);
+      if (op->pcrel)
+	{
+	  addressT addr;
+
+	  addr = fragp->fr_address + fragp->fr_fix;
+
+	  /* The rules for the base address of a PC relative reloc are
+             complicated; see mips16_extended_frag.  */
+	  if (type == 'p' || type == 'q')
+	    {
+	      addr += 2;
+	      if (ext)
+		addr += 2;
+	      /* Ignore the low bit in the target, since it will be
+                 set for a text label.  */
+	      if ((val & 1) != 0)
+		--val;
+	    }
+	  else if (RELAX_MIPS16_JAL_DSLOT (fragp->fr_subtype))
+	    addr -= 4;
+	  else if (RELAX_MIPS16_DSLOT (fragp->fr_subtype))
+	    addr -= 2;
+
+	  addr &= ~ (addressT) ((1 << op->shift) - 1);
+	  val -= addr;
+
+	  /* Make sure the section winds up with the alignment we have
+             assumed.  */
+	  if (op->shift > 0)
+	    record_alignment (asec, op->shift);
+	}
+
+      if (ext
+	  && (RELAX_MIPS16_JAL_DSLOT (fragp->fr_subtype)
+	      || RELAX_MIPS16_DSLOT (fragp->fr_subtype)))
+	as_warn_where (fragp->fr_file, fragp->fr_line,
+		       _("extended instruction in delay slot"));
+
+      buf = (bfd_byte *) (fragp->fr_literal + fragp->fr_fix);
+
+      if (target_big_endian)
+	insn = bfd_getb16 (buf);
+      else
+	insn = bfd_getl16 (buf);
+
+      mips16_immed (fragp->fr_file, fragp->fr_line, type, val,
+		    RELAX_MIPS16_USER_EXT (fragp->fr_subtype),
+		    small, ext, &insn, &use_extend, &extend);
+
+      if (use_extend)
+	{
+	  md_number_to_chars (buf, 0xf000 | extend, 2);
+	  fragp->fr_fix += 2;
+	  buf += 2;
+	}
+
+      md_number_to_chars (buf, insn, 2);
+      fragp->fr_fix += 2;
+      buf += 2;
+    }
+  else
+    {
+      if (fragp->fr_opcode == NULL)
+	return;
+
+      old = RELAX_OLD (fragp->fr_subtype);
+      new = RELAX_NEW (fragp->fr_subtype);
+      fixptr = fragp->fr_literal + fragp->fr_fix;
+
+      if (new > 0)
+	memcpy (fixptr - old, fixptr, new);
+
+      fragp->fr_fix += new - old;
+    }
+}
+
+#ifdef OBJ_ELF
+
+/* This function is called after the relocs have been generated.
+   We've been storing mips16 text labels as odd.  Here we convert them
+   back to even for the convenience of the debugger.  */
+
+void
+mips_frob_file_after_relocs ()
+{
+  asymbol **syms;
+  unsigned int count, i;
+
+  if (OUTPUT_FLAVOR != bfd_target_elf_flavour)
+    return;
+
+  syms = bfd_get_outsymbols (stdoutput);
+  count = bfd_get_symcount (stdoutput);
+  for (i = 0; i < count; i++, syms++)
+    {
+      if (elf_symbol (*syms)->internal_elf_sym.st_other == STO_MIPS16
+	  && ((*syms)->value & 1) != 0)
+	{
+	  (*syms)->value &= ~1;
+	  /* If the symbol has an odd size, it was probably computed
+	     incorrectly, so adjust that as well.  */
+	  if ((elf_symbol (*syms)->internal_elf_sym.st_size & 1) != 0)
+	    ++elf_symbol (*syms)->internal_elf_sym.st_size;
+	}
+    }
+}
+
+#endif
+
+/* This function is called whenever a label is defined.  It is used
+   when handling branch delays; if a branch has a label, we assume we
+   can not move it.  */
+
+void
+mips_define_label (sym)
+     symbolS *sym;
+{
+  struct insn_label_list *l;
+
+  if (free_insn_labels == NULL)
+    l = (struct insn_label_list *) xmalloc (sizeof *l);
+  else
+    {
+      l = free_insn_labels;
+      free_insn_labels = l->next;
+    }
+
+  l->label = sym;
+  l->next = insn_labels;
+  insn_labels = l;
+}
+
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+
+/* Some special processing for a MIPS ELF file.  */
+
+void
+mips_elf_final_processing ()
+{
+  /* Write out the register information.  */
+  if (! mips_64)
+    {
+      Elf32_RegInfo s;
+
+      s.ri_gprmask = mips_gprmask;
+      s.ri_cprmask[0] = mips_cprmask[0];
+      s.ri_cprmask[1] = mips_cprmask[1];
+      s.ri_cprmask[2] = mips_cprmask[2];
+      s.ri_cprmask[3] = mips_cprmask[3];
+      /* The gp_value field is set by the MIPS ELF backend.  */
+
+      bfd_mips_elf32_swap_reginfo_out (stdoutput, &s,
+				       ((Elf32_External_RegInfo *)
+					mips_regmask_frag));
+    }
+  else
+    {
+      Elf64_Internal_RegInfo s;
+
+      s.ri_gprmask = mips_gprmask;
+      s.ri_pad = 0;
+      s.ri_cprmask[0] = mips_cprmask[0];
+      s.ri_cprmask[1] = mips_cprmask[1];
+      s.ri_cprmask[2] = mips_cprmask[2];
+      s.ri_cprmask[3] = mips_cprmask[3];
+      /* The gp_value field is set by the MIPS ELF backend.  */
+
+      bfd_mips_elf64_swap_reginfo_out (stdoutput, &s,
+				       ((Elf64_External_RegInfo *)
+					mips_regmask_frag));
+    }
+
+  /* Set the MIPS ELF flag bits.  FIXME: There should probably be some
+     sort of BFD interface for this.  */
+  if (mips_any_noreorder)
+    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_NOREORDER;
+  if (mips_pic != NO_PIC && mips_pic != QNX_PIC)
+    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_PIC;
+
+  /* Set the MIPS ELF ABI flags. */
+  if (mips_abi_string == 0)
+    ;
+  else if (strcmp (mips_abi_string,"32") == 0)
+    elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_O32;
+  else if (strcmp (mips_abi_string,"o64") == 0)
+    elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_O64;
+  else if (strcmp (mips_abi_string,"eabi") == 0)
+    {
+      if (mips_eabi64)
+	elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_EABI64;
+      else
+	elf_elfheader (stdoutput)->e_flags |= E_MIPS_ABI_EABI32;
+    }
+
+  if (mips_32bitmode)
+    elf_elfheader (stdoutput)->e_flags |= EF_MIPS_32BITMODE;
+}
+
+#endif /* OBJ_ELF || OBJ_MAYBE_ELF */
+
+typedef struct proc
+  {
+    symbolS *isym;
+    unsigned long reg_mask;
+    unsigned long reg_offset;
+    unsigned long fpreg_mask;
+    unsigned long fpreg_offset;
+    unsigned long frame_offset;
+    unsigned long frame_reg;
+    unsigned long pc_reg;
+  }
+procS;
+
+static procS cur_proc;
+static procS *cur_proc_ptr;
+static int numprocs;
+
+/* When we align code in the .text section of mips16, use the correct two
+   byte nop pattern of 0x6500 (move $0,$0) */
+
+int
+mips_do_align (n, fill, len, max)
+     int n;
+     const char *fill;
+     int len;
+     int max;
+{
+  if (fill == NULL
+      && subseg_text_p (now_seg)
+      && n > 1
+      && mips_opts.mips16)
+    {
+      static const unsigned char be_nop[] = { 0x65, 0x00 };
+      static const unsigned char le_nop[] = { 0x00, 0x65 };
+
+      frag_align (1, 0, 0);
+
+      if (target_big_endian)
+      	frag_align_pattern (n, be_nop, 2, max);      
+      else
+      	frag_align_pattern (n, le_nop, 2, max);      
+      return 1;
+    }
+
+  return 0;
+}
+
+static void
+md_obj_begin ()
+{
+}
+
+static void
+md_obj_end ()
+{
+  /* check for premature end, nesting errors, etc */
+  if (cur_proc_ptr)
+    as_warn (_("missing `.end' at end of assembly"));
+}
+
+static long
+get_number ()
+{
+  int negative = 0;
+  long val = 0;
+
+  if (*input_line_pointer == '-')
+    {
+      ++input_line_pointer;
+      negative = 1;
+    }
+  if (!isdigit ((unsigned char) *input_line_pointer))
+    as_bad (_("Expected simple number."));
+  if (input_line_pointer[0] == '0')
+    {
+      if (input_line_pointer[1] == 'x')
+	{
+	  input_line_pointer += 2;
+	  while (isxdigit ((unsigned char) *input_line_pointer))
+	    {
+	      val <<= 4;
+	      val |= hex_value (*input_line_pointer++);
+	    }
+	  return negative ? -val : val;
+	}
+      else
+	{
+	  ++input_line_pointer;
+	  while (isdigit ((unsigned char) *input_line_pointer))
+	    {
+	      val <<= 3;
+	      val |= *input_line_pointer++ - '0';
+	    }
+	  return negative ? -val : val;
+	}
+    }
+  if (!isdigit ((unsigned char) *input_line_pointer))
+    {
+      printf (_(" *input_line_pointer == '%c' 0x%02x\n"),
+	      *input_line_pointer, *input_line_pointer);
+      as_warn (_("Invalid number"));
+      return -1;
+    }
+  while (isdigit ((unsigned char) *input_line_pointer))
+    {
+      val *= 10;
+      val += *input_line_pointer++ - '0';
+    }
+  return negative ? -val : val;
+}
+
+/* The .file directive; just like the usual .file directive, but there
+   is an initial number which is the ECOFF file index.  */
+
+static void
+s_file (x)
+     int x;
+{
+  int line;
+
+  line = get_number ();
+  s_app_file (0);
+}
+
+
+/* The .end directive.  */
+
+static void
+s_mips_end (x)
+     int x;
+{
+  symbolS *p;
+  int maybe_text;
+
+  if (!is_end_of_line[(unsigned char) *input_line_pointer])
+    {
+      p = get_symbol ();
+      demand_empty_rest_of_line ();
+    }
+  else
+    p = NULL;
+
+#ifdef BFD_ASSEMBLER
+  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
+    maybe_text = 1;
+  else
+    maybe_text = 0;
+#else
+  if (now_seg != data_section && now_seg != bss_section)
+    maybe_text = 1;
+  else
+    maybe_text = 0;
+#endif
+
+  if (!maybe_text)
+    as_warn (_(".end not in text section"));
+
+  if (!cur_proc_ptr)
+    {
+      as_warn (_(".end directive without a preceding .ent directive."));
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  if (p != NULL)
+    {
+      assert (S_GET_NAME (p));
+      if (strcmp (S_GET_NAME (p), S_GET_NAME (cur_proc_ptr->isym)))
+	as_warn (_(".end symbol does not match .ent symbol."));
+    }
+  else
+    as_warn (_(".end directive missing or unknown symbol"));
+
+#ifdef MIPS_STABS_ELF
+  {
+    segT saved_seg = now_seg;
+    subsegT saved_subseg = now_subseg;
+    fragS *saved_frag = frag_now;
+    valueT dot;
+    segT seg;
+    expressionS exp;
+    char *fragp;
+
+    dot = frag_now_fix ();
+
+#ifdef md_flush_pending_output
+    md_flush_pending_output ();
+#endif
+
+    assert (pdr_seg);
+    subseg_set (pdr_seg, 0);
+
+    /* Write the symbol */
+    exp.X_op = O_symbol;
+    exp.X_add_symbol = p;
+    exp.X_add_number = 0;
+    emit_expr (&exp, 4);
+
+    fragp = frag_more (7*4);
+
+    md_number_to_chars (fragp,     (valueT) cur_proc_ptr->reg_mask, 4);
+    md_number_to_chars (fragp + 4, (valueT) cur_proc_ptr->reg_offset, 4);
+    md_number_to_chars (fragp + 8, (valueT) cur_proc_ptr->fpreg_mask, 4);
+    md_number_to_chars (fragp +12, (valueT) cur_proc_ptr->fpreg_offset, 4);
+    md_number_to_chars (fragp +16, (valueT) cur_proc_ptr->frame_offset, 4);
+    md_number_to_chars (fragp +20, (valueT) cur_proc_ptr->frame_reg, 4);
+    md_number_to_chars (fragp +24, (valueT) cur_proc_ptr->pc_reg, 4);
+
+    subseg_set (saved_seg, saved_subseg);
+  }
+#endif
+
+  cur_proc_ptr = NULL;
+}
+
+/* The .aent and .ent directives.  */
+
+static void
+s_mips_ent (aent)
+     int aent;
+{
+  int number = 0;
+  symbolS *symbolP;
+  int maybe_text;
+
+  symbolP = get_symbol ();
+  if (*input_line_pointer == ',')
+    input_line_pointer++;
+  SKIP_WHITESPACE ();
+  if (isdigit ((unsigned char) *input_line_pointer)
+      || *input_line_pointer == '-')
+    number = get_number ();
+
+#ifdef BFD_ASSEMBLER
+  if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
+    maybe_text = 1;
+  else
+    maybe_text = 0;
+#else
+  if (now_seg != data_section && now_seg != bss_section)
+    maybe_text = 1;
+  else
+    maybe_text = 0;
+#endif
+
+  if (!maybe_text)
+    as_warn (_(".ent or .aent not in text section."));
+
+  if (!aent && cur_proc_ptr)
+    as_warn (_("missing `.end'"));
+
+  if (!aent)
+    {
+      cur_proc_ptr = &cur_proc;
+      memset (cur_proc_ptr, '\0', sizeof (procS));
+
+      cur_proc_ptr->isym = symbolP;
+
+      symbol_get_bfdsym (symbolP)->flags |= BSF_FUNCTION;
+
+      numprocs++;
+    }
+
+  demand_empty_rest_of_line ();
+}
+
+/* The .frame directive. If the mdebug section is present (IRIX 5 native)
+   then ecoff.c (ecoff_directive_frame) is used. For embedded targets, 
+   s_mips_frame is used so that we can set the PDR information correctly.
+   We can't use the ecoff routines because they make reference to the ecoff 
+   symbol table (in the mdebug section).  */
+
+static void
+s_mips_frame (ignore)
+     int ignore;
+{
+#ifdef MIPS_STABS_ELF
+
+  long val;
+
+  if (cur_proc_ptr ==  (procS *) NULL)
+    {
+      as_warn (_(".frame outside of .ent"));
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  cur_proc_ptr->frame_reg = tc_get_register (1);
+
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer++ != ','
+      || get_absolute_expression_and_terminator (&val) != ',')
+    {
+      as_warn (_("Bad .frame directive"));
+      --input_line_pointer;
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  cur_proc_ptr->frame_offset = val;
+  cur_proc_ptr->pc_reg = tc_get_register (0);
+
+  demand_empty_rest_of_line ();
+#else
+  s_ignore (ignore);
+#endif /* MIPS_STABS_ELF */
+}
+
+/* The .fmask and .mask directives. If the mdebug section is present 
+   (IRIX 5 native) then ecoff.c (ecoff_directive_mask) is used. For 
+   embedded targets, s_mips_mask is used so that we can set the PDR
+   information correctly. We can't use the ecoff routines because they 
+   make reference to the ecoff symbol table (in the mdebug section).  */
+
+static void
+s_mips_mask (reg_type)
+     char reg_type;
+{
+#ifdef MIPS_STABS_ELF
+  long mask, off;
+  
+  if (cur_proc_ptr == (procS *) NULL)
+    {
+      as_warn (_(".mask/.fmask outside of .ent"));
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  if (get_absolute_expression_and_terminator (&mask) != ',')
+    {
+      as_warn (_("Bad .mask/.fmask directive"));
+      --input_line_pointer;
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  off = get_absolute_expression ();
+
+  if (reg_type == 'F')
+    {
+      cur_proc_ptr->fpreg_mask = mask;
+      cur_proc_ptr->fpreg_offset = off;
+    }
+  else
+    {
+      cur_proc_ptr->reg_mask = mask;
+      cur_proc_ptr->reg_offset = off;
+    }
+
+  demand_empty_rest_of_line ();
+#else
+  s_ignore (reg_type);
+#endif /* MIPS_STABS_ELF */
+}
+
+/* The .loc directive.  */
+
+#if 0
+static void
+s_loc (x)
+     int x;
+{
+  symbolS *symbolP;
+  int lineno;
+  int addroff;
+
+  assert (now_seg == text_section);
+
+  lineno = get_number ();
+  addroff = frag_now_fix ();
+
+  symbolP = symbol_new ("", N_SLINE, addroff, frag_now);
+  S_SET_TYPE (symbolP, N_SLINE);
+  S_SET_OTHER (symbolP, 0);
+  S_SET_DESC (symbolP, lineno);
+  symbolP->sy_segment = now_seg;
+}
+#endif
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/tc-ppc.c binutils/gas/config/tc-ppc.c
--- binutils-2.10.1/gas/config/tc-ppc.c	2000-04-02 16:27:51.000000000 +1000
+++ binutils/gas/config/tc-ppc.c	2001-02-27 05:19:39.000000000 +1000
@@ -441,6 +441,74 @@
 
   { "xer", 1 },
 
+  { "v.0", 0 },     /* Vector registers */
+  { "v.1", 1 }, 
+  { "v.10", 10 }, 
+  { "v.11", 11 }, 
+  { "v.12", 12 }, 
+  { "v.13", 13 }, 
+  { "v.14", 14 }, 
+  { "v.15", 15 }, 
+  { "v.16", 16 }, 
+  { "v.17", 17 }, 
+  { "v.18", 18 }, 
+  { "v.19", 19 }, 
+  { "v.2", 2 }, 
+  { "v.20", 20 }, 
+  { "v.21", 21 }, 
+  { "v.22", 22 }, 
+  { "v.23", 23 }, 
+  { "v.24", 24 }, 
+  { "v.25", 25 }, 
+  { "v.26", 26 }, 
+  { "v.27", 27 }, 
+  { "v.28", 28 }, 
+  { "v.29", 29 }, 
+  { "v.3", 3 }, 
+  { "v.30", 30 },
+  { "v.31", 31 },
+  { "v.4", 4 }, 
+  { "v.5", 5 }, 
+  { "v.6", 6 }, 
+  { "v.7", 7 }, 
+  { "v.8", 8 }, 
+  { "v.9", 9 }, 
+
+  { "v0", 0 }, 
+  { "v1", 1 }, 
+  { "v10", 10 }, 
+  { "v11", 11 }, 
+  { "v12", 12 }, 
+  { "v13", 13 }, 
+  { "v14", 14 }, 
+  { "v15", 15 }, 
+  { "v16", 16 }, 
+  { "v17", 17 }, 
+  { "v18", 18 }, 
+  { "v19", 19 }, 
+  { "v2", 2 }, 
+  { "v20", 20 }, 
+  { "v21", 21 }, 
+  { "v22", 22 }, 
+  { "v23", 23 }, 
+  { "v24", 24 }, 
+  { "v25", 25 }, 
+  { "v26", 26 }, 
+  { "v27", 27 }, 
+  { "v28", 28 }, 
+  { "v29", 29 }, 
+  { "v3", 3 }, 
+  { "v30", 30 },
+  { "v31", 31 },
+  { "v4", 4 }, 
+  { "v5", 5 }, 
+  { "v6", 6 }, 
+  { "v7", 7 }, 
+  { "v8", 8 }, 
+  { "v9", 9 }, 
+
+  { "vrsave", 256 },
+
 };
 
 #define REG_NAME_CNT	(sizeof(pre_defined_registers) / sizeof(struct pd_reg))
@@ -751,7 +819,7 @@
       /* -m601 means to assemble for the Motorola PowerPC 601, which includes
          instructions that are holdovers from the Power. */
       else if (strcmp (arg, "601") == 0)
-	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_601;
+	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_601 | (ppc_cpu & PPC_OPCODE_VEC);
       /* -mppc, -mppc32, -m603, and -m604 mean to assemble for the
          Motorola PowerPC 603/604.  */
       else if (strcmp (arg, "ppc") == 0
@@ -759,7 +827,7 @@
 	       || strcmp (arg, "403") == 0
 	       || strcmp (arg, "603") == 0
 	       || strcmp (arg, "604") == 0)
-	ppc_cpu = PPC_OPCODE_PPC;
+	ppc_cpu = PPC_OPCODE_PPC | (ppc_cpu & PPC_OPCODE_VEC);
       /* -mppc64 and -m620 mean to assemble for the 64-bit PowerPC
          620.  */
       else if (strcmp (arg, "ppc64") == 0 || strcmp (arg, "620") == 0)
@@ -776,10 +844,12 @@
 	 and PowerPC.  At present, we just allow the union, rather
 	 than the intersection.  */
       else if (strcmp (arg, "com") == 0)
-	ppc_cpu = PPC_OPCODE_COMMON;
+	ppc_cpu = PPC_OPCODE_COMMON | (ppc_cpu & PPC_OPCODE_VEC);
       /* -many means to assemble for any architecture (PWR/PWRX/PPC).  */
       else if (strcmp (arg, "any") == 0)
-	ppc_cpu = PPC_OPCODE_ANY;
+	ppc_cpu = PPC_OPCODE_ANY | (ppc_cpu & PPC_OPCODE_VEC);
+      else if (strcmp (arg, "vec") == 0)
+	ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_VEC;
 
       else if (strcmp (arg, "regnames") == 0)
 	reg_names_p = true;
@@ -879,6 +949,7 @@
 			generate code for Motorola PowerPC 603/604\n\
 -mppc64, -m620		generate code for Motorola PowerPC 620\n\
 -mppc64bridge		generate code for PowerPC 64, including bridge insns\n\
+-mvec			generate code for AltiVec instructions\n\
 -mcom			generate code Power/PowerPC common instructions\n\
 -many			generate code for any architecture (PWR/PWRX/PPC)\n\
 -mregnames		Allow symbolic names for registers\n\
@@ -2300,6 +2371,18 @@
       lcomm_sym = symbol_find_or_make (lcomm_name);
 
       *input_line_pointer = lcomm_endc;
+
+      /* An optional fourth argument to .lcomm is the alignment.  */
+      if (*input_line_pointer == ',')
+	{
+	  offsetT nalign;
+	  ++input_line_pointer;
+	  nalign = get_absolute_expression ();
+	  if (nalign <= 0)
+	    as_warn ("ignoring bad alignment");
+	  else
+	    align = nalign;
+	}
     }
 
   *end_name = '\0';
@@ -3272,7 +3355,7 @@
       cons (4);
     }
 }
-
+
 #ifdef TE_PE
 
 /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format */
@@ -5024,3 +5107,29 @@
 
   return reloc;
 }
+
+/* When we align the .text section, insert the correct NOP pattern.  */
+
+int
+ppc_do_align (n, fill, len, max)
+     int n;
+     const char *fill;
+     int len;
+     int max;
+{
+  if (fill == NULL
+#ifdef BFD_ASSEMBLER
+      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0
+#else
+      && now_seg != data_section
+      && now_seg != bss_section
+#endif
+      && n > 1)
+    {
+      static const unsigned char nop_pattern[] = { 0x60, 0, 0, 0 };
+      frag_align_pattern (n, nop_pattern, sizeof(nop_pattern), max);
+      return 1;
+    }
+
+  return 0;
+}
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/tc-ppc.h binutils/gas/config/tc-ppc.h
--- binutils-2.10.1/gas/config/tc-ppc.h	2000-02-01 05:13:47.000000000 +1000
+++ binutils/gas/config/tc-ppc.h	2001-02-27 05:19:39.000000000 +1000
@@ -185,8 +185,16 @@
 #define tc_adjust_symtab() ppc_adjust_symtab ()
 extern void ppc_adjust_symtab PARAMS ((void));
 
-/* Niclas Andersson <nican@ida.liu.se> says this is needed.  */
-#define SUB_SEGMENT_ALIGN(SEG) 2
+/* Niclas Andersson <nican@ida.liu.se> says this needs to be 2.
+   Tom Wood <twood@ncct.sps.mot.com> says: Xcoff requires sections to
+   begin at their largest alignment.  This doesn't seem to be the
+   right place to fix this, but it seems to work.  To see the failure,
+   you have to have an item (say in .data) that is aligned to more
+   than 8-bytes.  Play with the size of the preceeding sections to
+   see if the item is placed at a mis-aligned location.  */
+#define SUB_SEGMENT_ALIGN(SEG) \
+  ((SEG) && (SEG)->next && (SEG)->next->alignment_power > 2 \
+   ? (SEG)->next->alignment_power : 2)
 
 /* We also need to copy, in particular, the class of the symbol,
    over what obj-coff would otherwise have copied.  */
@@ -275,6 +283,11 @@
 
 #endif /* OBJ_ELF */
 
+/* We use a special alignment function to insert the correct nop
+   pattern.  */
+extern int ppc_do_align PARAMS ((int, const char *, int, int));
+#define md_do_align(n,fill,len,max,l) if (ppc_do_align (n,fill,len,max)) goto l
+
 /* call md_apply_fix3 with segment instead of md_apply_fix */
 #define MD_APPLY_FIX3
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/tc-sh.c binutils/gas/config/tc-sh.c
--- binutils-2.10.1/gas/config/tc-sh.c	2000-03-28 02:17:08.000000000 +1000
+++ binutils/gas/config/tc-sh.c	2001-02-27 05:19:39.000000000 +1000
@@ -50,6 +50,8 @@
 static sh_opcode_info *find_cooked_opcode PARAMS ((char **));
 static void assemble_ppi PARAMS ((char *, sh_opcode_info *));
 
+symbolS *GOT_symbol;		/* Pre-defined "_GLOBAL_OFFSET_TABLE_" */
+
 int shl = 0;
 
 static void
@@ -67,10 +69,14 @@
    Integer arg to pass to the function
  */
 
+static void sh_elf_cons PARAMS ((int));
+
 const pseudo_typeS md_pseudo_table[] =
 {
-  {"int", cons, 4},
-  {"word", cons, 2},
+  {"long", sh_elf_cons, 4},
+  {"int", sh_elf_cons, 4},
+  {"word", sh_elf_cons, 2},
+  {"short", sh_elf_cons, 2 },
   {"form", listing_psize, 0},
   {"little", little, 0},
   {"heading", listing_title, 0},
@@ -99,6 +105,10 @@
    accomodate the insns seen so far.  */
 static int valid_arch;
 
+/* Whether -pic  */
+
+int sh_pic;
+
 const char EXP_CHARS[] = "eE";
 
 /* Chars that mean this number is a floating point constant */
@@ -194,6 +204,171 @@
 
 static struct hash_control *opcode_hash_control;	/* Opcode mnemonics */
 
+
+/* Parse @got, etc. and return the desired relocation. 
+   If we have additional arithmetic expression, then we fill in new_exp_p.  */
+static bfd_reloc_code_real_type
+sh_elf_suffix (str_p, exp_p, new_exp_p)
+     char **str_p;
+     expressionS *exp_p, *new_exp_p;
+{
+  struct map_bfd {
+    char *string;
+    int length;
+    bfd_reloc_code_real_type reloc;
+  };
+
+  char ident[20];
+  char *str = *str_p;
+  char *str2;
+  int ch;
+  int len;
+  struct map_bfd *ptr;
+
+#define MAP(str,reloc) { str, sizeof(str)-1, reloc }
+
+  static struct map_bfd mapping[] = {
+    MAP ("got",		BFD_RELOC_SH_GOT32),
+    MAP ("plt",		BFD_RELOC_SH_PLT32),
+    MAP ("gotoff",	BFD_RELOC_SH_GOTOFF),
+    { (char *)0,	0,	BFD_RELOC_UNUSED }
+  };
+
+  if (*str++ != '@')
+    return BFD_RELOC_UNUSED;
+
+  for (ch = *str, str2 = ident;
+       (str2 < ident + sizeof (ident) - 1
+	&& (isalnum (ch) || ch == '@'));
+       ch = *++str)
+    {
+      *str2++ = (islower (ch)) ? ch : tolower (ch);
+    }
+
+  *str2 = '\0';
+  len = str2 - ident;
+
+  ch = ident[0];
+  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
+    if (ch == ptr->string[0]
+	&& len == ptr->length
+	&& memcmp (ident, ptr->string, ptr->length) == 0)
+      {
+	/* Now check for identifier@suffix+constant */
+	if (*str == '-' || *str == '+')
+	  {
+	    char *orig_line = input_line_pointer;
+
+	    input_line_pointer = str;
+	    expression (new_exp_p);
+	    if (new_exp_p->X_op == O_constant)
+	      {
+		exp_p->X_add_number += new_exp_p->X_add_number;
+		str = input_line_pointer;
+	      }
+	    if (new_exp_p->X_op == O_subtract)
+	      str = input_line_pointer;
+
+	    if (&input_line_pointer != str_p)
+	      input_line_pointer = orig_line;
+	  }
+
+	*str_p = str;
+	return ptr->reloc;
+      }
+
+  return BFD_RELOC_UNUSED;
+}
+
+/* Like normal .long/.short/.word, except support @got, etc. */
+/* clobbers input_line_pointer, checks */
+/* end-of-line. */
+static void
+sh_elf_cons (nbytes)
+     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
+{
+  expressionS exp, new_exp;
+  bfd_reloc_code_real_type reloc;
+  const char *name;
+
+  if (is_it_end_of_statement ())
+    {
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  do
+    {
+      expression (&exp);
+      new_exp.X_op = O_absent;
+      new_exp.X_add_symbol = new_exp.X_op_symbol = NULL;
+      if (! GOT_symbol && exp.X_add_symbol)
+	name = S_GET_NAME (exp.X_add_symbol);
+      else
+	name = NULL;
+      if (((GOT_symbol && (GOT_symbol == exp.X_add_symbol))
+	   || (! GOT_symbol && name && name[0] == '_' && name[1] == 'G'
+	       && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0))
+	  && (exp.X_op == O_symbol
+	      || (exp.X_op == O_add
+		  && ((symbol_get_value_expression (exp.X_op_symbol)->X_op)
+		      == O_subtract))))
+	{
+	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, BFD_RELOC_32);
+	  int size = bfd_get_reloc_size (reloc_howto);
+
+	  if (GOT_symbol == NULL)
+	    GOT_symbol = symbol_find_or_make ("_GLOBAL_OFFSET_TABLE_");
+
+	  if (size > nbytes)
+	    as_bad (_("%s relocations do not fit in %d bytes\n"), reloc_howto->name, nbytes);
+	  else
+	    {
+	      register char *p = frag_more ((int) nbytes);
+	      int offset = nbytes - size;
+
+	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
+			   size, &exp, 0, TC_RELOC_GLOBAL_OFFSET_TABLE);
+	    }
+	}
+      else if ((exp.X_op == O_symbol || (exp.X_op == O_add && exp.X_op_symbol))
+	  && *input_line_pointer == '@'
+	  && (reloc = sh_elf_suffix (&input_line_pointer, &exp, &new_exp)) != BFD_RELOC_UNUSED)
+	{
+	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
+	  int size = bfd_get_reloc_size (reloc_howto);
+
+	  if (GOT_symbol == NULL)
+	    GOT_symbol = symbol_find_or_make ("_GLOBAL_OFFSET_TABLE_");
+
+	  if (size > nbytes)
+	    as_bad (_("%s relocations do not fit in %d bytes\n"), reloc_howto->name, nbytes);
+
+	  else
+	    {
+	      register char *p = frag_more ((int) nbytes);
+	      int offset = nbytes - size;
+
+	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size, &exp, 0, reloc);
+	      if(new_exp.X_op != O_absent) 
+		fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size, &new_exp, 0, BFD_RELOC_32);
+	    }
+	}
+      else
+	emit_expr (&exp, (unsigned int) nbytes);
+    }
+  while (*input_line_pointer++ == ',');
+
+  input_line_pointer--;		/* Put terminator back into stream. */
+  if (*input_line_pointer == '#' || *input_line_pointer == '!')
+    {
+       while (! is_end_of_line[*input_line_pointer++]);
+    }
+  else
+    demand_empty_rest_of_line ();
+}
+
+
 /*
    This function is called once, at assembler startup time.  This should
    set up all the tables, etc that the MD part of the assembler needs
@@ -266,6 +441,15 @@
   /* We use ! IDENT_CHAR for the next character after the register name, to
      make sure that we won't accidentally recognize a symbol name such as
      'sram' or sr_ram as being a reference to the register 'sr'.  */
+  int prefix;
+
+  if (src[0] == '$')
+    {
+      src++;
+      prefix = 1;
+    }
+  else
+    prefix = 0;
 
   if (src[0] == 'r')
     {
@@ -276,7 +460,7 @@
 	    {
 	      *mode = A_REG_N;
 	      *reg = 10 + src[2] - '0';
-	      return 3;
+	      return prefix + 3;
 	    }
 	}
       if (src[1] >= '0' && src[1] <= '9'
@@ -284,25 +468,25 @@
 	{
 	  *mode = A_REG_N;
 	  *reg = (src[1] - '0');
-	  return 2;
+	  return prefix + 2;
 	}
       if (src[1] >= '0' && src[1] <= '7' && strncmp (&src[2], "_bank", 5) == 0
 	  && ! IDENT_CHAR ((unsigned char) src[7]))
 	{
 	  *mode = A_REG_B;
 	  *reg  = (src[1] - '0');
-	  return 7;
+	  return prefix + 7;
 	}
 
       if (src[1] == 'e' && ! IDENT_CHAR ((unsigned char) src[2]))
 	{
 	  *mode = A_RE;
-	  return 2;
+	  return prefix + 2;
 	}
       if (src[1] == 's' && ! IDENT_CHAR ((unsigned char) src[2]))
 	{
 	  *mode = A_RS;
-	  return 2;
+	  return prefix + 2;
 	}
     }
 
@@ -314,13 +498,13 @@
 	    {
 	      *mode = DSP_REG_N;
 	      *reg = A_A0_NUM;
-	      return 2;
+	      return prefix + 2;
 	    }
 	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
 	    {
 	      *mode = DSP_REG_N;
 	      *reg = A_A0G_NUM;
-	      return 3;
+	      return prefix + 3;
 	    }
 	}
       if (src[1] == '1')
@@ -329,13 +513,13 @@
 	    {
 	      *mode = DSP_REG_N;
 	      *reg = A_A1_NUM;
-	      return 2;
+	      return prefix + 2;
 	    }
 	  if (src[2] == 'g' && ! IDENT_CHAR ((unsigned char) src[3]))
 	    {
 	      *mode = DSP_REG_N;
 	      *reg = A_A1G_NUM;
-	      return 3;
+	      return prefix + 3;
 	    }
 	}
 
@@ -344,14 +528,14 @@
 	{
 	  *mode = A_REG_N;
 	  *reg = 4 + (src[1] - '0');
-	  return 3;
+	  return prefix + 3;
 	}
       if (src[1] == 'y' && src[2] >= '0' && src[2] <= '1'
 	  && ! IDENT_CHAR ((unsigned char) src[3]))
 	{
 	  *mode = A_REG_N;
 	  *reg = 6 + (src[1] - '0');
-	  return 3;
+	  return prefix + 3;
 	}
       if (src[1] == 's' && src[2] >= '0' && src[2] <= '3'
 	  && ! IDENT_CHAR ((unsigned char) src[3]))
@@ -360,7 +544,7 @@
 
 	  *mode = A_REG_N;
 	  *reg = n | ((~n & 2) << 1);
-	  return 3;
+	  return prefix + 3;
 	}
     }
 
@@ -370,19 +554,19 @@
 	{
 	  *mode = A_REG_N;
 	  *reg = 8;
-	  return 2;
+	  return prefix + 2;
 	}
       if (src[1] == 'x')
 	{
 	  *mode = A_REG_N;
 	  *reg = 8;
-	  return 2;
+	  return prefix + 2;
 	}
       if (src[1] == 'y')
 	{
 	  *mode = A_REG_N;
 	  *reg = 9;
-	  return 2;
+	  return prefix + 2;
 	}
     }
 
@@ -391,7 +575,7 @@
     {
       *mode = DSP_REG_N;
       *reg = A_X0_NUM + src[1] - '0';
-      return 2;
+      return prefix + 2;
     }
 
   if (src[0] == 'y' && src[1] >= '0' && src[1] <= '1'
@@ -399,7 +583,7 @@
     {
       *mode = DSP_REG_N;
       *reg = A_Y0_NUM + src[1] - '0';
-      return 2;
+      return prefix + 2;
     }
 
   if (src[0] == 'm' && src[1] >= '0' && src[1] <= '1'
@@ -407,7 +591,7 @@
     {
       *mode = DSP_REG_N;
       *reg = src[1] == '0' ? A_M0_NUM : A_M1_NUM;
-      return 2;
+      return prefix + 2;
     }
 
   if (src[0] == 's'
@@ -415,71 +599,71 @@
       && src[2] == 'r' && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_SSR;
-      return 3;
+      return prefix + 3;
     }
 
   if (src[0] == 's' && src[1] == 'p' && src[2] == 'c'
       && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_SPC;
-      return 3;
+      return prefix + 3;
     }
 
   if (src[0] == 's' && src[1] == 'g' && src[2] == 'r'
       && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_SGR;
-      return 3;
+      return prefix + 3;
     }
 
   if (src[0] == 'd' && src[1] == 's' && src[2] == 'r'
       && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_DSR;
-      return 3;
+      return prefix + 3;
     }
 
   if (src[0] == 'd' && src[1] == 'b' && src[2] == 'r'
       && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_DBR;
-      return 3;
+      return prefix + 3;
     }
 
   if (src[0] == 's' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
     {
       *mode = A_SR;
-      return 2;
+      return prefix + 2;
     }
 
   if (src[0] == 's' && src[1] == 'p' && ! IDENT_CHAR ((unsigned char) src[2]))
     {
       *mode = A_REG_N;
       *reg = 15;
-      return 2;
+      return prefix + 2;
     }
 
   if (src[0] == 'p' && src[1] == 'r' && ! IDENT_CHAR ((unsigned char) src[2]))
     {
       *mode = A_PR;
-      return 2;
+      return prefix + 2;
     }
   if (src[0] == 'p' && src[1] == 'c' && ! IDENT_CHAR ((unsigned char) src[2]))
     {
       *mode = A_DISP_PC;
-      return 2;
+      return prefix + 2;
     }
   if (src[0] == 'g' && src[1] == 'b' && src[2] == 'r'
       && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_GBR;
-      return 3;
+      return prefix + 3;
     }
   if (src[0] == 'v' && src[1] == 'b' && src[2] == 'r'
       && ! IDENT_CHAR ((unsigned char) src[3]))
     {
       *mode = A_VBR;
-      return 3;
+      return prefix + 3;
     }
 
   if (src[0] == 'm' && src[1] == 'a' && src[2] == 'c'
@@ -488,19 +672,19 @@
       if (src[3] == 'l')
 	{
 	  *mode = A_MACL;
-	  return 4;
+	  return prefix + 4;
 	}
       if (src[3] == 'h')
 	{
 	  *mode = A_MACH;
-	  return 4;
+	  return prefix + 4;
 	}
     }
   if (src[0] == 'm' && src[1] == 'o' && src[2] == 'd'
       && ! IDENT_CHAR ((unsigned char) src[4]))
     {
       *mode = A_MOD;
-      return 3;
+      return prefix + 3;
     }
   if (src[0] == 'f' && src[1] == 'r')
     {
@@ -511,7 +695,7 @@
 	    {
 	      *mode = F_REG_N;
 	      *reg = 10 + src[3] - '0';
-	      return 4;
+	      return prefix + 4;
 	    }
 	}
       if (src[2] >= '0' && src[2] <= '9'
@@ -519,7 +703,7 @@
 	{
 	  *mode = F_REG_N;
 	  *reg = (src[2] - '0');
-	  return 3;
+	  return prefix + 3;
 	}
     }
   if (src[0] == 'd' && src[1] == 'r')
@@ -531,7 +715,7 @@
 	    {
 	      *mode = D_REG_N;
 	      *reg = 10 + src[3] - '0';
-	      return 4;
+	      return prefix + 4;
 	    }
 	}
       if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
@@ -539,7 +723,7 @@
 	{
 	  *mode = D_REG_N;
 	  *reg = (src[2] - '0');
-	  return 3;
+	  return prefix + 3;
 	}
     }
   if (src[0] == 'x' && src[1] == 'd')
@@ -551,7 +735,7 @@
 	    {
 	      *mode = X_REG_N;
 	      *reg = 11 + src[3] - '0';
-	      return 4;
+	      return prefix + 4;
 	    }
 	}
       if (src[2] >= '0' && src[2] <= '8' && ! ((src[2] - '0') & 1)
@@ -559,7 +743,7 @@
 	{
 	  *mode = X_REG_N;
 	  *reg = (src[2] - '0') + 1;
-	  return 3;
+	  return prefix + 3;
 	}
     }
   if (src[0] == 'f' && src[1] == 'v')
@@ -568,35 +752,35 @@
 	{
 	  *mode = V_REG_N;
 	  *reg = 12;
-	  return 4;
+	  return prefix + 4;
 	}
       if ((src[2] == '0' || src[2] == '4' || src[2] == '8')
 	  && ! IDENT_CHAR ((unsigned char) src[3]))
 	{
 	  *mode = V_REG_N;
 	  *reg = (src[2] - '0');
-	  return 3;
+	  return prefix + 3;
 	}
     }
   if (src[0] == 'f' && src[1] == 'p' && src[2] == 'u' && src[3] == 'l'
       && ! IDENT_CHAR ((unsigned char) src[4]))
     {
       *mode = FPUL_N;
-      return 4;
+      return prefix + 4;
     }
 
   if (src[0] == 'f' && src[1] == 'p' && src[2] == 's' && src[3] == 'c'
       && src[4] == 'r' && ! IDENT_CHAR ((unsigned char) src[5]))
     {
       *mode = FPSCR_N;
-      return 5;
+      return prefix + 5;
     }
 
   if (src[0] == 'x' && src[1] == 'm' && src[2] == 't' && src[3] == 'r'
       && src[4] == 'x' && ! IDENT_CHAR ((unsigned char) src[5]))
     {
       *mode = XMTRX_M4;
-      return 5;
+      return prefix + 5;
     }
 
   return 0;
@@ -1633,7 +1817,11 @@
 	  return;
 	}
 
-      if (*op_end)
+      if (*op_end == '#' || *op_end == '!')
+        {
+           while (! is_end_of_line[*op_end++]);
+        }
+      else if (*op_end)
 	as_bad (_("excess operands: '%s'"), op_end);
 
       build_Mytes (opcode, operand);
@@ -1681,10 +1869,29 @@
     }
 }
 
+/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.  Otherwise 
+   we have no need to default values of symbols.  */
+
 symbolS *
 DEFUN (md_undefined_symbol, (name),
        char *name)
 {
+#ifdef OBJ_ELF
+  if (name[0] == '_' && name[1] == 'G'
+      && strcmp (name, GLOBAL_OFFSET_TABLE_NAME) == 0)
+    {
+      if (!GOT_symbol)
+	{
+	  if (symbol_find (name))
+	    as_bad ("GOT already in the symbol table");
+	  
+	  GOT_symbol = symbol_new (name, undefined_section,
+				   (valueT)0, & zero_address_frag);
+	}
+      
+      return GOT_symbol;
+    }
+#endif
   return 0;
 }
 
@@ -1803,11 +2010,13 @@
 #define OPTION_LITTLE (OPTION_MD_BASE + 1)
 #define OPTION_SMALL (OPTION_LITTLE + 1)
 #define OPTION_DSP (OPTION_SMALL + 1)
+#define OPTION_PIC (OPTION_DSP + 1)
 
   {"relax", no_argument, NULL, OPTION_RELAX},
   {"little", no_argument, NULL, OPTION_LITTLE},
   {"small", no_argument, NULL, OPTION_SMALL},
   {"dsp", no_argument, NULL, OPTION_DSP},
+  {"pic", no_argument, NULL, OPTION_PIC},
   {NULL, no_argument, NULL, 0}
 };
 size_t md_longopts_size = sizeof(md_longopts);
@@ -1836,6 +2045,10 @@
       sh_dsp = 1;
       break;
 
+    case OPTION_PIC:
+      sh_pic = 1;
+      break;
+
     default:
       return 0;
     }
@@ -1852,7 +2065,8 @@
 -little			generate little endian code\n\
 -relax			alter jump instructions for long displacements\n\
 -small			align sections to 4 byte boundaries, not 16\n\
--dsp			enable sh-dsp insns, and disable sh3e / sh4 insns.\n"));
+-dsp			enable sh-dsp insns, and disable sh3e / sh4 insns.\n\
+-pic			generate position-independent code\n"));
 }
 
 void
@@ -2431,8 +2645,23 @@
   if (fixP->fx_addsy == NULL)
     return 1;
   
-  /* We need the symbol name for the VTABLE entries */
-  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+  /* Prevent all adjustments to global symbols, or else dynamic
+     linking will not work correctly.  */
+  if (sh_pic)
+    {
+      if (S_IS_EXTERN (fixP->fx_addsy))
+	return 0;
+      if (S_IS_WEAK (fixP->fx_addsy))
+	return 0;
+    }
+
+  /* adjust_reloc_syms doesn't know about the GOT */
+  if (fixP->fx_r_type == BFD_RELOC_SH_GOTOFF
+      || fixP->fx_r_type == BFD_RELOC_SH_PLT32
+      || fixP->fx_r_type == BFD_RELOC_SH_GOT32
+      || fixP->fx_r_type == BFD_RELOC_SH_GOTPC
+      || fixP->fx_r_type == BFD_RELOC_RVA
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
     return 0;
 
@@ -2652,6 +2881,55 @@
       return;
 #endif
 
+    case BFD_RELOC_SH_PLT32:
+      /* Make the jump instruction point to the address of the operand.  At
+	 runtime we merely add the offset to the actual PLT entry. */
+      *valp = 0xfffffffc;
+      break;
+
+    case BFD_RELOC_SH_GOTPC:
+/*
+ *   This is tough to explain.  We end up with this one if we have
+ * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal
+ * here is to obtain the absolute address of the GOT, and it is strongly
+ * preferable from a performance point of view to avoid using a runtime
+ * relocation for this.
+ * There are cases where you have something like:
+ *
+ *	.long	_GLOBAL_OFFSET_TABLE_+[.-.L66]
+ *
+ * and here no correction would be required.  Internally in the assembler
+ * we treat operands of this form as not being pcrel since the '.' is
+ * explicitly mentioned, and I wonder whether it would simplify matters
+ * to do it this way.  Who knows.  In earlier versions of the PIC patches,
+ * the pcrel_adjust field was used to store the correction, but since the
+ * expression is not pcrel, I felt it would be confusing to do it this way.
+ */
+      *valp -= 1;
+      if (! target_big_endian) 
+	{
+	  *buf++ = val >> 0;
+	  *buf++ = val >> 8;
+	  *buf++ = val >> 16;
+	  *buf++ = val >> 24;
+	}
+      else 
+	{
+	  *buf++ = val >> 24;
+	  *buf++ = val >> 16;
+	  *buf++ = val >> 8;
+	  *buf++ = val >> 0;
+	}
+      break;
+
+    case BFD_RELOC_SH_GOT32:
+      *valp = 0; /* Fully resolved at runtime.  No addend.  */
+      *(unsigned *)buf = 0;
+      break;
+
+    case BFD_RELOC_SH_GOTOFF:
+      break;
+
     default:
       abort ();
     }
@@ -2836,6 +3114,14 @@
   { BFD_RELOC_SH_CODE, R_SH_CODE },
   { BFD_RELOC_SH_DATA, R_SH_DATA },
   { BFD_RELOC_SH_LABEL, R_SH_LABEL },
+  { BFD_RELOC_SH_GOT32, R_SH_GOT32 },
+  { BFD_RELOC_SH_PLT32, R_SH_PLT32 },
+  { BFD_RELOC_SH_COPY, R_SH_COPY },
+  { BFD_RELOC_SH_GLOB_DAT, R_SH_GLOB_DAT },
+  { BFD_RELOC_SH_JMP_SLOT, R_SH_JMP_SLOT },
+  { BFD_RELOC_SH_RELATIVE, R_SH_RELATIVE },
+  { BFD_RELOC_SH_GOTOFF, R_SH_GOTOFF },
+  { BFD_RELOC_SH_GOTPC, R_SH_GOTPC },
   { BFD_RELOC_UNUSED, 0 }
 };
 
@@ -2995,6 +3281,8 @@
     rel->addend = fixp->fx_offset;
   else if (fixp->fx_pcrel)
     rel->addend = fixp->fx_addnumber;
+  else if (r_type == BFD_RELOC_32)
+    rel->addend = fixp->fx_addnumber;
   else
     rel->addend = 0;
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/config/tc-sh.h binutils/gas/config/tc-sh.h
--- binutils-2.10.1/gas/config/tc-sh.h	2000-03-30 08:57:57.000000000 +1000
+++ binutils/gas/config/tc-sh.h	2001-02-27 05:19:39.000000000 +1000
@@ -38,6 +38,9 @@
 /* Whether -small was used.  */
 extern int sh_small;
 
+/* Whether -pic was used.  */
+extern int sh_pic;
+
 /* Don't try to break words.  */
 #define WORKING_DOT_WORD
 
@@ -55,7 +58,7 @@
 extern int sh_force_relocation ();
 
 #ifdef OBJ_ELF
-#define obj_fix_adjustable(fixP) sh_fix_adjustable(fixP)
+#define tc_fix_adjustable(fixP) sh_fix_adjustable(fixP)
 struct fix;
 extern boolean sh_fix_adjustable PARAMS ((struct fix *));
 #endif
@@ -158,6 +161,36 @@
 #define elf_tc_final_processing sh_elf_final_processing
 extern void sh_elf_final_processing PARAMS ((void));
 
+/* This is the relocation type for direct references to GLOBAL_OFFSET_TABLE.
+ * It comes up in complicated expressions such as 
+ * _GLOBAL_OFFSET_TABLE_+[.-.L284], which cannot be expressed normally with
+ * the regular expressions.  The fixup specified here when used at runtime 
+ * implies that we should add the address of the GOT to the specified location,
+ * and as a result we have simplified the expression into something we can use.
+ */
+#define TC_RELOC_GLOBAL_OFFSET_TABLE BFD_RELOC_SH_GOTPC
+
+/* This expression evaluates to false if the relocation is for a local object
+   for which we still want to do the relocation at runtime.  True if we
+   are willing to perform this relocation while building the .o file.
+   This is only used for pcrel relocations, so GOTOFF does not need to be
+   checked here.  I am not sure if some of the others are ever used with
+   pcrel, but it is easier to be safe than sorry. */
+
+#define TC_RELOC_RTSYM_LOC_FIXUP(FIX)				\
+  ((FIX)->fx_r_type != BFD_RELOC_SH_PLT32			\
+   && (FIX)->fx_r_type != BFD_RELOC_SH_GOT32			\
+   && (FIX)->fx_r_type != BFD_RELOC_SH_GOTPC			\
+   && ((FIX)->fx_addsy == NULL					\
+       || (! S_IS_EXTERNAL ((FIX)->fx_addsy)			\
+	   && ! S_IS_WEAK ((FIX)->fx_addsy)			\
+	   && S_IS_DEFINED ((FIX)->fx_addsy)			\
+	   && ! S_IS_COMMON ((FIX)->fx_addsy))))
+
 #endif /* OBJ_ELF */
 
+#ifdef OBJ_ELF
+#define GLOBAL_OFFSET_TABLE_NAME "_GLOBAL_OFFSET_TABLE_"
+#endif
+
 /* end of tc-sh.h */
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/configure binutils/gas/configure
--- binutils-2.10.1/gas/configure	2000-10-16 21:27:25.000000000 +1000
+++ binutils/gas/configure	2001-03-01 02:51:40.000000000 +1000
@@ -1622,6 +1622,7 @@
       strongarm*)	cpu_type=arm endian=little ;;
       thumb*)		cpu_type=arm endian=little ;;
       hppa*)		cpu_type=hppa ;;
+      x86)			cpu_type=i386 ;;
       i[456]86)		cpu_type=i386 ;;
       m680[012346]0)	cpu_type=m68k ;;
       m68008)		cpu_type=m68k ;;
@@ -1686,8 +1687,9 @@
       arm-*-wince)          fmt=coff em=wince-pe bfd_gas=yes;;
       arm-*-pe | thumb-*-pe)            fmt=coff em=pe ;;
       arm-*-riscix*)	                fmt=aout em=riscix ;;
+      arm-*-nto*)  			fmt=elf ;;
 
-      avr-*-*)		    fmt=elf bfd_gas=yes ;;
+      avr-*-*)		    		fmt=elf bfd_gas=yes ;;
 
       d10v-*-*)		    fmt=elf bfd_gas=yes ;;
       d30v-*-*)		    fmt=elf bfd_gas=yes ;;
@@ -1751,6 +1753,8 @@
       i386-*-cygwin*)       fmt=coff em=pe bfd_gas=yes ;;
       i386-*-interix*)	    fmt=coff em=interix bfd_gas=yes ;;
       i386-*-mingw32*)      fmt=coff em=pe bfd_gas=yes ;;
+      x86-*-nto-* | i386-*-qnx* | i386-*-nto*)	    
+      				fmt=elf ;;
       i386-*-*nt*)          fmt=coff em=pe ;;
       i386-*-vxworks*)      fmt=aout ;;
       i960-*-bout)          fmt=bout ;;
@@ -1802,6 +1806,7 @@
       mips-dec-bsd*)        fmt=aout endian=little ;;
       mips-sony-bsd*)       fmt=ecoff ;;
       mips-*-bsd*)          { echo "configure: error: Unknown vendor for mips-bsd configuration." 1>&2; exit 1; } ;;
+      mips-*-nto*)	    fmt=elf ;;
       mips-*-ultrix*)       fmt=ecoff endian=little ;;
       mips-*-osf*)          fmt=ecoff endian=little ;;
       mips-*-ecoff*)        fmt=ecoff ;;
@@ -1828,6 +1833,7 @@
 		            fmt=coff em=pe ;;
       ppc-*-aix*)           fmt=coff ;;
       ppc-*-beos*)          fmt=coff ;;
+      ppc-*-nto*)	    fmt=elf ;;
       ppc-*-*bsd* | ppc-*-elf* | ppc-*-eabi* | ppc-*-sysv4*)
 			    fmt=elf ;;
       ppc-*-linux-gnu*)	    fmt=elf
@@ -1853,7 +1859,9 @@
       ppc-*-netware*)       fmt=elf em=ppcnw ;;
       ppc-*-vxworks*)       fmt=elf ;;
 
+      sh-*-linux-gnu*)	    fmt=elf ;;
       sh-*-elf*)	    fmt=elf ;;
+      sh-*-nto*)            fmt=elf ;;
       sh-*-coff*)           fmt=coff ;;
       sh-*-pe*)             fmt=coff em=pe bfd_gas=yes;;
       sh-*-rtemself*)       fmt=elf ;;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/configure.in binutils/gas/configure.in
--- binutils-2.10.1/gas/configure.in	2000-10-16 21:27:28.000000000 +1000
+++ binutils/gas/configure.in	2001-03-01 02:51:40.000000000 +1000
@@ -164,6 +164,7 @@
       arm-*-wince)          fmt=coff em=wince-pe bfd_gas=yes;;
       arm-*-pe | thumb-*-pe)            fmt=coff em=pe ;;
       arm-*-riscix*)	                fmt=aout em=riscix ;;
+      arm-*-nto*)  			fmt=elf ;;
 
       avr-*-*)		    fmt=elf bfd_gas=yes ;;
 
@@ -327,7 +328,9 @@
       ppc-*-netware*)       fmt=elf em=ppcnw ;;
       ppc-*-vxworks*)       fmt=elf ;;
 
+      sh-*-linux-gnu*)	    fmt=elf ;;
       sh-*-elf*)	    fmt=elf ;;
+      sh-*-nto*)	    fmt=elf ;;
       sh-*-coff*)           fmt=coff ;;
       sh-*-pe*)             fmt=coff em=pe bfd_gas=yes;;
       sh-*-rtemself*)       fmt=elf ;;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/doc/internals.texi binutils/gas/doc/internals.texi
--- binutils-2.10.1/gas/doc/internals.texi	2000-03-27 00:47:33.000000000 +1000
+++ binutils/gas/doc/internals.texi	2001-02-27 04:45:17.000000000 +1000
@@ -8,7 +8,7 @@
 This chapter describes the internals of the assembler.  It is incomplete, but
 it may help a bit.
 
-This chapter was last modified on $Date: 2000/03/26 14:47:33 $.  It is not updated regularly, and it
+This chapter was last modified on $Date: 2001/02/26 18:45:17 $.  It is not updated regularly, and it
 may be out of date.
 
 @menu
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/itbl-lex.c binutils/gas/itbl-lex.c
--- binutils-2.10.1/gas/itbl-lex.c	2000-05-31 22:27:13.000000000 +1000
+++ binutils/gas/itbl-lex.c	2001-02-27 04:45:15.000000000 +1000
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /cvs/src/src/gas/Attic/itbl-lex.c,v 1.1.2.1 2000/05/31 12:27:13 pb Exp $
+ * $Header: /cvs/tools/binutils/gas/itbl-lex.c,v 1.1.1.1 2001/02/26 18:45:15 keith Exp $
  */
 
 #define FLEX_SCANNER
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/assign.err binutils/gas/testsuite/gasp/assign.err
--- binutils-2.10.1/gas/testsuite/gasp/assign.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/assign.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-assign.asm:8 Can't find preprocessor variable bar.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/crash.err binutils/gas/testsuite/gasp/crash.err
--- binutils-2.10.1/gas/testsuite/gasp/crash.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/crash.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-crash.asm:18 Unreasonable expansion (-u turns off check).
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/exp.err binutils/gas/testsuite/gasp/exp.err
--- binutils-2.10.1/gas/testsuite/gasp/exp.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/exp.err	1970-01-01 10:00:00.000000000 +1000
@@ -1,7 +0,0 @@
-exp.asm:56 can't add two relocatable expressions
-exp.asm:57 the * operator cannot take non-absolute arguments.
-exp.asm:58 the / operator cannot take non-absolute arguments.
-exp.asm:59 the | operator cannot take non-absolute arguments.
-exp.asm:60 the & operator cannot take non-absolute arguments.
-exp.asm:61 the ~ operator cannot take non-absolute arguments.
-exp.asm:62 the * operator cannot take non-absolute arguments.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/pl1.err binutils/gas/testsuite/gasp/pl1.err
--- binutils-2.10.1/gas/testsuite/gasp/pl1.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/pl1.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-END missing from end of file.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/pl7.err binutils/gas/testsuite/gasp/pl7.err
--- binutils-2.10.1/gas/testsuite/gasp/pl7.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/pl7.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-END missing from end of file.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/reperr1.err binutils/gas/testsuite/gasp/reperr1.err
--- binutils-2.10.1/gas/testsuite/gasp/reperr1.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/reperr1.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-End of file whilst inside AREPEAT, started on line 3.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/reperr2.err binutils/gas/testsuite/gasp/reperr2.err
--- binutils-2.10.1/gas/testsuite/gasp/reperr2.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/reperr2.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-reperr2.asm:4 AENDR without a AREPEAT.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/reperr3.err binutils/gas/testsuite/gasp/reperr3.err
--- binutils-2.10.1/gas/testsuite/gasp/reperr3.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/reperr3.err	1970-01-01 10:00:00.000000000 +1000
@@ -1,6 +0,0 @@
-reperr3.asm:14 AENDR without a AREPEAT.
-reperr3.asm:16 AENDR without a AREPEAT.
-reperr3.asm:17 AENDR without a AREPEAT.
-reperr3.asm:18 AENDR without a AREPEAT.
-reperr3.asm:19 AENDR without a AREPEAT.
-reperr3.asm:20 AENDR without a AREPEAT.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/reperr.err binutils/gas/testsuite/gasp/reperr.err
--- binutils-2.10.1/gas/testsuite/gasp/reperr.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/reperr.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-END missing from end of file.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/sdata.err binutils/gas/testsuite/gasp/sdata.err
--- binutils-2.10.1/gas/testsuite/gasp/sdata.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/sdata.err	1970-01-01 10:00:00.000000000 +1000
@@ -1,3 +0,0 @@
-sdata.asm:19 Character code in string must be absolute expression.
-sdata.asm:19 Missing > for character code.
-END missing from end of file.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/testsuite/gasp/t3.err binutils/gas/testsuite/gasp/t3.err
--- binutils-2.10.1/gas/testsuite/gasp/t3.err	1999-05-03 17:28:53.000000000 +1000
+++ binutils/gas/testsuite/gasp/t3.err	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-END missing from end of file.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/gas/write.c binutils/gas/write.c
--- binutils-2.10.1/gas/write.c	1999-09-12 13:44:41.000000000 +1000
+++ binutils/gas/write.c	2001-02-27 05:19:38.000000000 +1000
@@ -2685,7 +2685,10 @@
 #if !(defined (TC_ARM)  && defined (OBJ_ELF))
 #if !(defined (TC_I960) && defined (OBJ_ELF))
 #if !defined (TC_I386) || !(defined (OBJ_ELF) || defined (OBJ_COFF)) || defined (TE_PE)
-		  add_number += S_GET_VALUE (add_symbolP);
+#if (defined (TC_SH) && defined (OBJ_ELF))
+		    if (! sh_pic)
+#endif
+		    add_number += S_GET_VALUE (add_symbolP);
 #endif
 #endif
 #endif
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/include/bfdlink.h binutils/include/bfdlink.h
--- binutils-2.10.1/include/bfdlink.h	2000-03-02 05:38:01.000000000 +1000
+++ binutils/include/bfdlink.h	2001-02-27 05:19:39.000000000 +1000
@@ -244,6 +244,8 @@
   /* The function to call when the executable or shared object is
      unloaded.  */
   const char *fini_function;
+
+  boolean without_lazy_binding;
 };
 
 /* This structures holds a set of callback functions.  These are
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/include/elf/mips.h binutils/include/elf/mips.h
--- binutils-2.10.1/include/elf/mips.h	2000-03-11 12:16:25.000000000 +1000
+++ binutils/include/elf/mips.h	2001-02-27 05:19:39.000000000 +1000
@@ -75,6 +75,8 @@
   /* These relocs are used for the mips16.  */
   RELOC_NUMBER (R_MIPS16_26, 100)
   RELOC_NUMBER (R_MIPS16_GPREL, 101)
+  /* And this is used with QNX pic for data copy relocs */
+  RELOC_NUMBER (R_MIPS_QNX_COPY, 126)
   /* These are GNU extensions to handle embedded-pic.  */
   RELOC_NUMBER (R_MIPS_PC32, 248)
   RELOC_NUMBER (R_MIPS_PC64, 249)
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/include/elf/sh.h binutils/include/elf/sh.h
--- binutils-2.10.1/include/elf/sh.h	2000-02-17 10:33:35.000000000 +1000
+++ binutils/include/elf/sh.h	2001-02-27 05:19:39.000000000 +1000
@@ -76,6 +76,16 @@
   RELOC_NUMBER (R_SH_SWITCH8, 33)
   RELOC_NUMBER (R_SH_GNU_VTINHERIT, 34)
   RELOC_NUMBER (R_SH_GNU_VTENTRY, 35)
+  FAKE_RELOC (R_SH_FIRST_INVALID_RELOC2, 36)
+  FAKE_RELOC (R_SH_LAST_INVALID_RELOC2, 143)
+  RELOC_NUMBER (R_SH_GOT32, 160)
+  RELOC_NUMBER (R_SH_PLT32, 161)
+  RELOC_NUMBER (R_SH_COPY, 162)
+  RELOC_NUMBER (R_SH_GLOB_DAT, 163)
+  RELOC_NUMBER (R_SH_JMP_SLOT, 164)
+  RELOC_NUMBER (R_SH_RELATIVE, 165)
+  RELOC_NUMBER (R_SH_GOTOFF, 166)
+  RELOC_NUMBER (R_SH_GOTPC, 167)
   EMPTY_RELOC (R_SH_max)
 END_RELOC_NUMBERS
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/include/opcode/ppc.h binutils/include/opcode/ppc.h
--- binutils-2.10.1/include/opcode/ppc.h	1999-05-09 09:28:34.000000000 +1000
+++ binutils/include/opcode/ppc.h	2001-02-27 05:19:39.000000000 +1000
@@ -88,6 +88,9 @@
 /* Opcode is supported as part of the 64-bit bridge.  */
 #define PPC_OPCODE_64_BRIDGE (0400)
 
+/* Opcode is part of the optional AltiVec extension.  */
+#define PPC_OPCODE_VEC (0400)
+
 /* A macro to extract the major opcode from an instruction.  */
 #define PPC_OP(i) (((i) >> 26) & 0x3f)
 
@@ -221,6 +224,10 @@
    number is allowed).  This flag will only be set for a signed
    operand.  */
 #define PPC_OPERAND_NEGATIVE (04000)
+
+/* This operand names a vector register.  The disassembler
+   prints these with a leading 'v'.  */
+#define PPC_OPERAND_VR (010000)
 
 /* The POWER and PowerPC assemblers use a few macros.  We keep them
    with the operands table for simplicity.  The macro table is an
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/configure.tgt binutils/ld/configure.tgt
--- binutils-2.10.1/ld/configure.tgt	2000-08-07 01:22:07.000000000 +1000
+++ binutils/ld/configure.tgt	2001-03-01 02:51:40.000000000 +1000
@@ -118,6 +118,8 @@
 			targ_extra_emuls=i386linux
 			tdir_i386linux=${targ_alias}aout
 			;;
+i[3456]86-*-nto* | x86-*nto*)  targ_emul=i386nto ;;
+i[3456]86-*-qnx*)  targ_emul=i386qnx; targ_extra_emuls=elf_i386 ;;
 i[3456]86-*-sysv[45]*)	targ_emul=elf_i386 ;;
 i[3456]86-*-solaris2*)	targ_emul=elf_i386 ;;
 i[3456]86-*-unixware)	targ_emul=elf_i386 ;;
@@ -159,6 +161,7 @@
 arm-*-elf)		targ_emul=armelf ;;
 arm-*-oabi)		targ_emul=armelf_oabi ;;
 arm*-*-linux-gnu*)	targ_emul=armelf_linux; targ_extra_emuls="armelf_linux26 armelf" ;;
+arm-*-nto*)		targ_emul=armnto ;;
 arm*-*-uclinux*)	targ_emul=armelf_linux; targ_extra_emuls=armelf ;;
 arm*-*-conix*)		targ_emul=armelf ;;
 thumb-*-linux-gnu* | thumb-*-uclinux*)	targ_emul=armelf_linux; targ_extra_emuls=armelf ;;
@@ -178,10 +181,17 @@
 			targ_emul=h8500
 			targ_extra_emuls="h8500s h8500b h8500m h8500c"
 			;;
+sh-*-linux-gnu*)
+			targ_emul=shelf_linux
+			targ_extra_emuls=shlelf_linux
+			;;
 sh-*-elf* | sh-*-rtemself*)
 			targ_emul=shelf
 			targ_extra_emuls="shlelf sh shl"
 			;;
+sh-*-nto*)		targ_emul=shelf_nto
+				targ_extra_emuls=shlelf_nto
+			;;
 sh-*-pe)		targ_emul=shpe ;
 			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
 sh-*-rtemscoff* | sh-*-* | sh-*-rtems*)
@@ -237,6 +247,8 @@
 mips*vr5000-*-elf*)	targ_emul=elf32b4300 ;;
 mips*el-*-elf*)		targ_emul=elf32elmip ;;
 mips*-*-elf*)		targ_emul=elf32ebmip ;;
+mips*el-*-nto*) 	targ_emul=elf32elmip ;;
+mips*-*-nto*)		targ_emul=elf32bmipnto ;;
 mips*el-*-rtems*)	targ_emul=elf32elmip ;;
 mips*-*-rtems*)		targ_emul=elf32ebmip ;;
 mips*el-*-vxworks*)	targ_emul=elf32elmip ;;
@@ -274,6 +286,8 @@
 powerpcle-*-elf* | powerpcle-*-eabi* | powerpcle-*-solaris* \
   | powerpcle-*-sysv* | powerpcle-*-vxworks*)
 	targ_emul=elf32lppc ;;
+powerpcle-*-nto*)	targ_emul=elf32lppcnto ;;
+powerpc-*-nto* | ppc*-nto*) 	targ_emul=elf32ppcnto ;;
 powerpcle-*-rtems*)	targ_emul=elf32leppc ;;
 powerpc-*-rtems*)	targ_emul=elf32ppc ;;
 powerpc-*-macos*)	targ_emul=ppcmacos ;;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/armnto.sh binutils/ld/emulparams/armnto.sh
--- binutils-2.10.1/ld/emulparams/armnto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/armnto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,15 @@
+ARCH=arm
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-littlearm"
+BIG_OUTPUT_FORMAT="elf32-bigarm"
+LITTLE_OUTPUT_FORMAT="elf32-littlearm"
+MAXPAGESIZE=0x1000
+TEMPLATE_NAME=armelf
+GENERATE_SHLIB_SCRIPT=yes
+
+DATA_START_SYMBOLS='__data_start = . ;';
+OTHER_TEXT_SECTIONS='*(.glue_7t) *(.glue_7)'
+OTHER_BSS_SYMBOLS='__bss_start__ = .;'
+OTHER_BSS_END_SYMBOLS='_bss_end__ = . ; __bss_end__ = . ; __end__ = . ;'
+
+TEXT_START_ADDR=0x00100000
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/elf32bmipnto.sh binutils/ld/emulparams/elf32bmipnto.sh
--- binutils-2.10.1/ld/emulparams/elf32bmipnto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/elf32bmipnto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,30 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-bigmips"
+BIG_OUTPUT_FORMAT="elf32-bigmips"
+LITTLE_OUTPUT_FORMAT="elf32-littlemips"
+TEXT_START_ADDR=0x08020000
+MAXPAGESIZE=0x1000
+NONPAGED_TEXT_START_ADDR=0x08020000
+#SHLIB_TEXT_START_ADDR=0x78200000
+TEXT_DYNAMIC=
+INITIAL_READONLY_SECTIONS='.reginfo : { *(.reginfo) }'
+OTHER_TEXT_SECTIONS='*(.mips16.fn.*) *(.mips16.call.*)'
+OTHER_GOT_SYMBOLS='
+  _gp = ALIGN(16) + 0x7ff0;
+'
+OTHER_GOT_SECTIONS='
+  .lit8 : { *(.lit8) }
+  .lit4 : { *(.lit4) }
+'
+TEXT_START_SYMBOLS='_btext = . ;'
+DATA_START_SYMBOLS='_bdata = . ;'
+OTHER_BSS_SYMBOLS='_fbss = .;'
+OTHER_SECTIONS='
+  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }
+  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }
+'
+STRICT_DATA_ALIGN=yes
+ARCH=mips
+MACHINE=
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/elf32lppcnto.sh binutils/ld/emulparams/elf32lppcnto.sh
--- binutils-2.10.1/ld/emulparams/elf32lppcnto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/elf32lppcnto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,10 @@
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+SCRIPT_NAME=elfppc
+OUTPUT_FORMAT="elf32-powerpcle"
+TEXT_START_SYMBOLS='_btext = .;'
+TEXT_START_ADDR=0x48040000
+#SHLIB_TEXT_START_ADDR=0xf0300000
+MAXPAGESIZE=0x1000
+ARCH=powerpc
+MACHINE=
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/elf32ppcnto.sh binutils/ld/emulparams/elf32ppcnto.sh
--- binutils-2.10.1/ld/emulparams/elf32ppcnto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/elf32ppcnto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,10 @@
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+SCRIPT_NAME=elfppc
+OUTPUT_FORMAT="elf32-powerpc"
+TEXT_START_SYMBOLS='_btext = .;'
+TEXT_START_ADDR=0x48040000
+#SHLIB_TEXT_START_ADDR=0xf0300000
+MAXPAGESIZE=0x1000
+ARCH=powerpc
+MACHINE=
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/elf32shnto.sh binutils/ld/emulparams/elf32shnto.sh
--- binutils-2.10.1/ld/emulparams/elf32shnto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/elf32shnto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,17 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-sh"
+TEXT_START_ADDR=0x1000
+MAXPAGESIZE=128
+ARCH=sh
+MACHINE=
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+EMBEDDED=yes
+
+# These are for compatibility with the COFF toolchain.
+ENTRY=start
+CTOR_START='___ctors = .;'
+CTOR_END='___ctors_end = .;'
+DTOR_START='___dtors = .;'
+DTOR_END='___dtors_end = .;'
+OTHER_RELOCATING_SECTIONS='.stack 0x30000 : { _stack = .; *(.stack) }'
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/i386nto.sh binutils/ld/emulparams/i386nto.sh
--- binutils-2.10.1/ld/emulparams/i386nto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/i386nto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,12 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-i386"
+TEXT_START_ADDR=0x08048000
+TEXT_START_SYMBOLS='_btext = .;'
+MAXPAGESIZE=0x1000
+NONPAGED_TEXT_START_ADDR=0x08048000
+#SHLIB_TEXT_START_ADDR=0xb0300000
+ARCH=i386
+MACHINE=
+NOP=0x9090
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/i386qnx.sh binutils/ld/emulparams/i386qnx.sh
--- binutils-2.10.1/ld/emulparams/i386qnx.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/i386qnx.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,12 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-i386"
+TEXT_START_ADDR=0x08048000
+TEXT_START_SYMBOLS='_btext = .;'
+MAXPAGESIZE=0x1000
+NONPAGED_TEXT_START_ADDR=0x08048000
+SHLIB_TEXT_START_ADDR=0xb0300000
+ARCH=i386
+MACHINE=
+NOP=0x9090
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/shelf_nto.sh binutils/ld/emulparams/shelf_nto.sh
--- binutils-2.10.1/ld/emulparams/shelf_nto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/shelf_nto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,12 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-sh"
+TEXT_START_ADDR=0x08040000
+MAXPAGESIZE=0x1000
+ARCH=sh
+MACHINE=
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+TEXT_START_SYMBOLS='_btext = .;'
+#SHLIB_TEXT_START_ADDR=0x70300000
+
+ENTRY=_start
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/emulparams/shlelf_nto.sh binutils/ld/emulparams/shlelf_nto.sh
--- binutils-2.10.1/ld/emulparams/shlelf_nto.sh	1970-01-01 10:00:00.000000000 +1000
+++ binutils/ld/emulparams/shlelf_nto.sh	2001-02-27 05:19:39.000000000 +1000
@@ -0,0 +1,12 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-shl"
+TEXT_START_ADDR=0x08040000
+MAXPAGESIZE=0x1000
+ARCH=sh
+MACHINE=
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+TEXT_START_SYMBOLS='_btext = .;'
+#SHLIB_TEXT_START_ADDR=0x70300000
+
+ENTRY=_start
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/ldlex.c binutils/ld/ldlex.c
--- binutils-2.10.1/ld/ldlex.c	2000-11-07 18:44:15.000000000 +1000
+++ binutils/ld/ldlex.c	2001-02-27 08:00:35.000000000 +1000
@@ -1,7 +1,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /cvs/src/src/ld/Attic/ldlex.c,v 1.1.2.2 2000/11/05 06:36:59 amodra Exp $
+ * $Header: /cvs/tools/binutils/ld/ldlex.c,v 1.1.1.1 2001/02/26 22:00:35 keith Exp $
  */
 
 #define FLEX_SCANNER
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/ldmain.c binutils/ld/ldmain.c
--- binutils-2.10.1/ld/ldmain.c	2000-05-28 20:57:51.000000000 +1000
+++ binutils/ld/ldmain.c	2001-02-27 05:19:39.000000000 +1000
@@ -166,6 +166,9 @@
 {
   char *emulation;
   long start_time = get_run_time ();
+#ifdef __QNXNTO__
+  munlockall ();
+#endif
 
 #if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
   setlocale (LC_MESSAGES, "");
@@ -236,6 +239,7 @@
      and _fini symbols.  We are compatible.  */
   link_info.init_function = "_init";
   link_info.fini_function = "_fini";
+  link_info.without_lazy_binding = false;
 
   ldfile_add_arch ("");
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/lexsup.c binutils/ld/lexsup.c
--- binutils-2.10.1/ld/lexsup.c	2000-05-15 12:21:03.000000000 +1000
+++ binutils/ld/lexsup.c	2001-02-27 05:19:39.000000000 +1000
@@ -123,6 +123,7 @@
 #define OPTION_NO_UNDEFINED		(OPTION_MPC860C0 + 1)
 #define OPTION_INIT                     (OPTION_NO_UNDEFINED + 1)
 #define OPTION_FINI                     (OPTION_INIT + 1)
+#define OPTION_WITHOUT_LAZY_BINDING     (OPTION_FINI + 1)
 
 /* The long options.  This structure is used for both the option
    parsing and the help text.  */
@@ -320,6 +321,8 @@
       '\0', NULL, N_("Create a shared library"), ONE_DASH },
   { {"Bshareable", no_argument, NULL, OPTION_SHARED }, /* FreeBSD.  */
       '\0', NULL, NULL, ONE_DASH },
+  { {"small-stubs", no_argument, NULL, OPTION_WITHOUT_LAZY_BINDING},
+      '\0', NULL, N_("Generate small PLT stubs"), TWO_DASHES },
   { {"sort-common", no_argument, NULL, OPTION_SORT_COMMON},
       '\0', NULL, N_("Sort common symbols by size"), TWO_DASHES },
   { {"sort_common", no_argument, NULL, OPTION_SORT_COMMON},
@@ -859,7 +862,23 @@
 	  config.dynamic_link = false;
 	  break;
 	case 'u':
-	  ldlang_add_undef (optarg);
+      if (optarg[0] == '@') {
+          FILE *ufp;
+          char usym[1024], *up;
+
+          if ((ufp = fopen(optarg + 1, "r")) != NULL) {
+              while ((up = fgets(usym, sizeof(usym) - 1, ufp)) != NULL) {
+                  up = strtok( usym, "\n" );
+                  ldlang_add_undef(up);
+              }
+              fclose(ufp);
+          }
+          else {
+              einfo ("%P%F: couldn't open undefined symbols file: `%s'\n", optarg+1 );
+          }
+      } else {
+          ldlang_add_undef(optarg);
+      }
 	  break;
 	case OPTION_VERBOSE:
 	  ldversion (1);
@@ -1013,6 +1032,9 @@
 	case OPTION_FINI:
 	  link_info.fini_function = optarg;
 	  break;
+	case OPTION_WITHOUT_LAZY_BINDING:
+	  link_info.without_lazy_binding = true;
+	  break;
 	}
     }
 
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/Makefile.in binutils/ld/Makefile.in
--- binutils-2.10.1/ld/Makefile.in	2000-11-07 18:44:12.000000000 +1000
+++ binutils/ld/Makefile.in	2001-03-01 02:51:40.000000000 +1000
@@ -212,6 +212,7 @@
 	earmaoutl.o \
 	earmcoff.o \
 	earmnbsd.o \
+	earmnto.o \
 	earmpe.o \
 	earm_epoc_pe.o \
 	eavr1200.o \
@@ -271,6 +272,7 @@
 	ei386nbsd.o \
 	ei386nw.o \
 	ei386pe.o \
+	ei386qnx.o \
 	ei386pe_posix.o \
 	elnk960.o \
 	em68k4knbsd.o \
@@ -303,6 +305,10 @@
 	esa29200.o \
 	esh.o \
 	eshelf.o \
+	eshelf_linux.o \
+	eshlelf_linux.o \
+	eshelf_nto.o \
+	eshlelf_nto.o \
 	eshlelf.o \
 	eshl.o \
 	eshpe.o \
@@ -1021,6 +1027,9 @@
 earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} armnbsd "$(tdir_armnbsd)"
+earmnto.c: $(srcdir)/emulparams/armnto.sh \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnto "$(tdir_armnto)"
 earm_epoc_pe.c: $(srcdir)/emulparams/arm_epoc_pe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/epocpe.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} arm_epoc_pe "$(tdir_armpe)"
@@ -1224,6 +1233,9 @@
 ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386pe "$(tdir_i386pe)"
+ei386qnx.c: $(srcdir)/emulparams/i386qnx.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386qnx "$(tdir_i386qnx)"
 ei386pe_posix.c: $(srcdir)/emulparams/i386pe_posix.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} i386pe_posix "$(tdir_i386pe_posix)"
@@ -1326,6 +1338,18 @@
 eshelf.c: $(srcdir)/emulparams/shelf.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} shelf "$(tdir_shelf)"
+eshelf_linux.c: $(srcdir)/emulparams/shelf_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_linux "$(tdir_shelf_linux)"
+eshlelf_linux.c: $(srcdir)/emulparams/shlelf_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_linux "$(tdir_shlelf_linux)"
+eshelf_nto.c: $(srcdir)/emulparams/shelf_nto.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_nto "$(tdir_shelf_nto)"
+eshlelf_nto.c: $(srcdir)/emulparams/shlelf_nto.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_nto "$(tdir_shlelf_nto)"
 eshlelf.c: $(srcdir)/emulparams/shlelf.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} shlelf "$(tdir_shlelf)"
@@ -1386,6 +1410,18 @@
 ez8002.c: $(srcdir)/emulparams/z8002.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} z8002 "$(tdir_z8002)"
+eelf32bmipnto.c: $(srcdir)/emulparams/elf32bmipnto.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bmipnto "$(tdir_elf32bmipnto)"
+eelf32ppcnto.c: $(srcdir)/emulparams/elf32lppcnto.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfppc.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcnto "$(tdir_elf32ppcnto)"
+eelf32lppcnto.c: $(srcdir)/emulparams/elf32lppcnto.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfppc.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppcnto "$(tdir_elf32lppcnto)"
+ei386nto.c: $(srcdir)/emulparams/i386nto.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nto "$(tdir_i386nto)"
 
 # The generated emulation files mostly have the same dependencies.
 $(EMULATION_OFILES): ../bfd/bfd.h sysdep.h config.h $(INCDIR)/bfdlink.h \
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/scripttempl/elfppc.sc binutils/ld/scripttempl/elfppc.sc
--- binutils-2.10.1/ld/scripttempl/elfppc.sc	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/scripttempl/elfppc.sc	2001-02-27 05:19:39.000000000 +1000
@@ -131,6 +131,7 @@
     /* .gnu.warning sections are handled specially by elf32.em.  */
     *(.gnu.warning)
     ${RELOCATING+*(.gnu.linkonce.t*)}
+    . += 16; /* To allow access of one vector beyond the last object.  */
   } =${NOP-0}
   .init		${RELOCATING-0} : { KEEP (*(.init))	} =${NOP-0}
   .fini		${RELOCATING-0} : { KEEP (*(.fini))	} =${NOP-0}
@@ -161,8 +162,11 @@
      multiple executions of the program; I think that is more
      important than losing a page of the virtual address space (note
      that no actual memory is lost; the page which is skipped can not
-     be referenced).  */
-  ${RELOCATING+. = ${DATA_ADDR- ALIGN(8) + ${MAXPAGESIZE}};}
+     be referenced).  
+
+     Align to a 16 byte boundary to allow vector access of non-vector 
+     objects.  */
+  ${RELOCATING+. = ${DATA_ADDR- ALIGN(16) + ${MAXPAGESIZE}};}
 
   .data  ${RELOCATING-0} :
   {
@@ -171,6 +175,7 @@
     ${RELOCATING+*(.data.*)}
     ${RELOCATING+*(.gnu.linkonce.d*)}
     ${CONSTRUCTING+CONSTRUCTORS}
+    . += 16; /* To allow access of one vector beyond the last object.  */
   }
   .data1 ${RELOCATING-0} : { *(.data1) }
   ${RELOCATING+${OTHER_READWRITE_SECTIONS}}
@@ -233,6 +238,7 @@
     ${RELOCATING+PROVIDE (___sbss_end = .);}
   }
   ${PLT}
+  . = ALIGN(16); /* For vector access of non-vector objects.  */
   .bss     ${RELOCATING-0} :
   {
    ${RELOCATING+${OTHER_BSS_SYMBOLS}}
@@ -241,6 +247,7 @@
    *(.dynbss)
    *(.bss)
    *(COMMON)
+   . += 16; /* To allow access of one vector beyond the last object.  */
   }
   ${RELOCATING+_end = . ;}
   ${RELOCATING+PROVIDE (end = .);}
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers15.sym binutils/ld/testsuite/ld-elfvers/vers15.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers15.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers15.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1,3 +0,0 @@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@VERS_1.1
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@@VERS_1.2
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers16.map binutils/ld/testsuite/ld-elfvers/vers16.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers16.map	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers16.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,3 +0,0 @@
-VERS_1.1 {
-  global: show_bar;
-};
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers17.map binutils/ld/testsuite/ld-elfvers/vers17.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers17.map	1999-07-08 01:36:28.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers17.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-VERS_2.0 {
-	 global:
-		 show_foo;
-};
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers18.map binutils/ld/testsuite/ld-elfvers/vers18.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers18.map	1999-07-08 01:36:29.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers18.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,15 +0,0 @@
-VERS_1.1 {
-	 global:
-		 foo1;
-	 local:
-		 hide_old*; 
-		 hide_original*; 
-		 hide_new*; 
-};
-
-VERS_1.2 {
-		 foo2;
-} VERS_1.1;
-
-VERS_2.0 {
-} VERS_1.2;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers18.sym binutils/ld/testsuite/ld-elfvers/vers18.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers18.sym	1999-07-08 01:36:29.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers18.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-[0-9a-f]*  w    F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@
-[0-9a-f]*  w    F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@VERS_1.1
-[0-9a-f]*  w    F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@VERS_1.2
-[0-9a-f]*  w    F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@@VERS_2.0
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers1.map binutils/ld/testsuite/ld-elfvers/vers1.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers1.map	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers1.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,16 +0,0 @@
-VERS_1.1 {
-	 global:
-		 foo1;
-	 local:
-		 hide_old*; 
-		 hide_original*; 
-		 hide_new*; 
-};
-
-VERS_1.2 {
-		 foo2;
-} VERS_1.1;
-
-VERS_2.0 {
-		 show_bar1; show_bar2;
-} VERS_1.2;
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers1.sym binutils/ld/testsuite/ld-elfvers/vers1.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers1.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers1.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@VERS_1.1
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@VERS_1.2
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_foo@@VERS_2.0
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers2.map binutils/ld/testsuite/ld-elfvers/vers2.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers2.map	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers2.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-
-VERS_XXX_1.1 {
-		 show_xyzzy;
-};
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers4a.sym binutils/ld/testsuite/ld-elfvers/vers4a.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers4a.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers4a.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?foo@@VERS_2.0
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers4.sym binutils/ld/testsuite/ld-elfvers/vers4.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers4.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers4.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1 +0,0 @@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?foo@@VERS_2.0
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers6.sym binutils/ld/testsuite/ld-elfvers/vers6.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers6.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers6.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-[0]* *F? *\*UND\*	[0]* show_foo@
-[0]* *F? *\*UND\*	[0]* show_foo@VERS_1.1
-[0]* *F? *\*UND\*	[0]* show_foo@VERS_1.2
-[0]* *F? *\*UND\*	[0]* show_foo@VERS_2.0
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers7a.sym binutils/ld/testsuite/ld-elfvers/vers7a.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers7a.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers7a.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1,2 +0,0 @@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?hide_a@@VERS_1
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?show_b@@VERS_1
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers7.map binutils/ld/testsuite/ld-elfvers/vers7.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers7.map	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers7.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,6 +0,0 @@
-VERS_1 {
-	global:
-		show_b ;
-	local:
-		hide_a;
-};
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers8.map binutils/ld/testsuite/ld-elfvers/vers8.map
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers8.map	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers8.map	1970-01-01 10:00:00.000000000 +1000
@@ -1,18 +0,0 @@
-VERSION {
-	VERS_1.1 {
-		 global:
-			 foo1;
-		 local:
-			 hide_old*; 
-			 hide_original*; 
-			 hide_new*; 
-	};
-	
-	VERS_1.2 {
-			 foo2;
-	} VERS_1.1;
-	
-	VERS_2.0 {
-			 show_bar1; show_bar2;
-	} VERS_1.2;
-}
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ld/testsuite/ld-elfvers/vers9.sym binutils/ld/testsuite/ld-elfvers/vers9.sym
--- binutils-2.10.1/ld/testsuite/ld-elfvers/vers9.sym	1999-05-03 17:29:08.000000000 +1000
+++ binutils/ld/testsuite/ld-elfvers/vers9.sym	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-[0]* *F? *\*UND\*	[0]* foo@VERS_1.2
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?foo@
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?foo@VERS_1.1
-[0-9a-f]* g     F .text	[0-9a-f]* (0x[0-9a-f][0-9a-f] )?foo@@VERS_1.2
Binary files binutils-2.10.1/libiberty/argv.o and binutils/libiberty/argv.o differ
Binary files binutils-2.10.1/libiberty/choose-temp.o and binutils/libiberty/choose-temp.o differ
Binary files binutils-2.10.1/libiberty/concat.o and binutils/libiberty/concat.o differ
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ltconfig binutils/ltconfig
--- binutils-2.10.1/ltconfig	2000-02-28 02:46:19.000000000 +1000
+++ binutils/ltconfig	2001-02-27 05:19:38.000000000 +1000
@@ -169,8 +169,8 @@
 # Constants:
 PROGRAM=ltconfig
 PACKAGE=libtool
-VERSION=1.3.4
-TIMESTAMP=" (1.385.2.196 1999/12/07 21:47:57)"
+VERSION=1.3.5
+TIMESTAMP=" (1.385.2.206 2000/05/27 11:12:27)"
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 rm="rm -f"
@@ -1164,15 +1164,21 @@
     # Extract the symbol export list from an `--export-all' def file,
     # then regenerate the def file from the symbol export list, so that
     # the compiled dll only exports the symbol export list.
+    # Be careful not to strip the DATA tag left by newer dlltools.
     export_symbols_cmds='test -f $objdir/$soname-ltdll.c || sed -e "/^# \/\* ltdll\.c starts here \*\//,/^# \/\* ltdll.c ends here \*\// { s/^# //; p; }" -e d < $0 > $objdir/$soname-ltdll.c~
       test -f $objdir/$soname-ltdll.$objext || (cd $objdir && $CC -c $soname-ltdll.c)~
       $DLLTOOL --export-all --exclude-symbols DllMain@12,_cygwin_dll_entry@12,_cygwin_noncygwin_dll_entry@12 --output-def $objdir/$soname-def  $objdir/$soname-ltdll.$objext $libobjs $convenience~
-      sed -e "1,/EXPORTS/d" -e "s/ @ [0-9]* ; *//" < $objdir/$soname-def > $export_symbols'
+      sed -e "1,/EXPORTS/d" -e "s/ @ [0-9]*//" -e "s/ *;.*$//" < $objdir/$soname-def > $export_symbols'
 
+    # If DATA tags from a recent dlltool are present, honour them!
     archive_expsym_cmds='echo EXPORTS > $objdir/$soname-def~
       _lt_hint=1;
-      for symbol in `cat $export_symbols`; do
-	echo "	\$symbol @ \$_lt_hint ; " >> $objdir/$soname-def;
+      cat $export_symbols | while read symbol; do
+        set dummy \$symbol;
+        case \$# in
+          2) echo "	\$2 @ \$_lt_hint ; " >> $objdir/$soname-def;;
+          *) echo "     \$2 @ \$_lt_hint \$3 ; " >> $objdir/$soname-def;;
+        esac;
 	_lt_hint=`expr 1 + \$_lt_hint`;
       done~
       test -f $objdir/$soname-ltdll.c || sed -e "/^# \/\* ltdll\.c starts here \*\//,/^# \/\* ltdll.c ends here \*\// { s/^# //; p; }" -e d < $0 > $objdir/$soname-ltdll.c~
@@ -1433,7 +1439,13 @@
     hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
     hardcode_libdir_separator=:
     ;;
-
+  rhapsody*)
+    archive_cmds='$CC -bundle -undefined suppress -o $lib $libobjs $deplibs $linkopts'
+    hardcode_libdir_flags_spec='-L$libdir'
+    hardcode_direct=yes
+    hardcode_shlibpath_var=no
+    ;;
+                                       
   sco3.2v5*)
     archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linkopts'
     hardcode_shlibpath_var=no
@@ -1466,7 +1478,13 @@
     ;;
 
   sysv4)
-    archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linkopts'
+    if test "x$host_vendor" = xsequent; then
+      # Use $CC to link under sequent, because it throws in some extra .o 
+      # files that make .init and .fini sections work.
+      archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $linkopts'
+    else
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linkopts'
+    fi
     runpath_var='LD_RUN_PATH'
     hardcode_shlibpath_var=no
     hardcode_direct=no #Motorola manual says yes, but my tests say they lie 
@@ -1632,11 +1650,11 @@
 main(){nm_test_var='a';nm_test_func();return(0);}
 EOF
 
-  echo "$progname:1635: checking if global_symbol_pipe works" >&5
-  if { (eval echo $progname:1636: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; } && test -s conftest.$objext; then
+  echo "$progname:1653: checking if global_symbol_pipe works" >&5
+  if { (eval echo $progname:1654: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; } && test -s conftest.$objext; then
     # Now try to grab the symbols.
     nlist=conftest.nm
-    if { echo "$progname:1639: eval \"$NM conftest.$objext | $global_symbol_pipe > $nlist\"" >&5; eval "$NM conftest.$objext | $global_symbol_pipe > $nlist 2>&5"; } && test -s "$nlist"; then
+    if { echo "$progname:1657: eval \"$NM conftest.$objext | $global_symbol_pipe > $nlist\"" >&5; eval "$NM conftest.$objext | $global_symbol_pipe > $nlist 2>&5"; } && test -s "$nlist"; then
 
       # Try sorting and uniquifying the output.
       if sort "$nlist" | uniq > "$nlist"T; then
@@ -1688,7 +1706,7 @@
 	  save_CFLAGS="$CFLAGS"
 	  LIBS="conftstm.$objext"
 	  CFLAGS="$CFLAGS$no_builtin_flag"
-	  if { (eval echo $progname:1691: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+	  if { (eval echo $progname:1709: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
 	    pipe_works=yes
 	  else
 	    echo "$progname: failed program was:" >&5
@@ -1919,6 +1937,14 @@
   soname_spec='${libname}${release}.sl$major'
   # HP-UX runs *really* slowly unless shared libraries are mode 555.
   postinstall_cmds='chmod 555 $lib'
+  case "$host_os" in
+  hpux10.20*)
+    # TODO:  Does this work for hpux-11 too?
+    deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9].[0-9]) shared library'
+    file_magic_cmd=/usr/bin/file
+    file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
   ;;
 
 irix5* | irix6*)
@@ -1966,9 +1992,7 @@
   finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
-  deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
-  file_magic_cmd=/usr/bin/file
-  file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  deplibs_check_method=pass_all
 
   if test -f /lib/ld.so.1; then
     dynamic_linker='GNU ld.so'
@@ -2029,6 +2053,14 @@
   sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
   ;;
 
+rhapsody*)
+  version_type=sunos
+  library_names_spec='${libname}.so'
+  soname_spec='${libname}.so'
+  shlibpath_var=DYLD_LIBRARY_PATH
+  deplibs_check_method=pass_all
+  ;;
+
 sco3.2v5*)
   version_type=osf
   soname_spec='${libname}${release}.so$major'
@@ -2069,6 +2101,10 @@
   soname_spec='${libname}${release}.so$major'
   shlibpath_var=LD_LIBRARY_PATH
   case "$host_vendor" in
+    sequent)
+      file_magic_cmd='/bin/file'
+      deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+      ;;
     ncr)
       deplibs_check_method='pass_all'
       ;;
@@ -2109,6 +2145,17 @@
   fi
   ;;
 
+nto-qnx)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}.so$versuffix ${libname}${release}.so$major $libname.so'
+  soname_spec='${libname}${release}.so$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  deplibs_check_method='pass_all'
+  ;;
+
 *)
   dynamic_linker=no
   ;;
@@ -2209,7 +2256,7 @@
 if eval "test \"`echo '$''{'lt_cv_dlopen'+set}'`\" != set"; then
   lt_cv_dlopen=no lt_cv_dlopen_libs=
 echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "$progname:2212: checking for dlopen in -ldl" >&5
+echo "$progname:2259: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2217,7 +2264,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2220 "ltconfig"
+#line 2267 "ltconfig"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
@@ -2230,7 +2277,7 @@
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo $progname:2233: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo $progname:2280: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2249,12 +2296,12 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dlopen""... $ac_c" 1>&6
-echo "$progname:2252: checking for dlopen" >&5
+echo "$progname:2299: checking for dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2257 "ltconfig"
+#line 2304 "ltconfig"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen(); below.  */
 #include <assert.h>
@@ -2279,7 +2326,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo $progname:2282: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo $progname:2329: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dlopen=yes"
 else
@@ -2296,7 +2343,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dld_link in -ldld""... $ac_c" 1>&6
-echo "$progname:2299: checking for dld_link in -ldld" >&5
+echo "$progname:2346: checking for dld_link in -ldld" >&5
 ac_lib_var=`echo dld'_'dld_link | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2304,7 +2351,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldld  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2307 "ltconfig"
+#line 2354 "ltconfig"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
@@ -2317,7 +2364,7 @@
 dld_link()
 ; return 0; }
 EOF
-if { (eval echo $progname:2320: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo $progname:2367: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2336,12 +2383,12 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for shl_load""... $ac_c" 1>&6
-echo "$progname:2339: checking for shl_load" >&5
+echo "$progname:2386: checking for shl_load" >&5
 if eval "test \"`echo '$''{'ac_cv_func_shl_load'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2344 "ltconfig"
+#line 2391 "ltconfig"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char shl_load(); below.  */
 #include <assert.h>
@@ -2366,7 +2413,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo $progname:2369: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo $progname:2416: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_shl_load=yes"
 else
@@ -2384,7 +2431,7 @@
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for shl_load in -ldld""... $ac_c" 1>&6
-echo "$progname:2387: checking for shl_load in -ldld" >&5
+echo "$progname:2434: checking for shl_load in -ldld" >&5
 ac_lib_var=`echo dld'_'shl_load | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2392,7 +2439,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ldld  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2395 "ltconfig"
+#line 2442 "ltconfig"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2406,7 +2453,7 @@
 shl_load()
 ; return 0; }
 EOF
-if { (eval echo $progname:2409: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo $progname:2456: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2449,17 +2496,17 @@
 for ac_hdr in dlfcn.h; do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "$progname:2452: checking for $ac_hdr" >&5
+echo "$progname:2499: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2457 "ltconfig"
+#line 2504 "ltconfig"
 #include <$ac_hdr>
 int fnord = 0;
 EOF
 ac_try="$ac_compile >/dev/null 2>conftest.out"
-{ (eval echo $progname:2462: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo $progname:2509: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2487,7 +2534,7 @@
     LIBS="$lt_cv_dlopen_libs $LIBS"
 
   echo $ac_n "checking whether a program can dlopen itself""... $ac_c" 1>&6
-echo "$progname:2490: checking whether a program can dlopen itself" >&5
+echo "$progname:2537: checking whether a program can dlopen itself" >&5
 if test "${lt_cv_dlopen_self+set}" = set; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2495,7 +2542,7 @@
     lt_cv_dlopen_self=cross
   else
     cat > conftest.c <<EOF
-#line 2498 "ltconfig"
+#line 2545 "ltconfig"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
@@ -2541,7 +2588,7 @@
 	       if(ptr1 || ptr2) { dlclose(self); exit(0); } } exit(1); } 
 
 EOF
-if { (eval echo $progname:2544: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo $progname:2591: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   lt_cv_dlopen_self=yes
 else
@@ -2560,7 +2607,7 @@
   if test "$lt_cv_dlopen_self" = yes; then
     LDFLAGS="$LDFLAGS $link_static_flag"
   echo $ac_n "checking whether a statically linked program can dlopen itself""... $ac_c" 1>&6
-echo "$progname:2563: checking whether a statically linked program can dlopen itself" >&5
+echo "$progname:2610: checking whether a statically linked program can dlopen itself" >&5
 if test "${lt_cv_dlopen_self_static+set}" = set; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2568,7 +2615,7 @@
     lt_cv_dlopen_self_static=cross
   else
     cat > conftest.c <<EOF
-#line 2571 "ltconfig"
+#line 2618 "ltconfig"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
@@ -2614,7 +2661,7 @@
     if(ptr1 || ptr2) { dlclose(self); exit(0); } } exit(1); } 
 
 EOF
-if { (eval echo $progname:2617: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo $progname:2664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   lt_cv_dlopen_self_static=yes
 else
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/ltmain.sh binutils/ltmain.sh
--- binutils-2.10.1/ltmain.sh	2000-02-28 02:46:19.000000000 +1000
+++ binutils/ltmain.sh	2001-02-27 05:19:38.000000000 +1000
@@ -1,7 +1,7 @@
 # ltmain.sh - Provide generalized library-building support services.
 # NOTE: Changing this file will not affect anything until you rerun ltconfig.
 #
-# Copyright (C) 1996-1999, 2000 Free Software Foundation, Inc.
+# Copyright (C) 1996-1999 Free Software Foundation, Inc.
 # Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
 #
 # This program is free software; you can redistribute it and/or modify
@@ -54,8 +54,8 @@
 # Constants.
 PROGRAM=ltmain.sh
 PACKAGE=libtool
-VERSION=1.3.4
-TIMESTAMP=" (1.385.2.196 1999/12/07 21:47:57)"
+VERSION=1.3.5
+TIMESTAMP=" (1.385.2.206 2000/05/27 11:12:27)"
 
 default_mode=
 help="Try \`$progname --help' for more information."
@@ -435,13 +435,7 @@
       fbsd_hideous_sh_bug=$base_compile
 
       # All platforms use -DPIC, to notify preprocessed assembler code.
-      # However, make sure we only set it for non-Java code.
-      case "$srcfile" in
-	*.java|*.class)
-	  command="$base_compile $pic_flag $srcfile";;
-	*)
-	  command="$base_compile $srcfile $pic_flag -DPIC";;
-      esac
+      command="$base_compile $srcfile $pic_flag -DPIC"
       if test "$build_old_libs" = yes; then
 	lo_libobj="$libobj"
 	dir=`$echo "X$libobj" | $Xsed -e 's%/[^/]*$%%'`
@@ -627,20 +621,6 @@
   # libtool link mode
   link)
     modename="$modename: link"
-    C_compiler="$CC" # save it, to compile generated C sources
-    # Always respect the CC configured in by ltconfig.
-    CC="$nonopt"
-    # CYGNUS LOCAL: tromey/java
-    # Add -B options to link line.
-    for arg
-    do
-       case "$arg" in
-	-B*)
-	   CC="$CC $arg"
-	   ;;
-       esac
-    done
-    # END CYGNUS LOCAL
     case "$host" in
     *-*-cygwin* | *-*-mingw* | *-*-os2*)
       # It is impossible to link a dll without this setting, and
@@ -1815,6 +1795,10 @@
 	*-*-cygwin* | *-*-mingw* | *-*-os2* | *-*-beos*)
 	  # these systems don't actually have a c library (as such)!
 	  ;;
+        *-*-rhapsody*)
+	  # rhapsody is a little odd...
+	  deplibs="$deplibs -framework System"
+	  ;;
 	*)
 	  # Add libc to deplibs on all other systems.
 	  deplibs="$deplibs -lc"
@@ -2947,13 +2931,21 @@
       # Run the actual program with our arguments.
 "
 	case $host in
-	*-*-cygwin* | *-*-mingw | *-*-os2*)
 	  # win32 systems need to use the prog path for dll
 	  # lookup to work
+	*-*-cygwin*)
+	  $echo >> $output "\
+      exec \$progdir/\$program \${1+\"\$@\"}
+"
+	  ;;
+
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2*)
 	  $echo >> $output "\
       exec \$progdir\\\\\$program \${1+\"\$@\"}
 "
 	  ;;
+
 	*)
 	  $echo >> $output "\
       # Export the path to the program.
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/opcodes/ppc-dis.c binutils/opcodes/ppc-dis.c
--- binutils-2.10.1/opcodes/ppc-dis.c	2000-05-07 00:49:26.000000000 +1000
+++ binutils/opcodes/ppc-dis.c	2001-02-27 05:19:39.000000000 +1000
@@ -41,7 +41,7 @@
      struct disassemble_info *info;
 {
   return print_insn_powerpc (memaddr, info, 1,
-			     PPC_OPCODE_PPC | PPC_OPCODE_601);
+			     PPC_OPCODE_PPC | PPC_OPCODE_601 | PPC_OPCODE_VEC);
 }
 
 /* Print a little endian PowerPC instruction.  For convenience, also
@@ -53,7 +53,7 @@
      struct disassemble_info *info;
 {
   return print_insn_powerpc (memaddr, info, 0,
-			     PPC_OPCODE_PPC | PPC_OPCODE_601);
+			     PPC_OPCODE_PPC | PPC_OPCODE_601 | PPC_OPCODE_VEC);
 }
 
 /* Print a POWER (RS/6000) instruction.  */
@@ -181,6 +181,8 @@
 	    (*info->fprintf_func) (info->stream, "r%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_FPR) != 0)
 	    (*info->fprintf_func) (info->stream, "f%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
+	    (*info->fprintf_func) (info->stream, "v%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
 	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/opcodes/ppc-opc.c binutils/opcodes/ppc-opc.c
--- binutils-2.10.1/opcodes/ppc-opc.c	2000-05-07 00:49:26.000000000 +1000
+++ binutils/opcodes/ppc-opc.c	2001-02-27 05:19:39.000000000 +1000
@@ -396,6 +396,49 @@
   /* The UI field in a D form instruction.  */
 #define UI U + 1
   { 16, 0, 0, 0, 0 },
+
+  /* AltiVec extensions */
+
+  /* The VA field in a VX or VA form instruction. */
+#define VRA (UI + 1)
+#define VRA_MASK (0x1f << 16)
+  { 5, 16, 0, 0, PPC_OPERAND_VR },
+
+  /* The VB field in a VX or VA form instruction. */
+#define VRB (VRA + 1)
+#define VRB_MASK (0x1f << 11)
+  { 5, 11, 0, 0, PPC_OPERAND_VR },
+
+  /* The VC field in a VA form instruction. */
+#define VRC (VRB + 1)
+#define VRC_MASK (0x1f << 6)
+  { 5, 6, 0, 0, PPC_OPERAND_VR },
+
+  /* The VS or VT field in an X form instruction, or the VT field
+     in a VX or VA instruction. */
+#define VRS (VRC + 1)
+#define VRT (VRS)
+#define VRT_MASK (0x1f << 21)
+  { 5, 21, 0, 0, PPC_OPERAND_VR },
+
+  /* The SH field in the "vsldoi" instruction. */
+#define VSH (VRS + 1)
+  { 4, 6, 0, 0, 0 },
+
+  /* The UIM field in the VX form instruction. */
+#define VUI (VSH + 1)
+  { 5, 16, 0, 0, 0 },
+
+  /* The SIM field in the VX form instruction. */
+#define VSI (VUI + 1)
+  { 5, 16, 0, 0, PPC_OPERAND_SIGNED },
+
+  /* The TAG field in the XV form instruction. */
+  /* Note: there are two bits if growing room in the TAG fields,
+   * leaving room for 16 (versus 4) potential streams. */
+#define TAG (VSI + 1)
+#define TAG_MASK (0x3 << 21)
+  { 2, 21, 0, 0, 0 },
 };
 
 /* The functions used to insert and extract complicated operands.  */
@@ -1071,6 +1114,50 @@
 #define DSO(op, xop) (OP (op) | ((xop) & 0x3))
 #define DS_MASK DSO (0x3f, 3)
 
+/* AltiVec extensions.  */
+
+/* A VA form instruction.  */
+#define VA(op, xop) (OP (op) | ((((unsigned long)(xop)) & 0x3f)))
+#define VA_MASK VA (0x3f, 0x3f)
+
+/* A VX form instruction.  */
+#define VX(op, xop) (OP (op) | ((((unsigned long)(xop)) & 0x7ff)))
+
+/* An VX form instruction with the RC bit specified.  */
+#define VXRC(op, xop, rc) (VX ((op), (xop)) | (((rc) & 1)<<10))
+
+/* The mask for a VX form instruction.  */
+/* Was VXRC based, but the RC bit is a don't care in our decode */
+/* I don't understand why X_MASK is based on XRC with 3 parms.  */
+#define VX_MASK VX (0x3f, 0x7ff)
+#define VXRC_MASK VX_MASK
+
+/* A VX_MASK with the VA field fixed.  */
+#define VXVA_MASK (VX_MASK | VRA_MASK)
+
+/* A VX_MASK with the VB field fixed.  */
+#define VXVB_MASK (VX_MASK | VRB_MASK)
+
+/* A VX_MASK with the RT field fixed.  */
+#define VXVT_MASK (VX_MASK | VRT_MASK)
+
+/* A VX_MASK with the VA and VB fields fixed.  */
+#define VXVAVB_MASK (VX_MASK | VRA_MASK | VRB_MASK)
+
+/* A VX_MASK with the VT and VA fields fixed.  */
+#define VXVTVA_MASK (VX_MASK | VRT_MASK | VRA_MASK)
+
+/* An XV form instruction.  */
+#define XV(op, xop, zz) \
+  (OP (op) | ((((unsigned long)(xop)) & 0x3ff) << 1) | ((((unsigned long)(zz)) & 1) << 25))
+#define XV_MASK XV (0x3f, 0x3ff, 1)
+
+/* An XV_MASK with the RA and RB fields fixed.  */
+#define XVRARB_MASK (XV_MASK | RA_MASK | RB_MASK)
+
+/* An XV_MASK with the RA, RB and TAG fields fixed.  */
+#define XVRARBTG_MASK (XV_MASK | RA_MASK | RB_MASK | TAG_MASK)
+
 /* An M form instruction.  */
 #define M(op, rc) (OP (op) | ((rc) & 1))
 #define M_MASK M (0x3f, 1)
@@ -1234,6 +1321,8 @@
 #define BODNZ	(0x10)
 #define BODNZP	(0x11)
 #define BODZ	(0x12)
+#define PPCVEC	PPC_OPCODE_VEC | PPC_OPCODE_ANY
+#define	VEC	PPCVEC
 #define BODZP	(0x13)
 #define BOU	(0x14)
 
@@ -1314,6 +1403,164 @@
 { "tdnli",   OPTO(2,TONL), OPTO_MASK,	PPC64,		{ RA, SI } },
 { "tdlti",   OPTO(2,TOLT), OPTO_MASK,	PPC64,		{ RA, SI } },
 { "tdlei",   OPTO(2,TOLE), OPTO_MASK,	PPC64,		{ RA, SI } },
+{ "vaddubm",    VX(4,0),        VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxub",     VX(4,2),        VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrlb",       VX(4,4),        VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpequb",   VXRC(4,6,0),    VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpequb.",  VXRC(4,6,1),    VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmuloub",    VX(4,8),        VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vaddfp",     VX(4,10),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmrghb",     VX(4,12),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vpkuhum",    VX(4,14),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmhaddshs",  VA(4,32),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmhraddshs", VA(4,33),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmladduhm",  VA(4,34),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmsumubm",   VA(4,36),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmsummbm",   VA(4,37),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmsumuhm",   VA(4,38),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmsumuhs",   VA(4,39),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmsumshm",   VA(4,40),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vmsumshs",   VA(4,41),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vsel",       VA(4,42),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vperm",      VA(4,43),       VA_MASK,      VEC,  { VRT, VRA, VRB, VRC } },
+{ "vsldoi",     VA(4,44),       VA_MASK,      VEC,  { VRT, VRA, VRB, VSH } },
+{ "vmaddfp",    VA(4,46),       VA_MASK,      VEC,  { VRT, VRA, VRC, VRB } },
+{ "vnmsubfp",   VA(4,47),       VA_MASK,      VEC,  { VRT, VRA, VRC, VRB } },
+{ "vadduhm",    VX(4,64),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxuh",     VX(4,66),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrlh",       VX(4,68),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpequh",   VXRC(4,70,0),   VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpequh.",  VXRC(4,70,1),   VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmulouh",    VX(4,72),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubfp",     VX(4,74),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmrghh",     VX(4,76),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vpkuwum",    VX(4,78),       VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vadduwm",    VX(4,128),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxuw",     VX(4,130),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrlw",       VX(4,132),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpequw",   VXRC(4,134,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpequw.",  VXRC(4,134,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmrghw",     VX(4,140),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vpkuhus",    VX(4,142),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpeqfp",   VXRC(4,198,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpeqfp.",  VXRC(4,198,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vpkuwus",    VX(4,206),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxsb",     VX(4,258),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vslb",       VX(4,260),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmulosb",    VX(4,264),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrefp",      VX(4,266),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vmrglb",     VX(4,268),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vpkshus",    VX(4,270),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxsh",     VX(4,322),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vslh",       VX(4,324),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmulosh",    VX(4,328),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrsqrtefp",  VX(4,330),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vmrglh",     VX(4,332),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vpkswus",    VX(4,334),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vaddcuw",    VX(4,384),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxsw",     VX(4,386),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vslw",       VX(4,388),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vexptefp",   VX(4,394),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vmrglw",     VX(4,396),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vpkshss",    VX(4,398),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsl",        VX(4,452),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgefp",   VXRC(4,454,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgefp.",  VXRC(4,454,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vlogefp",    VX(4,458),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vpkswss",    VX(4,462),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vaddubs",    VX(4,512),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminub",     VX(4,514),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsrb",       VX(4,516),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtub",   VXRC(4,518,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtub.",  VXRC(4,518,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmuleub",    VX(4,520),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrfin",      VX(4,522),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vspltb",     VX(4,524),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vupkhsb",    VX(4,526),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vadduhs",    VX(4,576),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminuh",     VX(4,578),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsrh",       VX(4,580),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtuh",   VXRC(4,582,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtuh.",  VXRC(4,582,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmuleuh",    VX(4,584),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vrfiz",      VX(4,586),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vsplth",     VX(4,588),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vupkhsh",    VX(4,590),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vadduws",    VX(4,640),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminuw",     VX(4,642),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsrw",       VX(4,644),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtuw",   VXRC(4,646,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtuw.",  VXRC(4,646,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vrfip",      VX(4,650),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vspltw",     VX(4,652),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vupklsb",    VX(4,654),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vsr",        VX(4,708),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtfp",   VXRC(4,710,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtfp.",  VXRC(4,710,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vrfim",      VX(4,714),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vupklsh",    VX(4,718),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vaddsbs",    VX(4,768),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminsb",     VX(4,770),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsrab",      VX(4,772),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtsb",   VXRC(4,774,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtsb.",  VXRC(4,774,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmulesb",    VX(4,776),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcfux",      VX(4,778),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vspltisb",   VX(4,780),      VXVB_MASK,    VEC,  { VRT, VSI } },
+{ "vpkpx",      VX(4,782),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vaddshs",    VX(4,832),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminsh",     VX(4,834),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsrah",      VX(4,836),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtsh",   VXRC(4,838,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtsh.",  VXRC(4,838,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vmulesh",    VX(4,840),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcfsx",      VX(4,842),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vspltish",   VX(4,844),      VXVB_MASK,    VEC,  { VRT, VSI } },
+{ "vupkhpx",    VX(4,846),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vaddsws",    VX(4,896),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminsw",     VX(4,898),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsraw",      VX(4,900),      VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtsw",   VXRC(4,902,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpgtsw.",  VXRC(4,902,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vctuxs",     VX(4,906),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vspltisw",   VX(4,908),      VXVB_MASK,    VEC,  { VRT, VSI } },
+{ "vcmpbfp",    VXRC(4,966,0),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vcmpbfp.",   VXRC(4,966,1),  VXRC_MASK,    VEC,  { VRT, VRA, VRB } },
+{ "vctsxs",     VX(4,970),      VX_MASK,      VEC,  { VRT, VRB, VUI } },
+{ "vupklpx",    VX(4,974),      VXVA_MASK,    VEC,  { VRT, VRB } },
+{ "vsububm",    VX(4,1024),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vavgub",     VX(4,1026),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vand",       VX(4,1028),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vmaxfp",     VX(4,1034),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vslo",       VX(4,1036),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubuhm",    VX(4,1088),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vavguh",     VX(4,1090),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vandc",      VX(4,1092),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vminfp",     VX(4,1098),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsro",       VX(4,1100),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubuwm",    VX(4,1152),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vavguw",     VX(4,1154),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vor",        VX(4,1156),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vxor",       VX(4,1220),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vavgsb",     VX(4,1282),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vnor",       VX(4,1284),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vavgsh",     VX(4,1346),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubcuw",    VX(4,1408),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vavgsw",     VX(4,1410),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsububs",    VX(4,1536),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "mfvscr",     VX(4,1540),     VXVAVB_MASK,  VEC,  { VRT } },
+{ "vsum4ubs",   VX(4,1544),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubuhs",    VX(4,1600),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "mtvscr",     VX(4,1604),     VXVTVA_MASK,  VEC,  { VRB } },
+{ "vsum4shs",   VX(4,1608),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubuws",    VX(4,1664),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsum2sws",   VX(4,1672),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubsbs",    VX(4,1792),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsum4sbs",   VX(4,1800),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubshs",    VX(4,1856),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsubsws",    VX(4,1920),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+{ "vsumsws",    VX(4,1928),     VX_MASK,      VEC,  { VRT, VRA, VRB } },
+
 { "tdngi",   OPTO(2,TONG), OPTO_MASK,	PPC64,		{ RA, SI } },
 { "tdnei",   OPTO(2,TONE), OPTO_MASK,	PPC64,		{ RA, SI } },
 { "tdi",     OP(2),	OP_MASK,	PPC64,		{ TO, RA, SI } },
@@ -2016,6 +2263,9 @@
 
 { "cmpw",    XCMPL(31,0,0), XCMPL_MASK, PPCCOM,		{ OBF, RA, RB } },
 { "cmpd",    XCMPL(31,0,1), XCMPL_MASK, PPC64,		{ OBF, RA, RB } },
+{ "lvsl",    X(31,6),   X_MASK,         VEC,           { VRT, RA, RB } },
+{ "lvebx",   X(31,7),   X_MASK,         VEC,           { VRT, RA, RB } },
+
 { "cmp",     X(31,0),	XCMP_MASK,	PPCONLY,	{ BF, L, RA, RB } },
 { "cmp",     X(31,0),	XCMPL_MASK,	PWRCOM,		{ BF, RA, RB } },
 
@@ -2077,6 +2327,9 @@
 { "ao.",     XO(31,10,1,1), XO_MASK,	PWRCOM,		{ RT, RA, RB } },
 
 { "mulhwu",  XO(31,11,0,0), XO_MASK,	PPC,		{ RT, RA, RB } },
+{ "lvsr",    X(31,38),  X_MASK,         VEC,           { VRT, RA, RB } },
+{ "lvehx",   X(31,39),  X_MASK,         VEC,           { VRT, RA, RB } },
+
 { "mulhwu.", XO(31,11,0,1), XO_MASK,	PPC,		{ RT, RA, RB } },
 
 { "mfcr",    X(31,19),	XRARB_MASK,	COM,		{ RT } },
@@ -2115,6 +2368,8 @@
 { "subf",    XO(31,40,0,0), XO_MASK,	PPC,		{ RT, RA, RB } },
 { "sub",     XO(31,40,0,0), XO_MASK,	PPC,		{ RT, RB, RA } },
 { "subf.",   XO(31,40,0,1), XO_MASK,	PPC,		{ RT, RA, RB } },
+{ "lvewx",   X(31,71),  X_MASK,         VEC,           { VRT, RA, RB } },
+
 { "sub.",    XO(31,40,0,1), XO_MASK,	PPC,		{ RT, RB, RA } },
 { "subfo",   XO(31,40,1,0), XO_MASK,	PPC,		{ RT, RA, RB } },
 { "subo",    XO(31,40,1,0), XO_MASK,	PPC,		{ RT, RB, RA } },
@@ -2129,6 +2384,8 @@
 { "lux",     X(31,55),	X_MASK,		PWRCOM,		{ RT, RA, RB } },
 
 { "cntlzd",  XRC(31,58,0), XRB_MASK,	PPC64,		{ RA, RS } },
+{ "lvx",     X(31,103), X_MASK,         VEC,           { VRT, RA, RB } },
+
 { "cntlzd.", XRC(31,58,1), XRB_MASK,	PPC64,		{ RA, RS } },
 
 { "andc",    XRC(31,60,0), X_MASK,	COM,	{ RA, RS, RB } },
@@ -2150,6 +2407,8 @@
 { "tdne",    XTO(31,68,TONE), XTO_MASK,  PPC64,		{ RA, RB } },
 { "td",	     X(31,68),	X_MASK,		 PPC64,		{ TO, RA, RB } },
 
+{ "stvebx",  X(31,135), X_MASK,         VEC,           { VRS, RA, RB } },
+
 { "mulhd",   XO(31,73,0,0), XO_MASK,	 PPC64,		{ RT, RA, RB } },
 { "mulhd.",  XO(31,73,0,1), XO_MASK,	 PPC64,		{ RT, RA, RB } },
 
@@ -2188,6 +2447,8 @@
 { "subfe",   XO(31,136,0,0), XO_MASK,	PPCCOM,		{ RT, RA, RB } },
 { "sfe",     XO(31,136,0,0), XO_MASK,	PWRCOM,		{ RT, RA, RB } },
 { "subfe.",  XO(31,136,0,1), XO_MASK,	PPCCOM,		{ RT, RA, RB } },
+{ "stvehx",  X(31,167), X_MASK,         VEC,           { VRS, RA, RB } },
+
 { "sfe.",    XO(31,136,0,1), XO_MASK,	PWRCOM,		{ RT, RA, RB } },
 { "subfeo",  XO(31,136,1,0), XO_MASK,	PPCCOM,		{ RT, RA, RB } },
 { "sfeo",    XO(31,136,1,0), XO_MASK,	PWRCOM,		{ RT, RA, RB } },
@@ -2196,6 +2457,8 @@
 
 { "adde",    XO(31,138,0,0), XO_MASK,	PPCCOM,		{ RT, RA, RB } },
 { "ae",      XO(31,138,0,0), XO_MASK,	PWRCOM,		{ RT, RA, RB } },
+{ "stvewx",  X(31,199), X_MASK,         VEC,           { VRS, RA, RB } },
+
 { "adde.",   XO(31,138,0,1), XO_MASK,	PPCCOM,		{ RT, RA, RB } },
 { "ae.",     XO(31,138,0,1), XO_MASK,	PWRCOM,		{ RT, RA, RB } },
 { "addeo",   XO(31,138,1,0), XO_MASK,	PPCCOM,		{ RT, RA, RB } },
@@ -2226,6 +2489,8 @@
 { "stdux",   X(31,181),	X_MASK,		PPC64,		{ RS, RAS, RB } },
 
 { "stwux",   X(31,183),	X_MASK,		PPCCOM,		{ RS, RAS, RB } },
+{ "stvx",    X(31,231), X_MASK,         VEC,           { VRS, RA, RB } },
+
 { "stux",    X(31,183),	X_MASK,		PWRCOM,		{ RS, RA, RB } },
 
 { "sliq",    XRC(31,184,0), X_MASK,	M601,		{ RA, RS, SH } },
@@ -2447,6 +2712,8 @@
 { "mfm_tw",   XSPR(31,339,799), XSPR_MASK, PPC860,	{ RT } },
 { "mfmi_dbcam",XSPR(31,339,816), XSPR_MASK, PPC860,	{ RT } },
 { "mfmi_dbram0",XSPR(31,339,817), XSPR_MASK, PPC860,	{ RT } },
+{ "lvxl",    X(31,359), X_MASK,         VEC,           { VRT, RA, RB } },
+
 { "mfmi_dbram1",XSPR(31,339,818), XSPR_MASK, PPC860,	{ RT } },
 { "mfmd_dbcam", XSPR(31,339,824), XSPR_MASK, PPC860,	{ RT } },
 { "mfmd_dbram0",XSPR(31,339,825), XSPR_MASK, PPC860,	{ RT } },
@@ -2613,6 +2880,8 @@
 { "divwu.",  XO(31,459,0,1), XO_MASK,	PPC,		{ RT, RA, RB } },
 { "divwuo",  XO(31,459,1,0), XO_MASK,	PPC,		{ RT, RA, RB } },
 { "divwuo.", XO(31,459,1,1), XO_MASK,	PPC,		{ RT, RA, RB } },
+{ "stvxl",   X(31,487), X_MASK,         VEC,           { VRS, RA, RB } },
+
 
 { "mtmq",    XSPR(31,467,0),   XSPR_MASK,    M601,	{ RS } },
 { "mtxer",   XSPR(31,467,1),   XSPR_MASK,    COM,	{ RS } },
@@ -2771,6 +3040,14 @@
 { "sre",     XRC(31,665,0), X_MASK,	M601,		{ RA, RS, RB } },
 { "sre.",    XRC(31,665,1), X_MASK,	M601,		{ RA, RS, RB } },
 
+{ "dst",     XV(31,342,0), XV_MASK,     VEC,           { RA, RB, TAG } },
+{ "dstt",    XV(31,342,1), XV_MASK,     VEC,           { RA, RB, TAG } },
+{ "dstst",   XV(31,374,0), XV_MASK,     VEC,           { RA, RB, TAG } },
+{ "dststt",  XV(31,374,1), XV_MASK,     VEC,           { RA, RB, TAG } },
+
+{ "dss",     XV(31,822,0), XVRARB_MASK, VEC,           { TAG } },
+{ "dssall",  XV(31,822,1), XVRARBTG_MASK, VEC,         { 0 } },
+
 { "stfsux",  X(31,695),	X_MASK,		COM,		{ FRS, RAS, RB } },
 
 { "sriq",    XRC(31,696,0), X_MASK,	M601,		{ RA, RS, SH } },
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/package.qpg binutils/package.qpg
--- binutils-2.10.1/package.qpg	1970-01-01 10:00:00.000000000 +1000
+++ binutils/package.qpg	2001-05-08 22:28:56.000000000 +1000
@@ -0,0 +1,307 @@
+<QPG:Generation>
+   <QPG:Owner file="owner.qpg"/>
+   <QPG:Values>
+      <QPG:Files>
+<!-- All binaries and shared objects that need pinfo files -->
+<QPG:Add file="nto/all/bfd/.libs/libbfd-2.10.1.so" pinfo="libbfd-2.10.1.so.pinfo" target="none" proc="x86" filetype="so" />
+<QPG:Add file="nto/all/opcodes/.libs/libopcodes-2.10.1.so" pinfo="libopcodes-2.10.1.so.pinfo" target="none" proc="x86" filetype="so" />
+<QPG:Add file="nto/all/binutils/.libs/size" pinfo="size.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/objdump" pinfo="objdump.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/ar" pinfo="ar.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/strings" pinfo="strings.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/ranlib" pinfo="ranlib.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/objcopy" pinfo="objcopy.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/addr2line" pinfo="addr2line.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/nm-new" pinfo="nm-new.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/readelf" pinfo="readelf.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/.libs/strip-new" pinfo="strip-new.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/binutils/cxxfilt" pinfo="cxxfilt.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/gas/.libs/as-new" pinfo="as-new.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/gas-ntoarm/.libs/as-new" pinfo="as-new.pinfo" target="arm" proc="x86" />
+<QPG:Add file="nto/all/gas-ntoppc/.libs/as-new" pinfo="as-new.pinfo"  target="ppc" proc="x86" />
+<QPG:Add file="nto/all/gas-ntomips/.libs/as-new" pinfo="as-new.pinfo" target="mips" proc="x86" />
+<QPG:Add file="nto/all/gas-ntosh/.libs/as-new" pinfo="as-new.pinfo" target="sh" proc="x86" />
+<QPG:Add file="nto/all/gas/gasp-new" pinfo="gasp-new.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/gprof/.libs/gprof" pinfo="gprof.pinfo" target="none" proc="x86" />
+<QPG:Add file="nto/all/ld/.libs/ld-new" pinfo="ld-new.pinfo" target="none" proc="x86" />
+
+<!-- Next, all real files -->
+<QPG:Add file="nto/ntosh/gprof/gprof" install="/usr/bin/ntosh-gprof" target="none" proc="x86" /> 
+<QPG:Add file="nto/all/bfd/libbfd.la" install="/usr/lib/" target="none" proc="x86" />
+<QPG:Add file="nto/all/bfd/.libs/libbfd.a" install="/usr/lib/" target="none" proc="x86" />
+<QPG:Add file="nto/all/opcodes/libopcodes.la" install="/usr/lib/" target="none" proc="x86" />
+<QPG:Add file="nto/all/opcodes/.libs/libopcodes.a" install="/usr/lib/" target="none" proc="x86" />
+<QPG:Add file="nto/all/libiberty/libiberty.a" install="/usr/lib/" target="none" proc="x86" />
+<QPG:Add file="nto/all/bfd/bfd.h" install="/usr/include/" target="none" proc="x86" />
+<QPG:Add file="include/ansidecl.h" install="/usr/include/" target="none" proc="x86" />
+<QPG:Add file="include/bfdlink.h" install="/usr/include/" target="none" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/armnto.x" install="/usr/ntox86/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/armnto.xbn" install="/usr/ntox86/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/armnto.xn" install="/usr/ntox86/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/armnto.xr" install="/usr/ntox86/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/armnto.xs" install="/usr/ntox86/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/armnto.xu" install="/usr/ntox86/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32bmipnto.x" install="/usr/ntox86/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32bmipnto.xbn" install="/usr/ntox86/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32bmipnto.xn" install="/usr/ntox86/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32bmipnto.xr" install="/usr/ntox86/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32bmipnto.xs" install="/usr/ntox86/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32bmipnto.xu" install="/usr/ntox86/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32ppcnto.x" install="/usr/ntox86/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32ppcnto.xbn" install="/usr/ntox86/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32ppcnto.xn" install="/usr/ntox86/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32ppcnto.xr" install="/usr/ntox86/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32ppcnto.xs" install="/usr/ntox86/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/elf32ppcnto.xu" install="/usr/ntox86/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/i386nto.x" install="/usr/ntox86/lib/ldscripts/" target="x86" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/i386nto.xbn" install="/usr/ntox86/lib/ldscripts/" target="x86" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/i386nto.xn" install="/usr/ntox86/lib/ldscripts/" target="x86" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/i386nto.xr" install="/usr/ntox86/lib/ldscripts/" target="x86" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/i386nto.xs" install="/usr/ntox86/lib/ldscripts/" target="x86" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/i386nto.xu" install="/usr/ntox86/lib/ldscripts/" target="x86" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shelf_nto.x" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shelf_nto.xbn" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shelf_nto.xn" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shelf_nto.xr" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shelf_nto.xs" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shelf_nto.xu" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shlelf_nto.x" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shlelf_nto.xbn" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shlelf_nto.xn" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shlelf_nto.xr" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shlelf_nto.xs" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/all/ld/ldscripts/shlelf_nto.xu" install="/usr/ntox86/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="binutils/ar.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/nm.1" install="/usr/man/man1/ "target="none" proc="none" />
+<QPG:Add file="binutils/objdump.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/ranlib.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/size.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/strings.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/strip.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/objcopy.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/addr2line.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="binutils/nlmconv.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="nto/ntox86/binutils/c++filt.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="gas/doc/as.1" install="/usr/man/man1/" target="none" proc="none" />
+<QPG:Add file="gprof/gprof.1" install="/usr/man/man1/ "target="none" proc="none" />
+<QPG:Add file="ld/ld.1" install="/usr/man/man1/" target="none" proc="none" />
+
+<QPG:Add file="nto/ntoarm/ld/ldscripts/armnto.xr" install="/usr/ntoarm/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/ntoarm/ld/ldscripts/armnto.xu" install="/usr/ntoarm/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/ntoarm/ld/ldscripts/armnto.x" install="/usr/ntoarm/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/ntoarm/ld/ldscripts/armnto.xn" install="/usr/ntoarm/lib/ldscripts/"target="arm" proc="x86"  />
+<QPG:Add file="nto/ntoarm/ld/ldscripts/armnto.xbn" install="/usr/ntoarm/lib/ldscripts/" target="arm" proc="x86" />
+<QPG:Add file="nto/ntoarm/ld/ldscripts/armnto.xs" install="/usr/ntoarm/lib/ldscripts/" target="arm" proc="x86"  />
+
+<QPG:Add file="nto/ntoppc/ld/ldscripts/elf32ppcnto.xr" install="/usr/ntoppc/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/ntoppc/ld/ldscripts/elf32ppcnto.xu" install="/usr/ntoppc/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/ntoppc/ld/ldscripts/elf32ppcnto.x" install="/usr/ntoppc/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/ntoppc/ld/ldscripts/elf32ppcnto.xn" install="/usr/ntoppc/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/ntoppc/ld/ldscripts/elf32ppcnto.xbn" install="/usr/ntoppc/lib/ldscripts/" target="ppc" proc="x86" />
+<QPG:Add file="nto/ntoppc/ld/ldscripts/elf32ppcnto.xs" install="/usr/ntoppc/lib/ldscripts/" target="ppc" proc="x86" />
+
+<QPG:Add file="nto/ntomips/ld/ldscripts/elf32bmipnto.xr" install="/usr/ntomips/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/ntomips/ld/ldscripts/elf32bmipnto.xu" install="/usr/ntomips/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/ntomips/ld/ldscripts/elf32bmipnto.x" install="/usr/ntomips/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/ntomips/ld/ldscripts/elf32bmipnto.xn" install="/usr/ntomips/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/ntomips/ld/ldscripts/elf32bmipnto.xbn" install="/usr/ntomips/lib/ldscripts/" target="mips" proc="x86" />
+<QPG:Add file="nto/ntomips/ld/ldscripts/elf32bmipnto.xs" install="/usr/ntomips/lib/ldscripts/" target="mips" proc="x86" />
+
+<QPG:Add file="nto/ntosh/ld/ldscripts/shelf_nto.xr" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shelf_nto.xu" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shelf_nto.x" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shelf_nto.xn" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shelf_nto.xbn" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shelf_nto.xs" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shlelf_nto.xr" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shlelf_nto.xu" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shlelf_nto.x" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shlelf_nto.xn" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shlelf_nto.xbn" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="nto/ntosh/ld/ldscripts/shlelf_nto.xs" install="/usr/ntosh/lib/ldscripts/" target="sh" proc="x86" />
+<QPG:Add file="oldmipsld/ld" install="/usr/ntomips/bin/ld" target="mips" proc="x86" />
+<QPG:Add file="ntomips-ld" install="/usr/bin/" filetype="symlink" linkto="../ntomips/bin/ld" target="mips" proc="x86" />
+
+<!-- Last, all symbolic links -->
+<QPG:Add file="ntosh-gprof.1" install="/usr/man/man1/" filetype="symlink" linkto="gprof.1" target="none" proc="none" />
+
+<QPG:Add file="nm" install="/usr/ntox86/bin/" filetype="symlink" linkto="../../bin/nm" target="x86" proc="x86" />
+<QPG:Add file="strip" install="/usr/ntox86/bin/" filetype="symlink" linkto="../../bin/strip" target="x86" proc="x86" />
+<QPG:Add file="ar" install="/usr/ntox86/bin/" filetype="symlink" linkto="../../bin/ar" target="x86" proc="x86" />
+<QPG:Add file="ranlib" install="/usr/ntox86/bin/" filetype="symlink" linkto="../../bin/ranlib" target="x86" proc="x86" />
+<QPG:Add file="as" install="/usr/ntox86/bin/" filetype="symlink" linkto="../../bin/as" target="x86" proc="x86" />
+<QPG:Add file="ld" install="/usr/ntox86/bin/" filetype="symlink" linkto="../../bin/ld" target="x86" proc="x86" />
+<QPG:Add file="ntox86-nm" install="/usr/bin/" filetype="symlink" linkto="nm" target="x86" proc="x86" />
+<QPG:Add file="ntox86-strip" install="/usr/bin/" filetype="symlink" linkto="strip" target="x86" proc="x86" />
+<QPG:Add file="ntox86-ar" install="/usr/bin/" filetype="symlink" linkto="ar" target="x86" proc="x86" />
+<QPG:Add file="ntox86-ranlib" install="/usr/bin/" filetype="symlink" linkto="ranlib" target="x86" proc="x86" />
+<QPG:Add file="ntox86-as" install="/usr/bin/" filetype="symlink" linkto="as" target="x86" proc="x86" />
+<QPG:Add file="ntox86-ld" install="/usr/bin/" filetype="symlink" linkto="ld" target="x86" proc="x86" />
+<QPG:Add file="ntox86-size" install="/usr/bin/" filetype="symlink" linkto="size" target="x86" proc="x86" />
+<QPG:Add file="ntox86-objdump" install="/usr/bin/" filetype="symlink" linkto="objdump" target="x86" proc="x86" />
+<QPG:Add file="ntox86-strings" install="/usr/bin/" filetype="symlink" linkto="strings" target="x86" proc="x86" />
+<QPG:Add file="ntox86-objcopy" install="/usr/bin/" filetype="symlink" linkto="objcopy" target="x86" proc="x86" />
+<QPG:Add file="ntox86-addr2line" install="/usr/bin/" filetype="symlink" linkto="addr2line" target="x86" proc="x86" />
+<QPG:Add file="ntox86-readelf" install="/usr/bin/" filetype="symlink" linkto="readelf" target="x86" proc="x86" />
+<QPG:Add file="ntox86-c++filt" install="/usr/bin/" filetype="symlink" linkto="c++filt" target="x86" proc="x86" />
+<QPG:Add file="ntox86-gasp" install="/usr/bin/" filetype="symlink" linkto="gasp" target="x86" proc="x86" />
+
+<QPG:Add file="nm" install="/usr/ntomips/bin/" filetype="symlink" linkto="../../bin/nm" target="mips" proc="x86" />
+<QPG:Add file="strip" install="/usr/ntomips/bin/" filetype="symlink" linkto="../../bin/strip" target="mips" proc="x86" />
+<QPG:Add file="ar" install="/usr/ntomips/bin/" filetype="symlink" linkto="../../bin/ar" target="mips" proc="x86" />
+<QPG:Add file="ranlib" install="/usr/ntomips/bin/" filetype="symlink" linkto="../../bin/ranlib" target="mips" proc="x86" />
+<QPG:Add file="as" install="/usr/ntomips/bin/" filetype="symlink" linkto="../../bin/ntomips-as" target="mips" proc="x86" />
+<!-- QPG:Add file="ld" install="/usr/ntomips/bin/" filetype="symlink" linkto="../../bin/ld" target="mips" proc="x86" / -->
+<QPG:Add file="ntomips-nm" install="/usr/bin/" filetype="symlink" linkto="nm" target="mips" proc="x86" />
+<QPG:Add file="ntomips-strip" install="/usr/bin/" filetype="symlink" linkto="strip" target="mips" proc="x86" />
+<QPG:Add file="ntomips-ar" install="/usr/bin/" filetype="symlink" linkto="ar" target="mips" proc="x86" />
+<QPG:Add file="ntomips-ranlib" install="/usr/bin/" filetype="symlink" linkto="ranlib" target="mips" proc="x86" />
+<!-- QPG:Add file="ntomips-ld" install="/usr/bin/" filetype="symlink" linkto="ld" target="mips" proc="x86" / -->
+<QPG:Add file="ntomips-size" install="/usr/bin/" filetype="symlink" linkto="size" target="mips" proc="x86" />
+<QPG:Add file="ntomips-objdump" install="/usr/bin/" filetype="symlink" linkto="objdump" target="mips" proc="x86" />
+<QPG:Add file="ntomips-strings" install="/usr/bin/" filetype="symlink" linkto="strings" target="mips" proc="x86" />
+<QPG:Add file="ntomips-objcopy" install="/usr/bin/" filetype="symlink" linkto="objcopy" target="mips" proc="x86" />
+<QPG:Add file="ntomips-addr2line" install="/usr/bin/" filetype="symlink" linkto="addr2line" target="mips" proc="x86" />
+<QPG:Add file="ntomips-readelf" install="/usr/bin/" filetype="symlink" linkto="readelf" target="mips" proc="x86" />
+<QPG:Add file="ntomips-c++filt" install="/usr/bin/" filetype="symlink" linkto="c++filt" target="mips" proc="x86" />
+<QPG:Add file="ntomips-gasp" install="/usr/bin/" filetype="symlink" linkto="gasp" target="mips" proc="x86" />
+
+<QPG:Add file="nm" install="/usr/ntoppc/bin/" filetype="symlink" linkto="../../bin/nm" target="ppc" proc="x86" />
+<QPG:Add file="strip" install="/usr/ntoppc/bin/" filetype="symlink" linkto="../../bin/strip" target="ppc" proc="x86" />
+<QPG:Add file="ar" install="/usr/ntoppc/bin/" filetype="symlink" linkto="../../bin/ar" target="ppc" proc="x86" />
+<QPG:Add file="ranlib" install="/usr/ntoppc/bin/" filetype="symlink" linkto="../../bin/ranlib" target="ppc" proc="x86" />
+<QPG:Add file="as" install="/usr/ntoppc/bin/" filetype="symlink" linkto="../../bin/ntoppc-as" target="ppc" proc="x86" />
+<QPG:Add file="ld" install="/usr/ntoppc/bin/" filetype="symlink" linkto="../../bin/ld" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-nm" install="/usr/bin/" filetype="symlink" linkto="nm" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-strip" install="/usr/bin/" filetype="symlink" linkto="strip" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-ar" install="/usr/bin/" filetype="symlink" linkto="ar" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-ranlib" install="/usr/bin/" filetype="symlink" linkto="ranlib" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-ld" install="/usr/bin/" filetype="symlink" linkto="ld" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-size" install="/usr/bin/" filetype="symlink" linkto="size" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-objdump" install="/usr/bin/" filetype="symlink" linkto="objdump" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-strings" install="/usr/bin/" filetype="symlink" linkto="strings" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-objcopy" install="/usr/bin/" filetype="symlink" linkto="objcopy" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-addr2line" install="/usr/bin/" filetype="symlink" linkto="addr2line" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-readelf" install="/usr/bin/" filetype="symlink" linkto="readelf" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-c++filt" install="/usr/bin/" filetype="symlink" linkto="c++filt" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-gasp" install="/usr/bin/" filetype="symlink" linkto="gasp" target="ppc" proc="x86" />
+
+<QPG:Add file="nm" install="/usr/ntoarm/bin/" filetype="symlink" linkto="../../bin/nm" target="arm" proc="x86" />
+<QPG:Add file="strip" install="/usr/ntoarm/bin/" filetype="symlink" linkto="../../bin/strip" target="arm" proc="x86" />
+<QPG:Add file="ar" install="/usr/ntoarm/bin/" filetype="symlink" linkto="../../bin/ar" target="arm" proc="x86" />
+<QPG:Add file="ranlib" install="/usr/ntoarm/bin/" filetype="symlink" linkto="../../bin/ranlib" target="arm" proc="x86" />
+<QPG:Add file="as" install="/usr/ntoarm/bin/" filetype="symlink" linkto="../../bin/ntoarm-as" target="arm" proc="x86" />
+<QPG:Add file="ld" install="/usr/ntoarm/bin/" filetype="symlink" linkto="../../bin/ld" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-nm" install="/usr/bin/" filetype="symlink" linkto="nm" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-strip" install="/usr/bin/" filetype="symlink" linkto="strip" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-ar" install="/usr/bin/" filetype="symlink" linkto="ar" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-ranlib" install="/usr/bin/" filetype="symlink" linkto="ranlib" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-ld" install="/usr/bin/" filetype="symlink" linkto="ld" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-size" install="/usr/bin/" filetype="symlink" linkto="size" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-objdump" install="/usr/bin/" filetype="symlink" linkto="objdump" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-strings" install="/usr/bin/" filetype="symlink" linkto="strings" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-objcopy" install="/usr/bin/" filetype="symlink" linkto="objcopy" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-addr2line" install="/usr/bin/" filetype="symlink" linkto="addr2line" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-readelf" install="/usr/bin/" filetype="symlink" linkto="readelf" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-c++filt" install="/usr/bin/" filetype="symlink" linkto="c++filt" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-gasp" install="/usr/bin/" filetype="symlink" linkto="gasp" target="arm" proc="x86" />
+
+<QPG:Add file="nm" install="/usr/ntosh/bin/" filetype="symlink" linkto="../../bin/nm" target="sh" proc="x86" />
+<QPG:Add file="strip" install="/usr/ntosh/bin/" filetype="symlink" linkto="../../bin/strip" target="sh" proc="x86" />
+<QPG:Add file="ar" install="/usr/ntosh/bin/" filetype="symlink" linkto="../../bin/ar" target="sh" proc="x86" />
+<QPG:Add file="ranlib" install="/usr/ntosh/bin/" filetype="symlink" linkto="../../bin/ranlib" target="sh" proc="x86" />
+<QPG:Add file="as" install="/usr/ntosh/bin/" filetype="symlink" linkto="../../bin/ntosh-as" target="sh" proc="x86" />
+<QPG:Add file="ld" install="/usr/ntosh/bin/" filetype="symlink" linkto="../../bin/ld" target="sh" proc="x86" />
+<QPG:Add file="ntosh-nm" install="/usr/bin/" filetype="symlink" linkto="nm" target="sh" proc="x86" />
+<QPG:Add file="ntosh-strip" install="/usr/bin/" filetype="symlink" linkto="strip" target="sh" proc="x86" />
+<QPG:Add file="ntosh-ar" install="/usr/bin/" filetype="symlink" linkto="ar" target="sh" proc="x86" />
+<QPG:Add file="ntosh-ranlib" install="/usr/bin/" filetype="symlink" linkto="ranlib" target="sh" proc="x86" />
+<QPG:Add file="ntosh-ld" install="/usr/bin/" filetype="symlink" linkto="ld" target="sh" proc="x86" />
+<QPG:Add file="ntosh-size" install="/usr/bin/" filetype="symlink" linkto="size" target="sh" proc="x86" />
+<QPG:Add file="ntosh-objdump" install="/usr/bin/" filetype="symlink" linkto="objdump" target="sh" proc="x86" />
+<QPG:Add file="ntosh-strings" install="/usr/bin/" filetype="symlink" linkto="strings" target="sh" proc="x86" />
+<QPG:Add file="ntosh-objcopy" install="/usr/bin/" filetype="symlink" linkto="objcopy" target="sh" proc="x86" />
+<QPG:Add file="ntosh-addr2line" install="/usr/bin/" filetype="symlink" linkto="addr2line" target="sh" proc="x86" />
+<QPG:Add file="ntosh-readelf" install="/usr/bin/" filetype="symlink" linkto="readelf" target="sh" proc="x86" />
+<QPG:Add file="ntosh-c++filt" install="/usr/bin/" filetype="symlink" linkto="c++filt" target="sh" proc="x86" />
+<QPG:Add file="ntosh-gasp" install="/usr/bin/" filetype="symlink" linkto="gasp" target="sh" proc="x86" />
+
+<!-- Man Pages Links -->
+
+<QPG:Add file="ntox86-ar.1" install="/usr/man/man1/" filetype="symlink" linkto="ar.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-nm.1" install="/usr/man/man1/" filetype="symlink" linkto="nm.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-objdump.1" install="/usr/man/man1/" filetype="symlink" linkto="objdump.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-ranlib.1" install="/usr/man/man1/" filetype="symlink" linkto="ranlib.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-size.1" install="/usr/man/man1/" filetype="symlink" linkto="size.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-strings.1" install="/usr/man/man1/" filetype="symlink" linkto="strings.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-strip.1" install="/usr/man/man1/" filetype="symlink" linkto="strip.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-objcopy.1" install="/usr/man/man1/" filetype="symlink" linkto="objcopy.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-addr2line.1" install="/usr/man/man1/" filetype="symlink" linkto="addr2line.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-nlmconv.1" install="/usr/man/man1/" filetype="symlink" linkto="nlmconv.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-c++filt.1" install="/usr/man/man1/" filetype="symlink" linkto="c++filt.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-as.1" install="/usr/man/man1/" filetype="symlink" linkto="as.1" target="x86" proc="x86" />
+<QPG:Add file="ntox86-ld.1" install="/usr/man/man1/" filetype="symlink" linkto="ld.1" target="x86" proc="x86" />
+
+<QPG:Add file="ntoppc-ar.1" install="/usr/man/man1/" filetype="symlink" linkto="ar.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-nm.1" install="/usr/man/man1/" filetype="symlink" linkto="nm.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-objdump.1" install="/usr/man/man1/" filetype="symlink" linkto="objdump.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-ranlib.1" install="/usr/man/man1/" filetype="symlink" linkto="ranlib.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-size.1" install="/usr/man/man1/" filetype="symlink" linkto="size.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-strings.1" install="/usr/man/man1/" filetype="symlink" linkto="strings.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-strip.1" install="/usr/man/man1/" filetype="symlink" linkto="strip.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-objcopy.1" install="/usr/man/man1/" filetype="symlink" linkto="objcopy.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-addr2line.1" install="/usr/man/man1/" filetype="symlink" linkto="addr2line.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-nlmconv.1" install="/usr/man/man1/" filetype="symlink" linkto="nlmconv.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-c++filt.1" install="/usr/man/man1/" filetype="symlink" linkto="c++filt.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-as.1" install="/usr/man/man1/" filetype="symlink" linkto="as.1" target="ppc" proc="x86" />
+<QPG:Add file="ntoppc-ld.1" install="/usr/man/man1/" filetype="symlink" linkto="ld.1" target="ppc" proc="x86" />
+
+<QPG:Add file="ntomips-ar.1" install="/usr/man/man1/" filetype="symlink" linkto="ar.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-nm.1" install="/usr/man/man1/" filetype="symlink" linkto="nm.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-objdump.1" install="/usr/man/man1/" filetype="symlink" linkto="objdump.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-ranlib.1" install="/usr/man/man1/" filetype="symlink" linkto="ranlib.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-size.1" install="/usr/man/man1/" filetype="symlink" linkto="size.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-strings.1" install="/usr/man/man1/" filetype="symlink" linkto="strings.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-strip.1" install="/usr/man/man1/" filetype="symlink" linkto="strip.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-objcopy.1" install="/usr/man/man1/" filetype="symlink" linkto="objcopy.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-addr2line.1" install="/usr/man/man1/" filetype="symlink" linkto="addr2line.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-nlmconv.1" install="/usr/man/man1/" filetype="symlink" linkto="nlmconv.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-c++filt.1" install="/usr/man/man1/" filetype="symlink" linkto="c++filt.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-as.1" install="/usr/man/man1/" filetype="symlink" linkto="as.1" target="mips" proc="x86" />
+<QPG:Add file="ntomips-ld.1" install="/usr/man/man1/" filetype="symlink" linkto="ld.1" target="mips" proc="x86" />
+
+<QPG:Add file="ntoarm-ar.1" install="/usr/man/man1/" filetype="symlink" linkto="ar.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-nm.1" install="/usr/man/man1/" filetype="symlink" linkto="nm.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-objdump.1" install="/usr/man/man1/" filetype="symlink" linkto="objdump.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-ranlib.1" install="/usr/man/man1/" filetype="symlink" linkto="ranlib.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-size.1" install="/usr/man/man1/" filetype="symlink" linkto="size.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-strings.1" install="/usr/man/man1/" filetype="symlink" linkto="strings.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-strip.1" install="/usr/man/man1/" filetype="symlink" linkto="strip.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-objcopy.1" install="/usr/man/man1/" filetype="symlink" linkto="objcopy.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-addr2line.1" install="/usr/man/man1/" filetype="symlink" linkto="addr2line.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-nlmconv.1" install="/usr/man/man1/" filetype="symlink" linkto="nlmconv.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-c++filt.1" install="/usr/man/man1/" filetype="symlink" linkto="c++filt.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-as.1" install="/usr/man/man1/" filetype="symlink" linkto="as.1" target="arm" proc="x86" />
+<QPG:Add file="ntoarm-ld.1" install="/usr/man/man1/" filetype="symlink" linkto="ld.1" target="arm" proc="x86" />
+
+<QPG:Add file="ntosh-ar.1" install="/usr/man/man1/" filetype="symlink" linkto="ar.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-nm.1" install="/usr/man/man1/" filetype="symlink" linkto="nm.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-objdump.1" install="/usr/man/man1/" filetype="symlink" linkto="objdump.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-ranlib.1" install="/usr/man/man1/" filetype="symlink" linkto="ranlib.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-size.1" install="/usr/man/man1/" filetype="symlink" linkto="size.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-strings.1" install="/usr/man/man1/" filetype="symlink" linkto="strings.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-strip.1" install="/usr/man/man1/" filetype="symlink" linkto="strip.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-objcopy.1" install="/usr/man/man1/" filetype="symlink" linkto="objcopy.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-addr2line.1" install="/usr/man/man1/" filetype="symlink" linkto="addr2line.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-nlmconv.1" install="/usr/man/man1/" filetype="symlink" linkto="nlmconv.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-c++filt.1" install="/usr/man/man1/" filetype="symlink" linkto="c++filt.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-as.1" install="/usr/man/man1/" filetype="symlink" linkto="as.1" target="sh" proc="x86" />
+<QPG:Add file="ntosh-ld.1" install="/usr/man/man1/" filetype="symlink" linkto="ld.1" target="sh" proc="x86" />
+
+<!-- Shared Objects links -->
+<QPG:Add file="libbfd.so" install="/usr/lib/" filetype="symlink" linkto="libbfd-2.10.1.so" target="none" proc="x86" />
+<QPG:Add file="libopcodes.so" install="/usr/lib/" filetype="symlink" linkto="libopcodes-2.10.1.so" target="none" proc="x86" />
+
+      </QPG:Files>
+   </QPG:Values>
+</QPG:Generation>
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/texinfo/texinfo.tex binutils/texinfo/texinfo.tex
--- binutils-2.10.1/texinfo/texinfo.tex	1999-06-12 19:59:55.000000000 +1000
+++ binutils/texinfo/texinfo.tex	2001-02-27 04:45:23.000000000 +1000
@@ -1,5 +1,5 @@
 % texinfo.tex -- TeX macros to handle Texinfo files.
-% $Id: texinfo.tex,v 1.1 1999/06/12 09:59:55 ian Exp $
+% $Id: texinfo.tex,v 1.1.1.1 2001/02/26 18:45:23 keith Exp $
 %
 % Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98
 % Free Software Foundation, Inc.
@@ -58,7 +58,7 @@
 
 % This automatically updates the version number based on RCS.
 \def\deftexinfoversion$#1: #2 ${\def\texinfoversion{#2}}
-\deftexinfoversion$Revision: 1.1 $
+\deftexinfoversion$Revision: 1.1.1.1 $
 \message{Loading texinfo package [Version \texinfoversion]:}
 
 % If in a .fmt file, print the version number
diff -urN -x Entries -x Root -x Repository binutils-2.10.1/update-pinfo binutils/update-pinfo
--- binutils-2.10.1/update-pinfo	1970-01-01 10:00:00.000000000 +1000
+++ binutils/update-pinfo	2001-04-05 06:16:31.000000000 +1000
@@ -0,0 +1,19 @@
+#/bin/ksh
+
+while read dest source
+do
+	sh build-pinfo $source
+done <<EOF
+/usr/lib/	nto/all/bfd/.libs/libbfd-2.10.1.so
+/usr/lib/	nto/all/opcodes/.libs/libopcodes-2.10.1.so
+/usr/bin/	nto/all/binutils/.libs/size
+/usr/bin/	nto/all/binutils/.libs/objdump
+/usr/bin/	nto/all/binutils/.libs/ar
+/usr/bin/	nto/all/binutils/.libs/strings
+/usr/bin/	nto/all/binutils/.libs/ranlib
+/usr/bin/	nto/all/binutils/.libs/objcopy
+/usr/bin/	nto/all/binutils/.libs/addr2line
+/usr/bin/	nto/all/binutils/readelf
+/usr/bin/	nto/all/gprof/.libs/gprof
+EOF
+exit
